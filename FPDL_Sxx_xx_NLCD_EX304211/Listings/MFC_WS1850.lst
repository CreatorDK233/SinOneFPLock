C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/21/2023 14:57:02 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MFC_WS1850
OBJECT MODULE PLACED IN .\Objects\MFC_WS1850.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Drivers\Protocol\MFC_WS1850.c LARGE OMF2 OPTIMIZE(9,SPEED) BROWSE INCDIR
                    -(.\Drivers\Lib\c;.\Drivers\Lib\H;.\Drivers\Lib\IAP_Lib;.\Drivers\Lib\TouchKey_lib;.\Drivers\Physical;.\Drivers\Protocol;
                    -.\Softwares\Application;.\Softwares\Basic;.\Softwares\ModuleLogic;.\Drivers\Protocol\YC_NFC;.\Drivers\Protocol\WIFI_Tuya
                    -) DEBUG PRINT(.\Listings\MFC_WS1850.lst) TABS(2) OBJECT(.\Objects\MFC_WS1850.obj)

line level    source

   1          #include "IO.h"
   2          #include "I2cBus.h"
   3          #include "StdTypes.h"
   4          #include "Basic_Function.h"
   5          
   6          #ifdef Function_NFCUsed_1850X
   7          #define MAXRLEN        18
   8          #define MIN_STRENGTH  228
   9          //******************************************************************/
  10          //                    RC522 FIFO长度定义                            /
  11          //******************************************************************/
  12          #define DEF_FIFO_LENGTH             64           //FIFO size=64byte
  13          
  14          //******************************************************************/
  15          //                       RC522命令字                                /
  16          //******************************************************************/
  17          #define PCD_SLEEP                 0x10           //取消当前命令
  18          #define PCD_IDLE                  0x00           //取消当前命令
  19          #define PCD_AUTHENT               0x0E           //验证密钥
  20          #define PCD_RECEIVE               0x08           //接收数据
  21          #define PCD_TRANSMIT              0x04           //发送数据
  22          #define PCD_TRANSCEIVE            0x0C           //发送并接收数据
  23          #define PCD_RESETPHASE            0x0F           //复位
  24          #define PCD_CALCCRC               0x03           //CRC计算
  25          
  26          //******************************************************************/
  27          //                   Mifare_One卡片命令字                          */
  28          //******************************************************************/
  29          #define PICC_REQIDL               0x26           //寻天线区内未进入休眠状态
  30          #define PICC_REQALL               0x52           //寻天线区内全部卡
  31          #define PICC_ANTICOLL1            0x93           //防冲撞
  32          #define PICC_ANTICOLL2            0x95           //防冲撞
  33          #define PICC_AUTHENT1A            0x60           //验证A密钥
  34          #define PICC_AUTHENT1B            0x61           //验证B密钥
  35          #define PICC_READ                 0x30           //读块
  36          #define PICC_WRITE                0xA0           //写块
  37          #define PICC_DECREMENT            0xC0           //扣款
  38          #define PICC_INCREMENT            0xC1           //充值
  39          #define PICC_RESTORE              0xC2           //调块数据到缓冲区
  40          #define PICC_TRANSFER             0xB0           //保存缓冲区中数据
  41          #define PICC_HALT                 0x50           //休眠
  42          
  43          //******************************************************************/
  44          //                        MF522寄存器定义                           /
  45          //******************************************************************/
  46          // PAGE 0
  47          #define     RFU00                 0x00    
  48          #define     CommandReg            0x01    
  49          #define     ComIEnReg             0x02    
  50          #define     DivlEnReg             0x03    
  51          #define     ComIrqReg             0x04    
  52          #define     DivIrqReg             0x05
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/21/2023 14:57:02 PAGE 2   

  53          #define     ErrorReg              0x06    
  54          #define     Status1Reg            0x07    
  55          #define     Status2Reg            0x08    
  56          #define     FIFODataReg           0x09
  57          #define     FIFOLevelReg          0x0A
  58          #define     WaterLevelReg         0x0B
  59          #define     ControlReg            0x0C
  60          #define     BitFramingReg         0x0D
  61          #define     CollReg               0x0E
  62          #define     RFU0F                 0x0F
  63          // PAGE 1     
  64          #define     RFU10                 0x10
  65          #define     ModeReg               0x11
  66          #define     TxModeReg             0x12
  67          #define     RxModeReg             0x13
  68          #define     TxControlReg          0x14
  69          #define     TxASKReg              0x15
  70          #define     TxSelReg              0x16
  71          #define     RxSelReg              0x17
  72          #define     RxThresholdReg        0x18
  73          #define     DemodReg              0x19
  74          #define     RFU1A                 0x1A
  75          #define     RFU1B                 0x1B
  76          #define     MifareReg             0x1C
  77          #define     RFU1D                 0x1D
  78          #define     RFU1E                 0x1E
  79          #define     SerialSpeedReg        0x1F
  80          // PAGE 2    
  81          #define     RFU20                 0x20  
  82          #define     CRCResultRegM         0x21
  83          #define     CRCResultRegL         0x22
  84          #define     RFU23                 0x23
  85          #define     ModWidthReg           0x24
  86          #define     RFU25                 0x25
  87          #define     RFCfgReg              0x26
  88          #define     GsNReg                0x27
  89          #define     CWGsCfgReg            0x28
  90          #define     ModGsCfgReg           0x29
  91          #define     TModeReg              0x2A
  92          #define     TPrescalerReg         0x2B
  93          #define     TReloadRegH           0x2C
  94          #define     TReloadRegL           0x2D
  95          #define     TCounterValueRegH     0x2E
  96          #define     TCounterValueRegL     0x2F
  97          // PAGE 3      
  98          #define     RFU30                 0x30
  99          #define     TestSel1Reg           0x31
 100          #define     TestSel2Reg           0x32
 101          #define     TestPinEnReg          0x33
 102          #define     TestPinValueReg       0x34
 103          #define     TestBusReg            0x35
 104          #define     AutoTestReg           0x36
 105          #define     VersionReg            0x37
 106          #define     AnalogTestReg         0x38
 107          #define     TestDAC1Reg           0x39  
 108          #define     TestDAC2Reg           0x3A   
 109          #define     TestADCReg            0x3B   
 110          #define     RFU3C                 0x3C   
 111          #define     RFU3D                 0x3D   
 112          #define     RFU3E                 0x3E   
 113          #define     RFU3F                 0x3F
 114          
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/21/2023 14:57:02 PAGE 3   

 115          //******************************************************************/
 116          //                    RC522通讯返回错误代码                         /
 117          //******************************************************************/
 118          #define MI_ERR                      0xFE 
 119          //#define MI_ERR                         //(-2)
 120          
 121          
 122          // Mifare Error Codes 
 123          // Each function returns a status value, which corresponds to the 
 124          // mifare error codes. 
 125          
 126          #define MI_OK                          0 
 127          #define MI_CHK_OK                      0 
 128          #define MI_CRC_ZERO                    0 
 129          
 130          #define MI_CRC_NOTZERO                 1 
 131          
 132          #define MI_NOTAGERR                 0xFF 
 133          #define MI_CHK_S_FAILED             0xFF 
 134          #define MI_CRCERR                   0xFE 
 135          #define MI_CHK_COMPERR              0xFE 
 136          #define MI_EMPTY                    0xFD 
 137          #define MI_AUTHERR                  0xFC 
 138          #define MI_PARITYERR                0xFB 
 139          #define MI_CODEERR                  0xFA 
 140          
 141          #define MI_SERNRERR                 0xF8 
 142          #define MI_KEYERR                   0xF7 
 143          #define MI_NOTAUTHERR               0xF6 
 144          #define MI_BITCOUNTERR              0xF5 
 145          #define MI_BYTECOUNTERR             0xF4 
 146          #define MI_IDLE                     0xF3 
 147          #define MI_TRANSERR                 0xF2 
 148          #define MI_WRITEERR                 0xF1 
 149          #define MI_INCRERR                  0xF0 
 150          #define MI_DECRERR                  0xEF 
 151          #define MI_READERR                  0xEE 
 152          #define MI_OVFLERR                  0xED 
 153          #define MI_POLLING                  0xEC 
 154          #define MI_FRAMINGERR               0xEB 
 155          #define MI_ACCESSERR                0xEA 
 156          #define MI_UNKNOWN_COMMAND          0xE9 
 157          #define MI_COLLERR                  0xE8 
 158          #define MI_RESETERR                 0xE7 
 159          #define MI_INITERR                  0xE7 
 160          #define MI_INTERFACEERR             0xE7 
 161          #define MI_ACCESSTIMEOUT            0xE5 
 162          #define MI_NOBITWISEANTICOLL        0xE4 
 163          #define MI_QUIT                     0xE2 
 164          
 165          #define MI_RECBUF_OVERFLOW          0xCF 
 166          #define MI_SENDBYTENR               0xCE 
 167          
 168          #define MI_SENDBUF_OVERFLOW         0xCC 
 169          #define MI_BAUDRATE_NOT_SUPPORTED   0xCB 
 170          #define MI_SAME_BAUDRATE_REQUIRED   0xCA 
 171          
 172          #define MI_WRONG_PARAMETER_VALUE    0xC5 
 173          
 174          #define MI_BREAK                    0x9E 
 175          #define MI_NY_IMPLEMENTED           0x9D 
 176          #define MI_NO_MFRC                  0x9C 
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/21/2023 14:57:02 PAGE 4   

 177          #define MI_MFRC_NOTAUTH             0x9B 
 178          #define MI_WRONG_DES_MODE           0x9A 
 179          #define MI_HOST_AUTH_S_FAILED         0x99 
 180          
 181          #define MI_WRONG_LOAD_MODE          0x97 
 182          #define MI_WRONG_DESKEY             0x96 
 183          #define MI_MKLOAD_S_FAILED            0x95 
 184          #define MI_FIFOERR                  0x94 
 185          #define MI_WRONG_ADDR               0x93 
 186          #define MI_DESKEYLOAD_S_FAILED        0x92 
 187          
 188          #define MI_WRONG_SEL_CNT            0x8F 
 189          #define MI_RC531_WRONG_READVALUE    0x8E //LI ADDED 09-4-24 
 190          #define MI_WRONG_TEST_MODE          0x8C 
 191          #define MI_TEST_S_FAILED              0x8B 
 192          #define MI_TOC_ERROR                0x8A 
 193          #define MI_COMM_ABORT               0x89 
 194          #define MI_INVALID_BASE             0x88 
 195          #define MI_MFRC_RESET               0x87 
 196          #define MI_WRONG_VALUE              0x86 
 197          #define MI_VALERR                   0x85
 198          //******************************************************************/
 199          //                         函数定义                                 /
 200          //******************************************************************/
 201          sint8_t PcdHalt(void);
 202          sint8_t PcdReset(void);
 203          void PcdAntennaOn(void);
 204          void PcdAntennaOff(void);
 205          sint8_t PcdRequest(uint8_t req_code,uint8_t *pTagType);   
 206          sint8_t PcdAnticoll(uint8_t *pSnr);
 207          sint8_t PcdSelect(uint8_t *pSnr);
 208          sint8_t PcdAuthState(uint8_t auth_mode,uint8_t addr,
 209                            uint8_t *pKey,uint8_t *pSnr);     
 210          sint8_t PcdRead(uint8_t addr,uint8_t *pData);     
 211          sint8_t PcdWrite(uint8_t addr,uint8_t *pData);    
 212          sint8_t PcdValue(uint8_t dd_mode,uint8_t addr,uint8_t *pValue);   
 213          sint8_t PcdBakValue(uint8_t sourceaddr, uint8_t goaladdr);                                 
 214          sint8_t PcdComMF522(uint8_t Command, uint8_t *pInData, 
 215                           uint8_t InLenByte,uint8_t *pOutData, 
 216                           uint16_t  *pOutLenBit);
 217          void CalulateCRC(uint8_t *pIndata,uint8_t len,
 218                           uint8_t *pOutData);
 219          void WriteRawRC(uint8_t Address,uint8_t value);
 220          uint8_t ReadRawRC(uint8_t Address); 
 221          void SetBitMask(uint8_t reg,uint8_t mask); 
 222          void ClearBitMask(uint8_t reg,uint8_t mask); 
 223          sint8_t Read_Block(uint8_t Block,uint8_t *Buf);
 224          sint8_t Write_Block(uint8_t Block);
 225          void PcdAntennaTestOn(void);
 226          
 227          extern sint8_t KK[8]; // 数据加密密钥
 228          static uint8_t RF_Buffer[18]; // 射频卡数据缓冲区
 229          static uint8_t UID[5];
 230          static uint8_t Password_Buffer[6]={0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
 231          //extern void Des_Encrypt(sint8_t* In, sint8_t* K,sint8_t* Out);
 232          //extern void Des_Decrypt(sint8_t* In, sint8_t* K,sint8_t* Out);
 233          static uint8_t des_on; // DES加密标志
 234          
 235          static uint8_t TestVal;
 236          static uint8_t TestBuff[20];
 237          
 238          static uint8_t HAL_SPI2_RXBUFF;
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/21/2023 14:57:02 PAGE 5   

 239          #ifdef Function_CardReaderUseSPI
              //******************************************************************/
              //功    能：读RC522寄存器
              //参数说明：Address[IN]:寄存器地址
              //返    回：读出的值
              //******************************************************************/
              uint8_t ReadRawRC(uint8_t Address)
              {
                uint8_t ucResult;
                HAL_StatusTypeDef HAL_STATUS;
                
                SET_MFC_CS_L;
                Hardware_DelayX1us(10);
              //  Hardware_DelayMs(10);
                ucResult = (Address<<1)|0x80;
                
                HAL_STATUS = HAL_SPI_Transmit(&hspi1,&ucResult,1,10);
                HAL_STATUS = HAL_SPI_Receive(&hspi1,&HAL_SPI2_RXBUFF,1,10);
                SET_MFC_CS_H;
              
              //  Hardware_DelayMs(10);
                Hardware_DelayX1us(10);
                return HAL_SPI2_RXBUFF;
              }
              
              //******************************************************************/
              //功    能：写RC522寄存器
              //参数说明：Address[IN]:寄存器地址
              //          value[IN]:写入的值
              //******************************************************************/
              void  WriteRawRC(uint8_t Address, uint8_t value)
              {
                uint8_t temp;
                HAL_StatusTypeDef HAL_STATUS;
                
                SET_MFC_CS_L;
                Hardware_DelayX1us(10);
                
                temp = Address<<1;
                HAL_STATUS = HAL_SPI_Transmit(&hspi1,&temp,1,500);
                HAL_STATUS = HAL_SPI_Transmit(&hspi1,&value,1,500);
                SET_MFC_CS_H;
                //Hardware_DelayX1us(100);
              }
              
              #else
 285          uint8_t ReadRawRC(uint8_t Address)
 286          {
 287   1        uint8_t ucResult;
 288   1        I2C_ReadRandom(I2CADDR_MFC,Address,&ucResult);
 289   1        return ucResult;
 290   1      }
 291          void WriteRawRC(uint8_t Address, uint8_t value)
 292          {  
 293   1        I2C_WriteRandom(I2CADDR_MFC,Address,value);
 294   1      }
 295          #endif
 296          
 297          //******************************************************************/
 298          //功    能：置RC522寄存器位
 299          //参数说明：reg[IN]:寄存器地址
 300          //          mask[IN]:置位值
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/21/2023 14:57:02 PAGE 6   

 301          //******************************************************************/
 302          void SetBitMask(uint8_t reg,uint8_t mask)  
 303          {
 304   1        sint8_t tmp = 0x00;
 305   1        tmp = ReadRawRC(reg)| mask;
 306   1        WriteRawRC(reg, tmp);  // set bit mask
 307   1      }
 308          
 309          //******************************************************************/
 310          //功    能：清RC522寄存器位
 311          //参数说明：reg[IN]:寄存器地址
 312          //          mask[IN]:清位值
 313          //******************************************************************/
 314          void ClearBitMask(uint8_t reg,uint8_t mask)  
 315          {
 316   1        sint8_t tmp = 0x00;
 317   1        tmp = ReadRawRC(reg)&(~mask);
 318   1        WriteRawRC(reg, tmp)        ;  // clear bit mask
 319   1      } 
 320          
 321          //******************************************************************/
 322          //功    能：复位RC522
 323          //返    回: 成功返回MI_OK
 324          //******************************************************************/
 325          sint8_t PcdReset(void)
 326          {
 327   1        //SET_MFC_RST_H;
 328   1        //Hardware_DelayMs(1);
 329   1        SET_MFC_RST_L;
 330   1        Hardware_DelayX1us(10);
 331   1        SET_MFC_RST_H;
 332   1        Hardware_DelayX1us(50);
 333   1        
 334   1        WriteRawRC(CommandReg,PCD_RESETPHASE);
 335   1        Hardware_DelayMs(5);
 336   1        
 337   1        WriteRawRC(RFCfgReg,0x48)       ; 
 338   1        /* 增益调整 GsN前后两位独立 CWGsCfg最大0x3F ModGsCfg最大0x3F*/
 339   1        WriteRawRC(GsNReg,0xFF); 
 340   1        WriteRawRC(CWGsCfgReg,0x3F); 
 341   1        WriteRawRC(ModGsCfgReg,0x3F); 
 342   1        
 343   1        
 344   1        WriteRawRC(ModeReg,0x3D);
 345   1        WriteRawRC(TReloadRegL,30);
 346   1        WriteRawRC(TReloadRegH,0);
 347   1        
 348   1        WriteRawRC(TModeReg,0x8D);
 349   1        WriteRawRC(TPrescalerReg,0x3E);  
 350   1          
 351   1      //  WriteRawRC(TxASKReg,0x40)            ; // FOR DEBUG AND TEST
 352   1        return MI_OK; 
 353   1      }
 354          
 355          //******************************************************************/
 356          //开启天线发射  
 357          //每次启动或关闭天险发射之间应至少有1ms的间隔
 358          //******************************************************************/
 359          void PcdAntennaOn(void)
 360          {
 361   1        //uint8_t i;
 362   1        /*
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/21/2023 14:57:02 PAGE 7   

 363   1        WriteRawRC(TxASKReg,0x40)       ;
 364   1        Hardware_DelayMs(3)            ;
 365   1        i = ReadRawRC(TxControlReg)     ;
 366   1        if(!(i&0x03))
 367   1          SetBitMask(TxControlReg, 0x03);
 368   1        i=ReadRawRC(TxASKReg)       ;
 369   1        */
 370   1        WriteRawRC(TxASKReg,0x40)       ;
 371   1        SetBitMask(TxControlReg, 0x03);
 372   1      }
 373          
 374          //******************************************************************/
 375          //开启天线发射  
 376          //每次启动或关闭天险发射之间应至少有1ms的间隔
 377          //******************************************************************/
 378          void PcdAntennaTestOn(void)
 379          {
 380   1      //*
 381   1        SET_MFC_RST_H                         ;
 382   1        Hardware_DelayMs(15); // 2010.10.09 ???? FOR DEBUG
 383   1        
 384   1        WriteRawRC(TxControlReg,0x02)    ;
 385   1      }
 386          
 387          
 388          //******************************************************************/
 389          //关闭天线发射
 390          //******************************************************************/
 391          void PcdAntennaOff(void)
 392          {
 393   1        //return;
 394   1          ClearBitMask(TxControlReg, 0x03);
 395   1      }
 396          
 397          //******************************************************************/
 398          //功    能：通过RC522和ISO14443卡通讯
 399          //参数说明：Command[IN]:RC522命令字
 400          //          pInData[IN]:通过RC522发送到卡片的数据
 401          //          InLenByte[IN]:发送数据的字节长度
 402          //          pOutData[OUT]:接收到的卡片返回数据
 403          //          *pOutLenBit[OUT]:返回数据的位长度
 404          //******************************************************************/
 405          sint8_t PcdComMF522(uint8_t Command  ,uint8_t *pInData , 
 406                           uint8_t InLenByte,uint8_t *pOutData, 
 407                           uint16_t  *pOutLenBit                       )
 408          {
 409   1        sint8_t status = MI_ERR                          ;
 410   1        uint8_t irqEn   = 0x00                  ;
 411   1        uint8_t waitFor = 0x00                  ;
 412   1        uint8_t lastBits                        ;
 413   1        uint8_t n                               ;
 414   1        uint16_t  i                               ;
 415   1        switch (Command)
 416   1        {
 417   2          case PCD_AUTHENT:
 418   2            irqEn   = 0x12                            ;
 419   2            waitFor = 0x10                            ;
 420   2            break                                     ;
 421   2          case PCD_TRANSCEIVE:
 422   2            irqEn   = 0x20;//0x77                            ;
 423   2            waitFor = 0x30                            ;
 424   2            break                                     ;
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/21/2023 14:57:02 PAGE 8   

 425   2          default:
 426   2            break                                     ;
 427   2        }
 428   1        WriteRawRC(ComIEnReg,irqEn|0x80)              ; //
 429   1        ClearBitMask(ComIrqReg,0x80)                  ;
 430   1        WriteRawRC(CommandReg,PCD_IDLE)               ;
 431   1        SetBitMask(FIFOLevelReg,0x80)                 ; // 清空FIFO 
 432   1        for(i=0; i<InLenByte; i++)
 433   1          WriteRawRC(FIFODataReg,pInData[i])          ; // 数据写入FIFO 
 434   1        WriteRawRC(CommandReg, Command)               ; // 命令写入命令寄存器
 435   1        if(Command == PCD_TRANSCEIVE)
 436   1          SetBitMask(BitFramingReg,0x80)              ; // 开始发送     
 437   1        
 438   1        PcdAntennaOn()                                ;//开启天线发射
 439   1        
 440   1        i = 100                                         ; //根据时钟频率调整，操作M1等待时间15ms
 441   1        do 
 442   1        {
 443   2          n = ReadRawRC(ComIrqReg)                    ;
 444   2          i--                                         ;
 445   2        }
 446   1        while((i!=0)&&!(n&0x01)&&!(n&waitFor))        ;
 447   1        ClearBitMask(BitFramingReg,0x80)              ;
 448   1        if(i!=0)
 449   1        {
 450   2          if(!(ReadRawRC(ErrorReg)&0x1B))
 451   2          {
 452   3            status = MI_OK                            ;
 453   3            if (n&irqEn&0x01)
 454   3              status = MI_NOTAGERR                    ;
 455   3            if(Command==PCD_TRANSCEIVE)
 456   3            {
 457   4              n = ReadRawRC(FIFOLevelReg)             ;
 458   4              lastBits = ReadRawRC(ControlReg)&0x07   ;
 459   4              if(lastBits)
 460   4                *pOutLenBit = (n-1)*8 + lastBits      ;
 461   4              else
 462   4                *pOutLenBit = n*8                     ;
 463   4              if(n==0)
 464   4                n = 1                                 ;
 465   4              if(n>MAXRLEN)
 466   4                n = MAXRLEN                           ;
 467   4              
 468   4             for (i=0; i<n; i++)
 469   4              { 
 470   5                pOutData[i]= ReadRawRC(FIFODataReg)  ; 
 471   5              }
 472   4              
 473   4              DEBUG_MARK;
 474   4            }
 475   3          }
 476   2          else
 477   2            status = MI_ERR;        
 478   2        }
 479   1        else{
 480   2          PcdAntennaOff();
 481   2        }
 482   1        SetBitMask(ControlReg,0x80);// stop timer now
 483   1        WriteRawRC(CommandReg,PCD_IDLE); 
 484   1        return status;
 485   1      }
 486          
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/21/2023 14:57:02 PAGE 9   

 487          //******************************************************************/
 488          //功    能：寻卡                                                    /
 489          //参数说明: req_code[IN]:寻卡方式                                   /
 490          //                0x52 = 寻感应区内所有符合14443A标准的卡           /
 491          //                0x26 = 寻未进入休眠状态的卡                       /
 492          //          pTagType[OUT]：卡片类型代码                             /
 493          //                0x4400 = Mifare_UltraLight                        /
 494          //                0x0400 = Mifare_One(S50)                          /
 495          //                0x0200 = Mifare_One(S70)                          /
 496          //                0x0800 = Mifare_Pro(X)                            /
 497          //                0x4403 = Mifare_DESFire                           /
 498          //返    回: 成功返回MI_OK                                           /
 499          //******************************************************************/
 500          sint8_t PcdRequest(uint8_t req_code,uint8_t *pTagType)
 501          {
 502   1        sint8_t status;  
 503   1        uint16_t  unLen;
 504   1        uint8_t ucComMF522Buf[MAXRLEN]; 
 505   1      
 506   1        ClearBitMask(Status2Reg,0x08);
 507   1        WriteRawRC(BitFramingReg,0x07);
 508   1        SetBitMask(TxControlReg,0x03);
 509   1       
 510   1        ucComMF522Buf[0] = req_code;
 511   1      
 512   1        status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,
 513   1                             1,ucComMF522Buf,&unLen);
 514   1        if ((status == MI_OK) && (unLen == 0x10))
 515   1        {    
 516   2          *pTagType     = ucComMF522Buf[0];
 517   2          *(pTagType+1) = ucComMF522Buf[1];
 518   2        }
 519   1        else
 520   1          status = MI_ERR;
 521   1        return status;
 522   1      }
 523          
 524          //******************************************************************/
 525          //功    能：防冲撞                                                  /
 526          //参数说明: pSnr[OUT]:卡片序列号，4字节                             /
 527          //返    回: 成功返回MI_OK                                           /
 528          //******************************************************************/
 529          sint8_t PcdAnticoll(uint8_t *pSnr)
 530          {
 531   1          sint8_t status;
 532   1          uint8_t i,snr_check=0;
 533   1          uint16_t  unLen;
 534   1          uint8_t ucComMF522Buf[MAXRLEN]; 
 535   1          
 536   1        //return MI_OK;
 537   1        
 538   1          ClearBitMask(Status2Reg,0x08);
 539   1          WriteRawRC(BitFramingReg,0x00);
 540   1          ClearBitMask(CollReg,0x80);
 541   1       
 542   1          ucComMF522Buf[0] = PICC_ANTICOLL1;
 543   1          ucComMF522Buf[1] = 0x20;
 544   1      
 545   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
 546   1      
 547   1          if (status == MI_OK)
 548   1          {
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/21/2023 14:57:02 PAGE 10  

 549   2             for (i=0; i<4; i++)
 550   2               {   
 551   3                   *(pSnr+i)  = ucComMF522Buf[i];
 552   3                   snr_check ^= ucComMF522Buf[i];
 553   3                 TestVal = snr_check;
 554   3               }
 555   2               if (snr_check != ucComMF522Buf[i])
 556   2               {   status = MI_ERR;    }
 557   2          }
 558   1          
 559   1          SetBitMask(CollReg,0x80);
 560   1          return status;
 561   1      }
 562          
 563          /////////////////////////////////////////////////////////////////////
 564          //功    能：选定卡片
 565          //参数说明: pSnr[IN]:卡片序列号，4字节
 566          //返    回: 成功返回MI_OK
 567          /////////////////////////////////////////////////////////////////////
 568          sint8_t PcdSelect(uint8_t *pSnr)
 569          {
 570   1          sint8_t status;
 571   1          uint8_t i;
 572   1          uint16_t  unLen;
 573   1          uint8_t ucComMF522Buf[MAXRLEN]; 
 574   1          
 575   1          ucComMF522Buf[0] = PICC_ANTICOLL1;
 576   1          ucComMF522Buf[1] = 0x70;
 577   1          ucComMF522Buf[6] = 0;
 578   1          for (i=0; i<4; i++)
 579   1          {
 580   2            ucComMF522Buf[i+2] = *(pSnr+i);
 581   2            ucComMF522Buf[6]  ^= *(pSnr+i);
 582   2          }
 583   1          CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
 584   1        
 585   1          ClearBitMask(Status2Reg,0x08);
 586   1      
 587   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
 588   1          
 589   1          if ((status == MI_OK) && (unLen == 0x18))
 590   1          {   status = MI_OK;  }
 591   1          else
 592   1          {   status = MI_ERR;    }
 593   1      
 594   1          return status;
 595   1      }
 596          
 597          //******************************************************************/
 598          //功    能：验证卡片密码
 599          //参数说明: auth_mode[IN]: 密码验证模式
 600          //                 0x60 = 验证A密钥
 601          //                 0x61 = 验证B密钥 
 602          //          addr[IN]：块地址
 603          //          pKey[IN]：密码
 604          //          pSnr[IN]：卡片序列号，4字节
 605          //返    回: 成功返回MI_OK
 606          //******************************************************************/
 607          sint8_t PcdAuthState(uint8_t auth_mode,uint8_t addr,
 608                            uint8_t *pKey,uint8_t *pSnr    )
 609          {
 610   1          sint8_t status;
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/21/2023 14:57:02 PAGE 11  

 611   1          uint16_t  unLen;
 612   1          uint8_t i,ucComMF522Buf[MAXRLEN]; 
 613   1      
 614   1          ucComMF522Buf[0] = auth_mode;
 615   1          ucComMF522Buf[1] = addr;
 616   1          for (i=0; i<6; i++)
 617   1          {    ucComMF522Buf[i+2] = *(pKey+i);   }
 618   1          for (i=0; i<6; i++)
 619   1          {    ucComMF522Buf[i+8] = *(pSnr+i);   }
 620   1          
 621   1          status = PcdComMF522(PCD_AUTHENT,ucComMF522Buf,12,ucComMF522Buf,&unLen);
 622   1          if ((status != MI_OK) || (!(ReadRawRC(Status2Reg) & 0x08)))
 623   1          {   status = MI_ERR;   }
 624   1          
 625   1          return status;
 626   1      }
 627          
 628          //******************************************************************/
 629          //功    能：读取M1卡一块数据
 630          //参数说明: addr[IN]：块地址
 631          //          pData[OUT]：读出的数据，16字节
 632          //返    回: 成功返回MI_OK
 633          //******************************************************************/
 634          sint8_t PcdRead(uint8_t addr,uint8_t *pData)
 635          {
 636   1          sint8_t status                                          ;
 637   1          uint16_t  unLen                                  ;
 638   1          uint8_t i;uint8_t ucComMF522Buf[MAXRLEN]               ; 
 639   1      
 640   1          ucComMF522Buf[0] = PICC_READ                         ;
 641   1          ucComMF522Buf[1] = addr                              ;
 642   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2])       ;   
 643   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,
 644   1                               ucComMF522Buf,&unLen           );
 645   1          if ((status == MI_OK) && (unLen == 0x90))
 646   1          {
 647   2              for (i=0; i<16; i++)
 648   2                  *(pData+i) = ucComMF522Buf[i];   
 649   2          }
 650   1          else
 651   1            status = MI_ERR;       
 652   1          return status;
 653   1      }
 654          
 655          //******************************************************************/
 656          //功    能：读取M1卡一块数据
 657          //参数说明: addr[IN]：块地址
 658          //          pData[OUT]：读出的数据，16字节
 659          //返    回: 成功返回MI_OK
 660          //******************************************************************/
 661          sint8_t Read_Block(uint8_t Block,uint8_t *Buf)
 662          {
 663   1        sint8_t result                                          ;
 664   1      
 665   1        result = PcdAuthState(0x60,Block,Password_Buffer,UID)   ;
 666   1        if(result!=MI_OK)
 667   1          return result                                         ;
 668   1        result = PcdRead(Block,Buf)                             ;
 669   1      //  return result; // 2011.01.03
 670   1        
 671   1        if(result!=MI_OK)     return   result                   ;
 672   1        if(Block!=0x00&&des_on)
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/21/2023 14:57:02 PAGE 12  

 673   1        {
 674   2          /*
 675   2          Des_Decrypt((sint8_t *)Buf,KK,(sint8_t *)Buf);
 676   2          Des_Decrypt((sint8_t *)&Buf[8],KK,(sint8_t *)&Buf[8]);  
 677   2          */
 678   2        }
 679   1        return MI_OK                                            ; 
 680   1      }
 681          
 682          //******************************************************************/
 683          //功    能：写数据到M1卡一块
 684          //参数说明: addr[IN]：块地址
 685          //          pData[IN]：写入的数据，16字节
 686          //返    回: 成功返回MI_OK
 687          //******************************************************************/
 688          sint8_t PcdWrite(uint8_t addr,uint8_t *pData)
 689          {
 690   1        sint8_t status                                          ;
 691   1        uint16_t  unLen                                     ;
 692   1        uint8_t i;uint8_t ucComMF522Buf[MAXRLEN]                ; 
 693   1          
 694   1        ucComMF522Buf[0] = PICC_WRITE                           ;
 695   1        ucComMF522Buf[1] = addr                                 ;
 696   1        CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2])          ;
 697   1        status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,
 698   1                             ucComMF522Buf,&unLen          )    ;
 699   1        if(  ( status != MI_OK)||(unLen != 4)
 700   1           ||((ucComMF522Buf[0]&0x0F)!= 0x0A))
 701   1          status = MI_ERR                                       ;           
 702   1        if (status == MI_OK)
 703   1        {
 704   2          for (i=0; i<16; i++)
 705   2            ucComMF522Buf[i] = *(pData+i)                       ;  
 706   2          CalulateCRC(ucComMF522Buf,16,&ucComMF522Buf[16])      ;
 707   2          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,
 708   2                               18,ucComMF522Buf,&unLen     )    ;
 709   2          if(  (status != MI_OK)||(unLen != 4 )
 710   2             ||((ucComMF522Buf[0]&0x0F)!= 0x0A))
 711   2            status = MI_ERR                                     ;   
 712   2        }    
 713   1        return status                                           ;
 714   1      }
 715          //******************************************************************/
 716          //功    能：写数据到M1卡一块
 717          //参数说明: addr[IN]：块地址
 718          //          pData[IN]：写入的数据，16字节
 719          //返    回: 成功返回MI_OK
 720          //******************************************************************/
 721          
 722          sint8_t Write_Block(uint8_t Block)
 723          {
 724   1        sint8_t result                                          ;
 725   1        if(des_on)
 726   1        {
 727   2      /*    Des_Encrypt((sint8_t *)RF_Buffer    ,KK,
 728   2                      (sint8_t *)RF_Buffer        )                ;// for debug
 729   2          Des_Encrypt((sint8_t *)&RF_Buffer[8],KK,
 730   2                      (sint8_t *)&RF_Buffer[8]    )                ;// for debug  
 731   2      */                
 732   2        }
 733   1        result = PcdAuthState(0x60,Block,Password_Buffer,UID)   ;
 734   1        if(result!=MI_OK)
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/21/2023 14:57:02 PAGE 13  

 735   1          return result                                         ;  
 736   1        result = PcdWrite(Block,RF_Buffer)                      ;
 737   1        return result                                           ;  
 738   1      }
 739          
 740          //******************************************************************/
 741          //功    能：扣款和充值
 742          //参数说明: dd_mode[IN]：命令字
 743          //               0xC0 = 扣款
 744          //               0xC1 = 充值
 745          //          addr[IN]：钱包地址
 746          //          pValue[IN]：4字节增(减)值，低位在前
 747          //返    回: 成功返回MI_OK
 748          //******************************************************************/
 749          sint8_t PcdValue(uint8_t dd_mode,uint8_t addr,uint8_t *pValue)
 750          {
 751   1          sint8_t status;
 752   1          uint16_t  unLen;
 753   1          uint8_t i,ucComMF522Buf[MAXRLEN]; 
 754   1          
 755   1          ucComMF522Buf[0] = dd_mode;
 756   1          ucComMF522Buf[1] = addr;
 757   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 758   1       
 759   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 760   1      
 761   1          if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
 762   1          {   status = MI_ERR;   }
 763   1              
 764   1          if (status == MI_OK)
 765   1          {
 766   2              for (i=0; i<16; i++)
 767   2              {    ucComMF522Buf[i] = *(pValue+i);   }
 768   2              CalulateCRC(ucComMF522Buf,4,&ucComMF522Buf[4]);
 769   2              unLen = 0;
 770   2              status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,6,ucComMF522Buf,&unLen);
 771   2              if (status != MI_ERR)
 772   2              {    status = MI_OK;    }
 773   2          }
 774   1          
 775   1          if (status == MI_OK)
 776   1          {
 777   2              ucComMF522Buf[0] = PICC_TRANSFER;
 778   2              ucComMF522Buf[1] = addr;
 779   2              CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]); 
 780   2         
 781   2              status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 782   2      
 783   2              if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
 784   2              {   status = MI_ERR;   }
 785   2          }
 786   1          return status;
 787   1      }
 788          
 789          //******************************************************************/
 790          //功    能：备份钱包
 791          //参数说明: sourceaddr[IN]：源地址
 792          //          goaladdr[IN]：目标地址
 793          //返    回: 成功返回MI_OK
 794          //******************************************************************/
 795          sint8_t PcdBakValue(uint8_t sourceaddr, uint8_t goaladdr)
 796          {
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/21/2023 14:57:02 PAGE 14  

 797   1          sint8_t status;
 798   1          uint16_t  unLen;
 799   1          uint8_t ucComMF522Buf[MAXRLEN]; 
 800   1      
 801   1          ucComMF522Buf[0] = PICC_RESTORE;
 802   1          ucComMF522Buf[1] = sourceaddr;
 803   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 804   1       
 805   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 806   1      
 807   1          if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
 808   1          {   status = MI_ERR;   }
 809   1          
 810   1          if (status == MI_OK)
 811   1          {
 812   2              ucComMF522Buf[0] = 0;
 813   2              ucComMF522Buf[1] = 0;
 814   2              ucComMF522Buf[2] = 0;
 815   2              ucComMF522Buf[3] = 0;
 816   2              CalulateCRC(ucComMF522Buf,4,&ucComMF522Buf[4]);
 817   2       
 818   2              status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,6,ucComMF522Buf,&unLen);
 819   2              if (status != MI_ERR)
 820   2              {    status = MI_OK;    }
 821   2          }
 822   1          
 823   1          if (status != MI_OK)
 824   1          {    return MI_ERR;   }
 825   1          
 826   1          ucComMF522Buf[0] = PICC_TRANSFER;
 827   1          ucComMF522Buf[1] = goaladdr;
 828   1      
 829   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 830   1       
 831   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 832   1      
 833   1          if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
 834   1          {   status = MI_ERR;   }
 835   1      
 836   1          return status;
 837   1      }
 838          
 839          
 840          //******************************************************************/
 841          //功    能：命令卡片进入休眠状态
 842          //返    回: 成功返回MI_OK
 843          //******************************************************************/
 844          sint8_t PcdHalt(void)
 845          {
 846   1          sint8_t status;
 847   1          uint16_t  unLen;
 848   1          uint8_t ucComMF522Buf[MAXRLEN]; 
 849   1      
 850   1          ucComMF522Buf[0] = PICC_HALT;
 851   1          ucComMF522Buf[1] = 0;
 852   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 853   1       
 854   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 855   1          return status;
 856   1      //    return MI_OK;
 857   1      }
 858          
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/21/2023 14:57:02 PAGE 15  

 859          //******************************************************************/
 860          //功    能：命令卡片进入休眠状态
 861          //返    回: 成功返回MI_OK
 862          //******************************************************************/
 863          sint8_t MIF_Halt(void)
 864          {
 865   1          sint8_t status;
 866   1          uint16_t  unLen;
 867   1          uint8_t ucComMF522Buf[MAXRLEN]; 
 868   1      
 869   1          ucComMF522Buf[0] = PICC_HALT;
 870   1          ucComMF522Buf[1] = 0;
 871   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 872   1       
 873   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 874   1          return status ;  
 875   1      //    return MI_OK;
 876   1      }
 877          
 878          
 879          
 880          //******************************************************************/
 881          //用MF522计算CRC16函数
 882          //******************************************************************/
 883          void CalulateCRC(uint8_t *pIndata,uint8_t len,uint8_t *pOutData)
 884          {
 885   1          uint8_t i,n;
 886   1          ClearBitMask(DivIrqReg,0x04);
 887   1          WriteRawRC(CommandReg,PCD_IDLE);
 888   1          SetBitMask(FIFOLevelReg,0x80);
 889   1          for (i=0; i<len; i++)
 890   1          {   WriteRawRC(FIFODataReg, *(pIndata+i));   }
 891   1          WriteRawRC(CommandReg, PCD_CALCCRC);
 892   1          i = 0xFF;
 893   1          do 
 894   1          {
 895   2              n = ReadRawRC(DivIrqReg);
 896   2              i--;
 897   2          }
 898   1          while ((i!=0) && !(n&0x04));
 899   1          pOutData[0] = ReadRawRC(CRCResultRegL);
 900   1          pOutData[1] = ReadRawRC(CRCResultRegM);
 901   1      }
 902          
 903          
 904          status_t Find_Card(void)
 905          {
 906   1      
 907   1        //sint8_t status = MI_ERR ;
 908   1        uint8_t irqEn  = 0x00    ;
 909   1        uint8_t waitFor = 0x00   ;
 910   1        //uint8_t lastBits         ;
 911   1        uint8_t n                ;
 912   1        uint16_t  i              ;
 913   1       
 914   1        //ENTKS = 0;
 915   1       //ClearBitMask(ComIrqReg,0x80);    //release IRQ PIN
 916   1        ClearBitMask(Status2Reg,0x08);
 917   1        WriteRawRC(BitFramingReg,0x07);
 918   1        SetBitMask(TxControlReg,0x03);
 919   1        Hardware_DelayMs(2);
 920   1        irqEn  = 0x20;//0x77;
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/21/2023 14:57:02 PAGE 16  

 921   1        waitFor = 0x30;
 922   1      
 923   1        WriteRawRC(ComIEnReg,irqEn|0x80); //
 924   1        ClearBitMask(ComIrqReg,0x80);
 925   1        WriteRawRC(CommandReg,PCD_IDLE);
 926   1        SetBitMask(FIFOLevelReg,0x80); // 清空FIFO 
 927   1        WriteRawRC(FIFODataReg,0x52); // 数据写入FIFO 
 928   1        WriteRawRC(CommandReg, PCD_TRANSCEIVE); // 命令写入命令寄存器
 929   1      
 930   1        SetBitMask(BitFramingReg,0x80); // 开始发送  
 931   1         
 932   1        PcdAntennaOn();//开启天线发射
 933   1         
 934   1        i = 15; //根据时钟频率调整，操作M1等待时间15ms
 935   1        do 
 936   1        {
 937   2          n = ReadRawRC(ComIrqReg);
 938   2          i--;
 939   2          if (PINMACRO_NFC_IRQ_STATUS == 0 )
 940   2          {
 941   3            //PcdAntennaOff();
 942   3            return S_SUCCESS;
 943   3          }
 944   2        }
 945   1        while((i!=0)&&!(n&0x01)&&!(n&waitFor));
 946   1      
 947   1        //PcdAntennaOff();
 948   1      
 949   1        return S_FAIL;
 950   1       
 951   1      }
 952          
 953          status_t MFC_Auto_Reader(uint8_t *Point)
 954          {
 955   1        uint8_t i;
 956   1         
 957   1      //  return S_FAIL;
 958   1          
 959   1        //PcdAntennaOn();//开启天线发射 
 960   1      //  Hardware_DelayMs(1);
 961   1      
 962   1        //PA_ODR |=SETBIT2;
 963   1        
 964   1        if ( Find_Card() == S_SUCCESS )
 965   1        {
 966   2          if(PcdAnticoll(UID)==MI_OK)
 967   2          {   
 968   3            DEBUG_MARK;
 969   3            if ( PcdSelect(UID) == MI_OK )
 970   3            {
 971   4              PcdAntennaOff();
 972   4              SetBitMask(ControlReg,0x80);// stop timer now
 973   4                WriteRawRC(CommandReg,PCD_IDLE); 
 974   4              
 975   4              for (i=0;i<4;i++)
 976   4              {
 977   5                *Point = UID[i];
 978   5                Point++;
 979   5              }
 980   4              DEBUG_MARK;
 981   4              return S_SUCCESS;
 982   4            }
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/21/2023 14:57:02 PAGE 17  

 983   3          }
 984   2        }
 985   1        PcdAntennaOff();
 986   1        SetBitMask(ControlReg,0x80);// stop timer now
 987   1          WriteRawRC(CommandReg,PCD_IDLE); 
 988   1        //WriteRawRC(CommandReg,PCD_SLEEP);
 989   1      
 990   1        //PA_ODR &=CLRBIT2; 
 991   1        return S_FAIL;
 992   1      }
 993          
 994          status_t MFC_ReadLockBrandData(uint8_t *buff)
 995          {
 996   1        uint8_t i;
 997   1        uint8_t tempBuff[224];
 998   1        status_t TempResult;
 999   1        
1000   1        TempResult = S_FAIL;
1001   1        if ( Find_Card() == S_SUCCESS )
1002   1        {
1003   2          if(PcdAnticoll(UID)==MI_OK)
1004   2          {
1005   3            if( PcdSelect(UID)==MI_OK )
1006   3            {
1007   4              if ( Read_Block(0x04,tempBuff) == MI_OK ) //for save identify byte
1008   4              { 
1009   5                if (  (tempBuff[0] == 0x11)
1010   5                    &&(tempBuff[1] == 0x55)
1011   5                    &&(tempBuff[2] == 0xAA)
1012   5                    &&(tempBuff[3] == 0xDD)
1013   5                    &&(tempBuff[4] == 0xBB)
1014   5                    &&(tempBuff[5] == 0x11)
1015   5                    &&(tempBuff[6] == 0x55)
1016   5                    &&(tempBuff[7] == 0xAA)
1017   5                    &&(tempBuff[8] == 0xDD)
1018   5                    &&(tempBuff[9] == 0xBB) )
1019   5                {
1020   6                  for ( i=0;i<7;i++)
1021   6                  {
1022   7                    if ( Read_Block(4*i+8,&tempBuff[(2*i)*16]) != MI_OK ){
1023   8                      break;
1024   8                    }
1025   7                    if ( Read_Block(4*i+9,&tempBuff[((2*i)+1)*16]) != MI_OK ){
1026   8                      break;
1027   8                    }
1028   7                    CLRWDT();
1029   7                  }
1030   6                  if ( i==7 )
1031   6                  {
1032   7                    for (i=0;i<224;i++)
1033   7                    {
1034   8                      *(buff+i)=tempBuff[i];
1035   8                    }
1036   7                    TempResult = S_SUCCESS;
1037   7                  }
1038   6                }
1039   5              }
1040   4            }
1041   3          }
1042   2        }
1043   1        PcdAntennaOff();
1044   1        SetBitMask(ControlReg,0x80);// stop timer now
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/21/2023 14:57:02 PAGE 18  

1045   1          WriteRawRC(CommandReg,PCD_IDLE); 
1046   1        
1047   1        return TempResult;
1048   1      }
1049          
1050          
1051          void MFC_POWERDOWN(void)
1052          {
1053   1        
1054   1        SET_MFC_RST_L;
1055   1        Hardware_DelayMs(1);
1056   1      
1057   1        //WriteRawRC(CommandReg,PCD_RESETPHASE);
1058   1        //Hardware_DelayMs(1)          ;
1059   1        
1060   1        //WriteRawRC(CommandReg,PCD_SLEEP);
1061   1      }
1062          
1063          void MFC_WAKEUP(void)
1064          { 
1065   1        SET_MFC_RST_H;
1066   1        Hardware_DelayMs(1);
1067   1      /*  
1068   1        WriteRawRC(RFCfgReg,0x78)     ; 
1069   1        WriteRawRC(GsNReg,0xFF)     ; 
1070   1        WriteRawRC(CWGsCfgReg,0x3F)   ; 
1071   1        WriteRawRC(ModGsCfgReg,0x3F)     ; 
1072   1          
1073   1          
1074   1        WriteRawRC(ModeReg,0x3D)       ;
1075   1        WriteRawRC(TReloadRegL,30)       ;
1076   1        WriteRawRC(TReloadRegH,0)      ;
1077   1      
1078   1        WriteRawRC(TModeReg,0x8D)      ;
1079   1        WriteRawRC(TPrescalerReg,0x3E)     ;  
1080   1      */
1081   1        
1082   1        DEBUG_MARK;
1083   1      }
1084          
1085          
1086          void MFC_Init(void)
1087          {
1088   1        PcdReset();//复位RC522
1089   1        //PcdAntennaOn();//开启天线发射 
1090   1        PcdAntennaOff();
1091   1        
1092   1        DEBUG_MARK;
1093   1      }
1094          
1095          
1096          void MFC_Test(void)
1097          {
1098   1             uint8_t i;
1099   1              TestVal = 0x00;
1100   1             DEBUG_MARK;
1101   1        TestVal = ReadRawRC(RFCfgReg);//,0x78)       ; 
1102   1        DEBUG_MARK;
1103   1        TestVal = ReadRawRC(GsNReg);//,0xFF)        ; 
1104   1        DEBUG_MARK;
1105   1        TestVal = ReadRawRC(CWGsCfgReg);//,0x3F)     ; 
1106   1        DEBUG_MARK;
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/21/2023 14:57:02 PAGE 19  

1107   1        TestVal = ReadRawRC(ModGsCfgReg);//,0x3F)     ; 
1108   1        DEBUG_MARK;
1109   1        
1110   1        TestVal = ReadRawRC(ModeReg);//,0x3D)             ;
1111   1        DEBUG_MARK;
1112   1        TestVal = ReadRawRC(TReloadRegL);//,30)           ;
1113   1        DEBUG_MARK;
1114   1        TestVal = ReadRawRC(TReloadRegH);//,0)            ;
1115   1        DEBUG_MARK;
1116   1        
1117   1        TestVal = ReadRawRC(TModeReg);//,0x8D)            ;
1118   1        DEBUG_MARK;
1119   1        TestVal = ReadRawRC(TPrescalerReg);//,0x3E)       ;
1120   1        DEBUG_MARK;
1121   1          TestVal = ReadRawRC(TPrescalerReg);//,0x3E)       ;
1122   1        DEBUG_MARK;
1123   1          TestVal = ReadRawRC(TPrescalerReg);//,0x3E)       ;
1124   1        DEBUG_MARK;
1125   1        //PcdAntennaOn();//开启天线发射 
1126   1        //Hardware_DelayMs(1);
1127   1        //Find_Card();
1128   1        //PcdAntennaOff();
1129   1         for(i=0; i<10; i++)
1130   1          TestBuff[i]=i;
1131   1          
1132   1         for(i=0; i<10; i++)
1133   1            WriteRawRC(FIFODataReg,TestBuff[i])          ; // 数据写入FIFO 
1134   1        DEBUG_MARK;     
1135   1        for(i=0; i<10; i++)
1136   1          TestBuff[i]=0xFF;   
1137   1        DEBUG_MARK; 
1138   1        
1139   1        //i=0;  
1140   1        
1141   1        TestVal = (FIFODataReg<<1)|0x80;
1142   1        for(i=0; i<10; i++)
1143   1        {
1144   2          
1145   2          TestBuff[i] = ReadRawRC(FIFODataReg)          ; //
1146   2          /*
1147   2          SET_MFC_CS_L;
1148   2          Hardware_DelayX1us(100);
1149   2        
1150   2          HAL_SPI_Transmit(&hspi2,&TestVal,1,10);
1151   2          Hardware_DelayMs(10);
1152   2          HAL_SPI_Receive(&hspi2,&TestBuff[i],1,10);
1153   2        //  HAL_STATUS = HAL_SPI_TransmitReceive(&hspi2,&ucResult,&ReadData,1,500);
1154   2          Hardware_DelayMs(10);
1155   2          SET_MFC_CS_H;
1156   2      
1157   2        //  Hardware_DelayMs(10);
1158   2          Hardware_DelayX1us(100);
1159   2        */
1160   2        DEBUG_MARK;   
1161   2        }   
1162   1      }
1163          #endif
1164          
1165          


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/21/2023 14:57:02 PAGE 20  

   CODE SIZE        =   3539    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     52     503
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

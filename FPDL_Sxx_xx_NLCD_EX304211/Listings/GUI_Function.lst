C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      04/21/2023 14:57:04 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE GUI_FUNCTION
OBJECT MODULE PLACED IN .\Objects\GUI_Function.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Softwares\Application\GUI_Function.c LARGE OMF2 OPTIMIZE(9,SPEED) BROWSE
                    - INCDIR(.\Drivers\Lib\c;.\Drivers\Lib\H;.\Drivers\Lib\IAP_Lib;.\Drivers\Lib\TouchKey_lib;.\Drivers\Physical;.\Drivers\Pr
                    -otocol;.\Softwares\Application;.\Softwares\Basic;.\Softwares\ModuleLogic;.\Drivers\Protocol\YC_NFC;.\Drivers\Protocol\WI
                    -FI_Tuya) DEBUG PRINT(.\Listings\GUI_Function.lst) TABS(2) OBJECT(.\Objects\GUI_Function.obj)

line level    source

   1          #include "gpio.h"
   2          //Protocol layer
   3          #include "MFC_WS1850.h"
   4          #include "EEPROM.h"
   5          #include "BeepMgr.h"
   6          #include "TuyaWIFI.h"
   7          //Logic layer
   8          #include "AppUnlock.h"
   9          #include "Motor.h"
  10          #include "FP.h"
  11          #include "LCD.h"
  12          #include "MFC.h"
  13          //Application layer
  14          #include "GUI_Function.h"
  15          #include "global_variable.h"
  16          #include "Font.h"
  17          #include "Voice_Menu.h"
  18          #include "Font_Menu.h"
  19          
  20          
  21          extern screen_t CurrentScreen;
  22          extern DataInputMgr_t DataInputMgr;
  23          extern VoiceMenuMgr_t VoiceMenuMgr;
  24          extern PasscodeInputMgr_t PasscodeInputMgr;
  25          extern uint8_t LEDsCtrlSwitch;
  26          extern uint8_t GUI_ToggleFlag_05s;
  27          extern keycode_t gui_keycode;
  28          
  29          
  30          
  31          void GoToMainMenu(void)//进入主菜单
  32          {
  33   1        VoiceMenuMgr.MenuPoint=0;
  34   1        #ifdef Function_TuyaWifi
                VoiceMenuMgr.TotalMenuNum = 6;
                #else
  37   1        VoiceMenuMgr.TotalMenuNum = 5;
  38   1        #endif
  39   1        CurrentScreen = SCREEN_MainMenu;
  40   1      }
  41          
  42          void GoToFpMenu(void)//进入指纹菜单
  43          {
  44   1        VoiceMenuMgr.MenuPoint=0;
  45   1        VoiceMenuMgr.TotalMenuNum = 4;
  46   1        CurrentScreen = SCREEN_FpMenu;
  47   1      }
  48          void GoToPasswordMenu(void)//进入密码菜单
  49          {
  50   1        VoiceMenuMgr.MenuPoint=0;
  51   1        VoiceMenuMgr.TotalMenuNum = 4;
  52   1        CurrentScreen = SCREEN_PasscodeMenu;
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      04/21/2023 14:57:04 PAGE 2   

  53   1      }
  54          void GoToCardMenu(void)//进入卡片菜单
  55          {
  56   1        VoiceMenuMgr.MenuPoint=0;
  57   1        VoiceMenuMgr.TotalMenuNum = 3;
  58   1        CurrentScreen = SCREEN_CardUserMenu;
  59   1      }
  60          void GoToSystemConfigMenu(void)//进入系统设置菜单
  61          {
  62   1        VoiceMenuMgr.MenuPoint=0;
  63   1        #ifdef Function_VoiceEnabledEnglish
                VoiceMenuMgr.TotalMenuNum = 7;
                #else
  66   1        VoiceMenuMgr.TotalMenuNum = 6;
  67   1        #endif
  68   1        CurrentScreen = SCREEN_SystemConfigMenu;
  69   1      }
  70          void GoToSystemVersion(void)//进入系统版本号菜单
  71          {
  72   1        VoiceMenuMgr.MenuPoint=0;
  73   1        VoiceMenuMgr.TotalMenuNum = 2;
  74   1        CurrentScreen = SCREEN_SystemVersion;
  75   1      }
  76          
  77          void GotoLogMenu(void)//进入日志菜单
  78          {
  79   1        VoiceMenuMgr.MenuPoint=0;
  80   1        VoiceMenuMgr.TotalMenuNum = 3;
  81   1        CurrentScreen = SCREEN_EventLogMenu;
  82   1      }
  83          
  84          bool_t IfSystemIsInFactoryDefaultStatus(void)//如果系统处于出厂默认状态
  85          {
  86   1        if ( ( CheckMemoryMgr.FpUserNum == 0x00 )
  87   1            &&(CheckMemoryMgr.FpMasterNum == 0x00 )
  88   1            &&(CheckMemoryMgr.CardUserNum == 0x00 )
  89   1            &&(CheckMemoryMgr.PasscodeMasterNum == 0x00 )
  90   1            &&(CheckMemoryMgr.PasscodeUserNum == 0x00 ) )
  91   1        {
  92   2          return bTRUE;
  93   2        }
  94   1        else
  95   1        {
  96   2          return bFALSE;
  97   2        }
  98   1      }
  99          
 100          bool_t IfSystemWithoutSecondIdentity(void)//如果系统没有第二身份
 101          {
 102   1        if  ( (((CheckMemoryMgr.FpUserNum+CheckMemoryMgr.FpMasterNum) == 0x00 )&&((CheckMemoryMgr.PasscodeMasterN
             -um + CheckMemoryMgr.PasscodeUserNum)== 0x00))
 103   1          ||(((CheckMemoryMgr.FpUserNum+CheckMemoryMgr.FpMasterNum) == 0x00 )&&(CheckMemoryMgr.CardUserNum == 0x00
             - ))
 104   1          ||(((CheckMemoryMgr.PasscodeMasterNum + CheckMemoryMgr.PasscodeUserNum)== 0x00)&&(CheckMemoryMgr.CardUse
             -rNum == 0x00 ))
 105   1          )
 106   1        {
 107   2          return bTRUE;
 108   2        }
 109   1        else
 110   1        {
 111   2          return bFALSE;
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      04/21/2023 14:57:04 PAGE 3   

 112   2        }
 113   1      }
 114          
 115          bool_t CompareTwoArrayIsSame(uint8_t Point1[],uint8_t Point2[],uint8_t Lenth)//比较两个数组是否相同
 116          {
 117   1        uint8_t i;
 118   1        for (i=0;i<Lenth;i++)
 119   1        {
 120   2          if (Point1[i]!=Point2[i]){
 121   3            return bFALSE;
 122   3          }
 123   2        }
 124   1        return bTRUE;
 125   1      }
 126          
 127          void UnlockModeJudgment(void)//开锁模式有效性判断
 128          {
 129   1        if  ( IfSystemWithoutSecondIdentity() == bTRUE )
 130   1        {
 131   2          UserIdentifyResultMgr.UnlockingMode = SingalMode;
 132   2          EEPROM_WriteSequential(UnlockModeStartAddr,&UserIdentifyResultMgr.UnlockingMode,1);
 133   2        }
 134   1      }
 135          
 136          bool_t is_valid_date(uint8_t year, uint8_t month, uint8_t date)//判断是不是有效日期
 137          {
 138   1          uint8_t monttbuffer[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
 139   1          uint16_t y;
 140   1          uint8_t m,d;
 141   1          y=((year/16)*10)+(year%16)+2000;
 142   1          m = ((month/16)*10)+(month%16);
 143   1          d = ((date/16)*10) + (date%16);
 144   1              if (((y % 4 == 0) && (y % 100 != 0)) 
 145   1            || (y % 400 == 0)
 146   1            )
 147   1              {
 148   2                      monttbuffer[1] = 29; 
 149   2          }
 150   1              if ( (m > 0) 
 151   1            && (m < 13)
 152   1            && (d > 0) 
 153   1            && (d <= monttbuffer[m - 1])
 154   1            )
 155   1              {
 156   2            return bTRUE;
 157   2          }
 158   1          else{
 159   2            return bFALSE;
 160   2          }
 161   1      }
 162          
 163          void Config_AntiPrying_Interrupt(void)//设置防撬
 164          {
 165   1        if (PickAlarmEnableMgr.Enable == bTRUE)
 166   1        {
 167   2          EnableAntiPrying_Interrupt();
 168   2        }
 169   1        else{
 170   2          DisableAntiPrying_Interrupt();
 171   2        }
 172   1      }
 173          
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      04/21/2023 14:57:04 PAGE 4   

 174          void UnlockSuccess(uint8_t UnlockType)//开锁成功
 175          {
 176   1        UserIdentifyResultMgr.IdentifyType = UnlockType;
 177   1        GUI_SetMotorToOpenAndCloseDoor();
 178   1        //Enable_KEYLED_WATERLIGHT(); 
 179   1        CurrentScreen = SCREEN_IdentifySuccess;
 180   1        UserIdentifyResultMgr.TimeCnt = Def_MessageBoxTimeDelay;
 181   1      }
 182          
 183          void RefreshSystemSleepTime(void)//更新系统休眠时间
 184          {
 185   1        if ( ( CurrentScreen == SCREEN_Main )
 186   1           ||( CurrentScreen ==SCREEN_Initialization)
 187   1           ||( CurrentScreen ==SCREEN_LowBattery )
 188   1          )
 189   1        {
 190   2          SystemPowerMgr.SleepDelayTimerCnt = DEF_SystemSleepDelayTime_MainScreen;
 191   2        }
 192   1        else
 193   1        {
 194   2          SystemPowerMgr.SleepDelayTimerCnt = DEF_SystemSleepDelayTime_MenuScreen;
 195   2        }
 196   1      }
 197          
 198          void SystemConfigSave(void)//系统设置保存
 199          {
 200   1        #ifdef Function_VoiceEnabledEnglish
                  EEPROM_WriteSequential(SystemLanguageStartAddr, (uint8_t*)&SystemLanguage, 1);
                #endif
 203   1          EEPROM_WriteSequential(UnlockModeStartAddr, (uint8_t*)&UserIdentifyResultMgr.UnlockingMode, 1);
 204   1          EEPROM_WriteSequential(VolumeSwitchStartAddr, (uint8_t*)&VoiceMgr.Enable, 1);
 205   1          EEPROM_WriteSequential(PickAlarmSwitchStartAddr, (uint8_t*)&PickAlarmEnableMgr.Enable, 1);
 206   1      }
 207          
 208          void SystemConfigLoad(void)//系统设置加载
 209          {
 210   1        uint8_t temp;
 211   1        bool_t temp_BOOL;
 212   1        #ifdef Function_VoiceEnabledEnglish
                EEPROM_ReadSequential(SystemLanguageStartAddr,&temp,1);
                if (temp == Chinese)
                {
                  SystemLanguage = Chinese;
                }
                else
                {
                  SystemLanguage = English;
                }
                #else
 223   1        SystemLanguage = Chinese;
 224   1        #endif
 225   1        EEPROM_ReadSequential(UnlockModeStartAddr,&temp,1);
 226   1        if (temp == DoubleMode)
 227   1        {
 228   2          UserIdentifyResultMgr.UnlockingMode = DoubleMode;
 229   2        }
 230   1        else
 231   1        {
 232   2          UserIdentifyResultMgr.UnlockingMode = SingalMode;
 233   2        }
 234   1        
 235   1        EEPROM_ReadSequential(VolumeSwitchStartAddr,(uint8_t*)&temp_BOOL,1);
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      04/21/2023 14:57:04 PAGE 5   

 236   1      
 237   1        if (temp_BOOL == bFALSE)
 238   1        {
 239   2            VoiceMgr.Enable = bFALSE;
 240   2        }
 241   1        else
 242   1        {
 243   2            VoiceMgr.Enable = bTRUE;
 244   2        }
 245   1        
 246   1        EEPROM_ReadSequential(PickAlarmSwitchStartAddr,(uint8_t*)&temp_BOOL,1);
 247   1          
 248   1        #ifdef Function_AntiPryingDefaultDisabled
 249   1        if (temp_BOOL == bTRUE)
 250   1        {
 251   2            PickAlarmEnableMgr.Enable = bTRUE;
 252   2        }
 253   1        else
 254   1        {
 255   2            PickAlarmEnableMgr.Enable = bFALSE;
 256   2        }
 257   1        #else
                if (temp_BOOL == bFALSE)
                {
                    PickAlarmEnableMgr.Enable = bFALSE;
                }
                else
                {
                    PickAlarmEnableMgr.Enable = bTRUE;
                }
                #endif
 267   1          
 268   1        Config_AntiPrying_Interrupt();
 269   1        
 270   1      }
 271          
 272          /****************************************************************/
 273          void ReadLockBrand(void)//读取锁品牌
 274          {
 275   1        uint8_t temp;
 276   1        
 277   1        EEPROM_ReadSequential(LockBrandStartAddr,&temp,1);
 278   1        if ( temp == 0x55 )
 279   1        {
 280   2          EEPROM_ReadSequential(LockBrandStartAddr+1,&LockBrand.LockBrandDisDataBuff[0],224);
 281   2          LockBrand.LockBrandDataValid = bTRUE;
 282   2        }
 283   1        else{
 284   2          LockBrand.LockBrandDataValid = bFALSE;
 285   2        } 
 286   1      }
 287          
 288          void WriteLockBrand(void)//写入锁品牌
 289          { 
 290   1        #ifdef Function_ScreenDisplay
                uint8_t temp;
                temp = 0x55;
                LockBrand.GotBrandData = bFALSE;
                if ( MFC_ReadLockBrandData(&LockBrand.LockBrandDisDataBuff[0]) == S_SUCCESS )
                {
                  EEPROM_WriteSequential(LockBrandStartAddr,&temp,1);
                  
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      04/21/2023 14:57:04 PAGE 6   

              //    if ( LockBrand.BrandType == SmallBrand )
              //    {
                    EEPROM_WriteSequential(LockBrandStartAddr+1,&LockBrand.LockBrandDisDataBuff[0],224);
              //    }
              //    else if ( LockBrand.BrandType == BigBrand )
              //    {
              //      EEPROM_WriteSequential(LockBrandStartAddr+1,&LockBrand.LockBrandDisDataBuff[0],512);
              //    }
                  LockBrand.GotBrandData = bTRUE;
                  LockBrand.LockBrandDataValid = bTRUE;
                }
                #endif
 310   1      }
 311          
 312          void SystemConfigReset(void)//系统设置恢复出厂
 313          {
 314   1        UserIdentifyResultMgr.UnlockingMode = SingalMode;
 315   1        VoiceMgr.Enable = bTRUE;
 316   1        
 317   1        #ifdef Function_AntiPryingDefaultDisabled
 318   1          PickAlarmEnableMgr.Enable = bFALSE;
 319   1        #else
                  PickAlarmEnableMgr.Enable = bTRUE;
                #endif
 322   1        
 323   1        Config_AntiPrying_Interrupt();
 324   1      
 325   1        SystemConfigSave();
 326   1      }
 327          
 328          //ID输入效果显示生成
 329          void GUI_DataInputCreat(uint8_t StartPage,uint8_t StartColumn,uint8_t InputNum,uint16_t DefaultValue)
 330          {
 331   1        #ifdef Function_ScreenDisplay
                uint8_t temp,i;
                #endif
 334   1        uint16_t value;
 335   1      
 336   1        if( DataInputMgr.Status == InputIdle )
 337   1        {
 338   2          DataInputMgr.Status = InputStart;
 339   2          DataInputMgr.Value = DefaultValue;
 340   2          DataInputMgr.InputNum = InputNum;
 341   2      
 342   2          if ( DefaultValue == 0x0000 ){
 343   3            DataInputMgr.InputPoint = 0;
 344   3          }
 345   2          else{
 346   3            DataInputMgr.InputPoint = InputNum;
 347   3          }
 348   2        }
 349   1          
 350   1        else if ( DataInputMgr.Status == InputStart )
 351   1        {
 352   2          if (DataInputMgr.InputPoint > DataInputMgr.InputNum ){
 353   3            return;
 354   3          }
 355   2      
 356   2          value = DataInputMgr.Value;
 357   2          #ifdef Function_ScreenDisplay
                  for (i=0;i<DataInputMgr.InputPoint;i++)
                  { 
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      04/21/2023 14:57:04 PAGE 7   

                    temp = value%10;
                    DisOneDigital16x8(StartPage,StartColumn+(8*(DataInputMgr.InputPoint-i-1)),temp,NormalDisplay);
                    value/=10;
                  }
              
                  for (i=DataInputMgr.InputPoint;i<(DataInputMgr.InputNum+1);i++)   //"+1" for clear underline
                  {
                    DisZF16x8(StartPage,StartColumn+(8*i),ZF_kongge,NormalDisplay);
                  }
                  
                  if ( GUI_ToggleFlag_05s == 1 )
                  {
                    DisZF16x8(StartPage,StartColumn+(8*DataInputMgr.InputPoint),ZF_kongge,NormalDisplay);
                  }
                  else{
                    DisZF16x8(StartPage,StartColumn+(8*DataInputMgr.InputPoint),ZF_underline,NormalDisplay);
                  }
                  #else
 378   2          StartPage = 0; StartColumn = 0;//无意义，注掉不影响，会报warming
 379   2          #endif
 380   2        }
 381   1      
 382   1      }
 383          
 384          
 385          void GUI_UserIDinputButtonMonitor(keycode_t keycode)//GUI_用户ID输入按钮监视器
 386          {
 387   1        if ( (keycode < KEY_NINE)||(keycode == KEY_NINE) )
 388   1        {
 389   2          DEF_ButtonPress_Voice;
 390   2          PasscodeUserRegisterMgr.OverTimeCnt = Def_GuiTimeDelayCnt5s;
 391   2          if ( DataInputMgr.InputPoint < DataInputMgr.InputNum )
 392   2          {
 393   3            DataInputMgr.Value = DataInputMgr.Value*10+gui_keycode;
 394   3            DataInputMgr.InputPoint++;
 395   3          }
 396   2        }
 397   1        else if ( keycode == KEY_ASTERISK )
 398   1        {
 399   2          DEF_ButtonPress_Voice;
 400   2          PasscodeUserRegisterMgr.OverTimeCnt = Def_GuiTimeDelayCnt5s;
 401   2          if ( DataInputMgr.InputPoint > 0 )
 402   2          {
 403   3            DataInputMgr.InputPoint--;
 404   3            DataInputMgr.Value/=10;
 405   3          }
 406   2          else
 407   2          {
 408   3            DataInputMgr.Status = InputExit;
 409   3          }
 410   2        }
 411   1        else if ( keycode == KEY_POUNDSIGN )
 412   1        {
 413   2          //DEF_ButtonPress_Voice;
 414   2          PasscodeUserRegisterMgr.OverTimeCnt = Def_GuiTimeDelayCnt5s;
 415   2          if ( DataInputMgr.InputPoint == 0 )
 416   2          {
 417   3            DataInputMgr.Status = InputExit;
 418   3          }
 419   2          else
 420   2          {
 421   3            DataInputMgr.Status = InputEnd;
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      04/21/2023 14:57:04 PAGE 8   

 422   3          }
 423   2        }
 424   1      }
 425          
 426          void GUI_PasscodeInputCreat(uint8_t StartPage,uint8_t StartColumn)//GUI密码输入显示效果生成
 427          {
 428   1        uint8_t i=0;
 429   1        StartColumn=0;//无意义，注掉不影响，会报warming
 430   1        if (PasscodeInputMgr.Point > 16)
 431   1        {
 432   2          return;
 433   2        }
 434   1        #ifdef Function_ScreenDisplay
                Clear_Screen_Page(StartPage);
                Clear_Screen_Page(StartPage+1);
                for (i=0;i<PasscodeInputMgr.Point;i++)
                {
                  DisZF16x8(StartPage,(8*i)+(64-(PasscodeInputMgr.Point*4)),ZF_xinghao,NormalDisplay);
                }
                #else
 442   1        StartPage=0;//无意义，注掉不影响，会报warming
 443   1        #endif
 444   1      }
 445          
 446          void GUI_PasscodeInputButtonMonitor(keycode_t keycode)//GUI按键密码输入监视器
 447          {
 448   1        if ( (keycode < KEY_NINE)||(keycode == KEY_NINE) )//0-9
 449   1        {
 450   2          PasscodeUserRegisterMgr.OverTimeCnt = Def_GuiTimeDelayCnt5s;
 451   2          if ( CurrentScreen != SCREEN_PickLockAlarm ){
 452   3            DEF_ButtonPress_Voice;
 453   3          }
 454   2          if ( PasscodeInputMgr.Point <  PasscodeInputMgr.PasscodeLen )
 455   2          {
 456   3            PasscodeInputMgr.InputBuff[PasscodeInputMgr.Point] = gui_keycode;
 457   3            PasscodeInputMgr.Point++;
 458   3          }
 459   2        }
 460   1        else if ( keycode == KEY_ASTERISK )
 461   1        {
 462   2          PasscodeUserRegisterMgr.OverTimeCnt = Def_GuiTimeDelayCnt5s;
 463   2          if ( CurrentScreen != SCREEN_PickLockAlarm && CurrentScreen != SCREEN_ManagerIdentify){
 464   3            DEF_ButtonPress_Voice;
 465   3          }
 466   2          
 467   2          if ( PasscodeInputMgr.Point > 0 )
 468   2          {
 469   3            PasscodeInputMgr.Status = PasscodeInputExit;  
 470   3          }
 471   2          else
 472   2          {
 473   3            PasscodeInputMgr.Status = PasscodeInputExit;
 474   3          }
 475   2        }
 476   1        else if ( keycode == KEY_POUNDSIGN )
 477   1        {
 478   2          PasscodeUserRegisterMgr.OverTimeCnt = Def_GuiTimeDelayCnt5s;
 479   2          if ( CurrentScreen != SCREEN_PickLockAlarm ){
 480   3            DEF_ButtonPress_Voice;
 481   3          }
 482   2          if ( PasscodeInputMgr.Point == 0 )
 483   2          {
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      04/21/2023 14:57:04 PAGE 9   

 484   3            PasscodeInputMgr.Status = PasscodeInputExit;
 485   3          }
 486   2          else
 487   2          {
 488   3            PasscodeInputMgr.Status = PasscodeInputEnd;
 489   3          }
 490   2        }
 491   1      }
 492          
 493          void PasscodeUserIdentify(void)//密码用户认证
 494          {
 495   1        if ( PasscodeUserIdentifyMgr.Status != PasscodeIdentifyIdle )
 496   1        {
 497   2          if (PasscodeUserIdentifyMgr.Status == PasscodeIdentifyStart )
 498   2          {
 499   3            //PasscodeUserIdentifyMgr.TimeCnt = 240;
 500   3            PasscodeUserIdentifyMgr.Status = PasscodeIdentifyPasscodeInput;
 501   3          }
 502   2          else if (PasscodeUserIdentifyMgr.Status == PasscodeIdentifyPasscodeInput)
 503   2          {
 504   3            #ifdef Function_ScreenDisplay
                    Clear_Screen_Page(3);
                    Clear_Screen_Page(6);
                    Clear_Screen_Page(7);
                    GUI_PasscodeInputCreat(4,0);
                    #endif
 510   3            if (PasscodeInputMgr.Status == PasscodeInputEnd)
 511   3            {
 512   4              if ( IfSystemIsInFactoryDefaultStatus()==bTRUE )
 513   4              {
 514   5                if( (PasscodeInputMgr.InputBuff[0]==0x01)
 515   5                  &&(PasscodeInputMgr.InputBuff[1]==0x01)
 516   5                  &&(PasscodeInputMgr.InputBuff[2]==0x01)
 517   5                  &&(PasscodeInputMgr.InputBuff[3]==0x01)
 518   5                  &&(PasscodeInputMgr.InputBuff[4]==0x01)
 519   5                  &&(PasscodeInputMgr.InputBuff[5]==0x01)
 520   5                  &&(PasscodeInputMgr.InputBuff[6]==0x01)
 521   5                  &&(PasscodeInputMgr.InputBuff[8]==0x01)
 522   5                  &&(PasscodeInputMgr.InputBuff[9]==0x01)
 523   5                  )
 524   5                {
 525   6                  PasscodeUserIdentifyMgr.Status = PasscodeIdentifyAgingTestSuccess;
 526   6                }
 527   5                else if ((PasscodeInputMgr.InputBuff[0]==0x01)
 528   5                    &&(PasscodeInputMgr.InputBuff[1]==0x03)
 529   5                    &&(PasscodeInputMgr.InputBuff[2]==0x05)
 530   5                    &&(PasscodeInputMgr.InputBuff[3]==0x07)
 531   5                    &&(PasscodeInputMgr.Point == 4)
 532   5                    )
 533   5                {
 534   6                  PasscodeUserIdentifyMgr.Status = PasscodeIdentifyCheckVersionSuccess;
 535   6                }
 536   5                else
 537   5                {
 538   6                  PasscodeUserIdentifyMgr.Status = PasscodeIdentifyFail;
 539   6                }
 540   5              }
 541   4              else
 542   4              {
 543   5                PasscodeUserIdentifyMgr.UserID = PasscodeIdendify(PasscodeInputMgr.InputBuff);
 544   5                if ( PasscodeUserIdentifyMgr.UserID != 0x00 )//Identify success
 545   5                {
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      04/21/2023 14:57:04 PAGE 10  

 546   6                  PasscodeUserIdentifyMgr.Status = PasscodeIdentifySuccess;
 547   6                  //PasscodeUserIdentifyMgr.TimeCnt =Def_IdendtifySuccessScreenTimeDelay;
 548   6                  UserIdentifyResultMgr.PasscodeType = LocalPasscode;
 549   6                  //GUI_Flag_RefreshLCD = bTRUE;
 550   6                }
 551   5                else
 552   5                {
 553   6                  if ( PasscodeInputMgr.Point == 10 )
 554   6                  {
 555   7                    PasscodeUserIdentifyMgr.Status = PasscodeIdentifyFail;
 556   7                    //PasscodeUserIdentifyMgr.TimeCnt =Def_IdendtifyFailScreenTimeDelay;
 557   7                    #ifdef Function_TuyaWifi
                            WifiMgr.PostMgr.Flag.Bits.RequestGreenTime = 1;
                            PasscodeUserIdentifyMgr.Status = PasscodeIdentifyIdle;
                            #endif
 561   7                  }
 562   6                  else if ((PasscodeInputMgr.Point == 12)||( PasscodeInputMgr.Point == 13 ))
 563   6                  {
 564   7                    #ifdef Function_AppUnlock
 565   7                    PasscodeUserIdentifyMgr.UserID = AppPasscodeIdentify(PasscodeInputMgr.InputBuff,PasscodeInputMgr.P
             -oint);
 566   7                    if ( PasscodeUserIdentifyMgr.UserID != 0x00 )//App unlock success
 567   7                    {
 568   8                      PasscodeUserIdentifyMgr.Status = PasscodeIdentifySuccess;
 569   8                      //PasscodeUserIdentifyMgr.TimeCnt =Def_IdendtifySuccessScreenTimeDelay;
 570   8                      UserIdentifyResultMgr.PasscodeType = AppPasscode;
 571   8                      //GUI_Flag_RefreshLCD = bTRUE;
 572   8                    }
 573   7                    else
 574   7                    #endif
 575   7                    {
 576   8                      PasscodeUserIdentifyMgr.Status = PasscodeIdentifyFail;
 577   8                      //PasscodeUserIdentifyMgr.TimeCnt =Def_IdendtifyFailScreenTimeDelay;
 578   8                      //GUI_Flag_RefreshLCD = bTRUE;
 579   8                    }
 580   7                  }
 581   6                  else
 582   6                  {
 583   7                    PasscodeUserIdentifyMgr.Status = PasscodeIdentifyFail;
 584   7                    //PasscodeUserIdentifyMgr.TimeCnt =Def_IdendtifyFailScreenTimeDelay;
 585   7                    //GUI_Flag_RefreshLCD = bTRUE;
 586   7                  }
 587   6                }
 588   5              }
 589   4            }
 590   3            else if (PasscodeInputMgr.Status == PasscodeInputExit)
 591   3            {
 592   4              PasscodeUserIdentifyMgr.Status = PasscodeIdentifyIdle;
 593   4              PasscodeUserRegisterMgr.TimeCnt = 0;  
 594   4              //GUI_Flag_RefreshLCD = bTRUE;
 595   4            }
 596   3          }
 597   2        }
 598   1      }
 599          
 600          uint8_t PasscodeIdendify(uint8_t *BUFF1)//密码验证
 601          {
 602   1          uint8_t i,k;
 603   1        int j;
 604   1        uint8_t PasscodeLen;
 605   1        for (i=0;i<(DEF_MAX_PASSCODEMASTER+DEF_MAX_PASSCODEUSER);i++)
 606   1        {
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      04/21/2023 14:57:04 PAGE 11  

 607   2          if ( PasscodeMemoryMgr[i].Status != PasscodeIsValid ){
 608   3            continue;
 609   3          }
 610   2      
 611   2          PasscodeLen = 0;
 612   2          for (j=11;j>=0;j--)
 613   2          {
 614   3            if(j%2==1)
 615   3            {
 616   4              if ( (PasscodeMemoryMgr[i].PasscodeBuff[j/2]&0xf) != 0xF )
 617   4              {
 618   5                PasscodeLen = j+1;
 619   5                break;
 620   5              }
 621   4            }
 622   3            else
 623   3            {
 624   4              if ( ((PasscodeMemoryMgr[i].PasscodeBuff[j/2]>>4)&0xf) != 0xF )
 625   4              {
 626   5                PasscodeLen = j+1;
 627   5                break;
 628   5              }
 629   4            }
 630   3          }
 631   2          
 632   2          for (j=0;j<(16-PasscodeLen+1);j++)
 633   2          {
 634   3            for (k=0;k<PasscodeLen;k++)
 635   3            {
 636   4              if(k%2==1)
 637   4              {
 638   5                if (((PasscodeMemoryMgr[i].PasscodeBuff[k/2]&0xf) != *(BUFF1+k+j)))
 639   5                {
 640   6                  break;
 641   6                }
 642   5              }
 643   4                else
 644   4              {
 645   5                if ((((PasscodeMemoryMgr[i].PasscodeBuff[k/2]>>4)&0xf) != *(BUFF1+k+j)))
 646   5                {
 647   6                  break;
 648   6                }
 649   5              }
 650   4            }
 651   3            if (k == PasscodeLen){
 652   4              return PasscodeMemoryMgr[i].UserID;
 653   4            }
 654   3          }
 655   2        }
 656   1        return 0;
 657   1      }
 658          
 659          uint8_t AppPasscodeIdentify(uint8_t BUFF[],unsigned int pwd_len )//APP密码识别
 660          {
 661   1        uint8_t i,j;
 662   1        uint8_t UserPasscodeLen;
 663   1        uint8_t temp[12];
 664   1        unsigned int mode=0,result=0;
 665   1        
 666   1        ReadPasscodeUserMemoryFromEEPROM();
 667   1             //ReadPasscodeMaster02MemoryFromEEPROM();
 668   1      
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      04/21/2023 14:57:04 PAGE 12  

 669   1        for (i=0;i<DEF_MAX_PASSCODEMASTER;i++)
 670   1        {
 671   2          UserPasscodeLen = 0;
 672   2          for(j=0;j<6;j++)
 673   2          {
 674   3            temp[2*j]=PasscodeMemoryMgr[i].PasscodeBuff[j]>>4;
 675   3            temp[2*j+1]=PasscodeMemoryMgr[i].PasscodeBuff[j]&0x0f;
 676   3          }
 677   2          for (j=0;j<pwd_len;j++)
 678   2          {
 679   3            if ( temp[j] < 10)
 680   3            {
 681   4              UserPasscodeLen++;
 682   4            }
 683   3            else
 684   3            {
 685   4              break;
 686   4            }
 687   3          }
 688   2          if(pwd_decrypt(temp,i,UserPasscodeLen,BUFF,pwd_len,&mode,&result)>0)             
 689   2          {
 690   3            return i+1;
 691   3          }
 692   2          
 693   2        }
 694   1        return 0;
 695   1      }
 696          
 697          void ShowLockBrand(void)//显示锁品牌
 698          {
 699   1        #ifdef Function_ScreenDisplay
                code uint8_t Welcome_Str[8]={HZ_huan,HZ_yingjie,HZ_shiyong,HZ_yong,HZ_zhineng,HZ_neng,HZ_suomen,HZ_end};
              
                if ( LockBrand.LockBrandDataValid == bTRUE )
                {
                  DisImage_RAM(6,8,112,16,&LockBrand.LockBrandDisDataBuff[0],NormalDisplay);
                }
                else if( LockBrand.LockBrandDataValid == bFALSE )
                {
                  DisHZ16x14Str(6,16,Welcome_Str,NormalDisplay);
                }
                #endif
 711   1      }
 712          
 713          void GUI_Update_Version(void)//更新版本号
 714          {
 715   1        #ifdef Function_ScreenDisplay
                 code uint8_t SystemVersionStr[]={HZ_xi,HZ_tong,HZ_ban,HZ_ben,HZ_end};
                //code uint8_t FPM_Version[]={"FPM:126"};
                uint8_t ModelStr[]={"Sxxx-xxx"};
                uint8_t VersionStr[]={"100.100"};
                #endif
 721   1      
 722   1        if ( VoiceDataTransferMgr.VoicePlayEnd == bTRUE )
 723   1        {
 724   2          if (VoiceMenuMgr.MenuPoint < VoiceMenuMgr.TotalMenuNum )
 725   2          {
 726   3            PLAY_VOICE_MULTISEGMENTS(SystemVersionVoiceBuff[VoiceMenuMgr.MenuPoint]);
 727   3            VoiceMenuMgr.MenuPoint++;
 728   3          }
 729   2        }
 730   1        
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      04/21/2023 14:57:04 PAGE 13  

 731   1        #ifdef Function_ScreenDisplay
                DisHZ16x14Str(0,32,SystemVersionStr,NormalDisplay);
                ModelStr[1]=DEF_CustomerNumber/100+0x30;
                ModelStr[2]=DEF_CustomerNumber%100/10+0x30;
                ModelStr[3]=DEF_CustomerNumber%10+0x30;
                ModelStr[5]=DEF_ModelNumber/100+0x30;
                ModelStr[6]=DEF_ModelNumber%100/10+0x30;
                ModelStr[7]=DEF_ModelNumber%10+0x30;  
                DisEN16x8Str(3,20,ModelStr,NormalDisplay);
                //Main Board Hardware Version
                VersionStr[0]=DEF_HardwareVerion/100+0x30;
                VersionStr[1]=DEF_HardwareVerion%100/10+0x30;
                VersionStr[2]=DEF_HardwareVerion%10+0x30;
                //Main Board Firmware Version
                VersionStr[4]=DEF_FirmwareVerion/100+0x30;
                VersionStr[5]=DEF_FirmwareVerion%100/10+0x30;
                VersionStr[6]=DEF_FirmwareVerion%10+0x30;
              
                DisEN16x8Str(5,20,VersionStr,NormalDisplay);
                #endif
 751   1      }
 752          
 753          void ReadPasscodeUserMemoryFromEEPROM(void)//从EEPROM内存读取密码用户
 754          {
 755   1        EEPROM_ReadSequential(PasscodeUserMemoryStartAddr,&PasscodeMemoryMgr[0].UserID,(8*(DEF_MAX_PASSCODEUSER+D
             -EF_MAX_PASSCODEMASTER)));
 756   1      }
 757          
 758          void WritePasscodeUserMemoryToEEPROM(void)//从EEPROM内存写入密码用户
 759          {
 760   1        EEPROM_WriteSequential(PasscodeUserMemoryStartAddr,&PasscodeMemoryMgr[0].UserID,(8*(DEF_MAX_PASSCODEUSER+
             -DEF_MAX_PASSCODEMASTER)));
 761   1      }
 762          
 763          bool_t GUI_CompareTwoPasscodes(uint8_t *BUFF1,uint8_t *BUFF2)//比较两个密码是否相等
 764          {
 765   1        if (  ( *BUFF1 == *BUFF2)
 766   1          &&(*(BUFF1+1) == *(BUFF2+1))
 767   1          &&(*(BUFF1+2) == *(BUFF2+2))
 768   1          &&(*(BUFF1+3) == *(BUFF2+3))
 769   1          &&(*(BUFF1+4) == *(BUFF2+4))
 770   1          &&(*(BUFF1+5) == *(BUFF2+5))
 771   1          &&(*(BUFF1+6) == *(BUFF2+6))
 772   1          &&(*(BUFF1+7) == *(BUFF2+7))
 773   1          &&(*(BUFF1+8) == *(BUFF2+8))
 774   1          &&(*(BUFF1+9) == *(BUFF2+9))
 775   1          &&(*(BUFF1+10) == *(BUFF2+10))
 776   1          &&(*(BUFF1+11) == *(BUFF2+11))
 777   1           )
 778   1        {
 779   2          return bTRUE;
 780   2        }
 781   1        else
 782   1        {
 783   2          return bFALSE;
 784   2        }
 785   1      }
 786          
 787          bool_t IfPasscodeUserIDisRegistered(uint8_t UserID)//如果密码用户ID已注册
 788          {
 789   1        uint8_t i;
 790   1        for (i=0;i<(DEF_MAX_PASSCODEUSER+DEF_MAX_PASSCODEMASTER);i++)
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      04/21/2023 14:57:04 PAGE 14  

 791   1        {
 792   2          if (PasscodeMemoryMgr[i].UserID == UserID )
 793   2          {
 794   3            return bTRUE;
 795   3          }
 796   2        }
 797   1        return bFALSE;
 798   1      }
 799          
 800          uint8_t CheckHowManyRegisteredPasscodeMaster( void )//检查注册密码管理员数量
 801          {
 802   1        uint8_t i,MasterNum;
 803   1        MasterNum =0;
 804   1        for (i=0;i<(DEF_MAX_PASSCODEMASTER);i++)
 805   1        {
 806   2          if ( IfPasscodeUserIDisRegistered(i+1) == bTRUE )
 807   2          {
 808   3            MasterNum++;
 809   3          }
 810   2        }
 811   1        return MasterNum;
 812   1      }
 813          
 814          uint8_t CheckHowManyRegisteredPasscodeUser( void )//检查注册密码用户数量
 815          {
 816   1        uint8_t i,UserNum;
 817   1        UserNum =0;
 818   1        for (i=DEF_MAX_PASSCODEMASTER;i<(DEF_MAX_PASSCODEUSER+DEF_MAX_PASSCODEMASTER);i++)
 819   1        {
 820   2          if ( IfPasscodeUserIDisRegistered(i+1) == bTRUE )
 821   2          {
 822   3              UserNum++;
 823   3          }
 824   2        }
 825   1        return UserNum;
 826   1      }
 827          
 828          void DeletePasscodeUserfromMemory(uint8_t UserID)//从EEPROM内存中删除密码用户
 829          {
 830   1        uint8_t i,j;
 831   1      
 832   1        for (i=0;i<(DEF_MAX_PASSCODEUSER+DEF_MAX_PASSCODEMASTER);i++)
 833   1        {
 834   2          if (PasscodeMemoryMgr[i].UserID == UserID )
 835   2          {
 836   3            PasscodeMemoryMgr[i].Status = PasscodeIsInvalid;
 837   3            PasscodeMemoryMgr[i].UserID = 0xFF;
 838   3            for (j=0;j<6;j++)
 839   3            {
 840   4              PasscodeMemoryMgr[i].PasscodeBuff[j] = 0xFF;
 841   4            }
 842   3            break;
 843   3          }
 844   2        } 
 845   1      
 846   1        WritePasscodeUserMemoryToEEPROM();
 847   1      }
 848          
 849          void DeleteAllPasscodeMasterfromMemory(void)//从EEPROM内存中删除全部密码管理员
 850          {
 851   1        uint8_t i,j;
 852   1      
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      04/21/2023 14:57:04 PAGE 15  

 853   1        for (i=0;i<DEF_MAX_PASSCODEMASTER;i++)
 854   1        {
 855   2      
 856   2          PasscodeMemoryMgr[i].Status = PasscodeIsInvalid;
 857   2          PasscodeMemoryMgr[i].UserID = 0xFF;
 858   2          for (j=0;j<6;j++)
 859   2          {
 860   3            PasscodeMemoryMgr[i].PasscodeBuff[j] = 0xFF;
 861   3          }
 862   2      
 863   2        } 
 864   1        WritePasscodeUserMemoryToEEPROM();
 865   1      }
 866          
 867          void DeleteAllPasscodeUserfromMemory(void)//从EEPROM内存中删除全部密码用户
 868          {
 869   1        uint8_t i,j;
 870   1      
 871   1        for (i=DEF_MAX_PASSCODEMASTER;i<(DEF_MAX_PASSCODEMASTER+DEF_MAX_PASSCODEUSER);i++)
 872   1        {
 873   2      
 874   2          PasscodeMemoryMgr[i].Status = PasscodeIsInvalid;
 875   2          PasscodeMemoryMgr[i].UserID = 0xFF;
 876   2          for (j=0;j<6;j++)
 877   2          {
 878   3            PasscodeMemoryMgr[i].PasscodeBuff[j] = 0xFF;
 879   3          }
 880   2      
 881   2        } 
 882   1        WritePasscodeUserMemoryToEEPROM();
 883   1      }
 884          
 885          status_t SavePasscodeUserToMemory(uint8_t *Point,uint8_t UserID)//保存密码用户到内存
 886          {
 887   1        uint8_t j;
 888   1        for (j=0;j<6;j++)
 889   1        {
 890   2          PasscodeMemoryMgr[UserID-1].PasscodeBuff[j] = (*(Point+2*j))<<4|((*(Point+2*j+1)&0X0f));
 891   2        }
 892   1        PasscodeMemoryMgr[UserID-1].UserID = UserID;
 893   1        PasscodeMemoryMgr[UserID-1].Status = PasscodeIsValid;
 894   1        WritePasscodeUserMemoryToEEPROM();
 895   1        return S_SUCCESS;
 896   1      }
 897          
 898          uint8_t Get_Availabe_PasscodeMasterID(void)//获取已注册密码管理员ID
 899          {
 900   1        uint8_t i;
 901   1        for (i=0;i<DEF_MAX_PASSCODEMASTER;i++)
 902   1        {
 903   2          if ( PasscodeMemoryMgr[i].Status != PasscodeIsValid ){
 904   3            return (i+1);
 905   3          }
 906   2        }
 907   1        return 0;
 908   1      }
 909          
 910          uint8_t Get_Availabe_PasscodeUserID(void)//获取已注册密码用户ID
 911          {
 912   1        uint8_t i;
 913   1        for (i=DEF_MAX_PASSCODEMASTER;i<(DEF_MAX_PASSCODEMASTER+DEF_MAX_PASSCODEUSER);i++)
 914   1        {
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      04/21/2023 14:57:04 PAGE 16  

 915   2          if ( PasscodeMemoryMgr[i].Status != PasscodeIsValid ){
 916   3            return (i+1);
 917   3          }
 918   2        }
 919   1        return 0;
 920   1      }
 921          
 922          void GUI_GetUserNumList(void)//获取用户数量
 923          {
 924   1      
 925   1        if ( CheckMemoryMgr.Status == StartCheckMemory)
 926   1        {
 927   2          CheckHomManyRegisteredFPuser.Status = StartCheckHowManyRegisteredFPuser;
 928   2          CheckHomManyRegisteredFPuser.FailTimes = 0x00;
 929   2          CheckMemoryMgr.Status = WaitForReadFPuserNum;
 930   2        }
 931   1        else if ( CheckMemoryMgr.Status == WaitForReadFPuserNum )
 932   1        {
 933   2          CheckHowManyRegistereFPuser();
 934   2          if ( CheckHomManyRegisteredFPuser.Status == CheckHomManyRegisteredFPuserSuccess )
 935   2          {
 936   3            CheckMemoryMgr.FpUserNum = CheckHomManyRegisteredFPuser.UserNum;
 937   3            CheckMemoryMgr.FpMasterNum = CheckHomManyRegisteredFPuser.MasterNum;
 938   3            CheckMemoryMgr.CardUserNum = CheckHowManyRegisteredCardUser();
 939   3            CheckMemoryMgr.PasscodeMasterNum = CheckHowManyRegisteredPasscodeMaster();
 940   3            CheckMemoryMgr.PasscodeUserNum = CheckHowManyRegisteredPasscodeUser();
 941   3            CheckMemoryMgr.Status = CheckMemorySuccess;
 942   3          }
 943   2          else if ( CheckHomManyRegisteredFPuser.Status == CheckHomManyRegisteredFPuserFail )
 944   2          {
 945   3            if ( CheckHomManyRegisteredFPuser.FailTimes++ < 4 )
 946   3            {
 947   4              CheckHomManyRegisteredFPuser.Status = StartCheckHowManyRegisteredFPuser;//retry
 948   4            }
 949   3            else
 950   3            {
 951   4              CheckMemoryMgr.Status = CheckMemoryFail;
 952   4              CheckMemoryMgr.FpUserNum = 1;//CheckHomManyRegisteredFPuser.UserNum;
 953   4              CheckMemoryMgr.FpMasterNum = 1;//CheckHomManyRegisteredFPuser.MasterNum;
 954   4              CheckMemoryMgr.CardUserNum = CheckHowManyRegisteredCardUser();
 955   4              CheckMemoryMgr.PasscodeMasterNum = CheckHowManyRegisteredPasscodeMaster();
 956   4              CheckMemoryMgr.PasscodeUserNum = CheckHowManyRegisteredPasscodeUser();
 957   4            }
 958   3          }
 959   2        }
 960   1        
 961   1      }
 962          
 963          uint8_t TranslateNumberToVoice(uint8_t value)//将数字转换为语音
 964          {
 965   1        return 12+(2*value);
 966   1      }
 967          
 968          void SaveSystemTime( void )
 969          {
 970   1        SystemTime.year   =   TempSystemTime.year;
 971   1        SystemTime.month  =   TempSystemTime.month;
 972   1        SystemTime.date   =   TempSystemTime.date;
 973   1        SystemTime.day    =   TempSystemTime.day;
 974   1        SystemTime.hour   =   TempSystemTime.hour;
 975   1        SystemTime.minute =   TempSystemTime.minute;
 976   1        SystemTime.second =   TempSystemTime.second;
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      04/21/2023 14:57:04 PAGE 17  

 977   1      }
 978          
 979          void GotSystemTime( void )
 980          {
 981   1        TempSystemTime.year   = SystemTime.year;
 982   1        TempSystemTime.month  = SystemTime.month;
 983   1        TempSystemTime.date   = SystemTime.date;
 984   1        TempSystemTime.day    = SystemTime.day;
 985   1        TempSystemTime.hour   = SystemTime.hour;
 986   1        TempSystemTime.minute = SystemTime.minute;
 987   1        TempSystemTime.second = SystemTime.second;
 988   1      }
 989          
 990          
 991          
 992          
 993          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3304    ----
   CONSTANT SIZE    =     12    ----
   XDATA SIZE       =   ----      78
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

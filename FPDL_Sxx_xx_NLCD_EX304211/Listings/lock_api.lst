C51 COMPILER V9.60.0.0   LOCK_API                                                          03/08/2023 18:02:10 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE LOCK_API
OBJECT MODULE PLACED IN .\Objects\lock_api.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Drivers\Protocol\WIFI_Tuya\lock_api.c LARGE OMF2 OPTIMIZE(9,SPEED) BROWS
                    -E INCDIR(.\Drivers\Lib\c;.\Drivers\Lib\H;.\Drivers\Lib\IAP_Lib;.\Drivers\Lib\TouchKey_lib;.\Drivers\Physical;.\Drivers\P
                    -rotocol;.\Softwares\Application;.\Softwares\Basic;.\Softwares\ModuleLogic;.\Drivers\Protocol\YC_NFC;.\Drivers\Protocol\W
                    -IFI_Tuya) DEBUG PRINT(.\Listings\lock_api.lst) TABS(2) OBJECT(.\Objects\lock_api.obj)

line level    source

   1          /**********************************Copyright (c)**********************************
   2          **                       ç‰ˆæƒæ‰€æœ‰ (C), 2015-2020, æ¶‚é¸¦ç§‘æŠ€
   3          **
   4          **                             http://www.tuya.com
   5          **
   6          *********************************************************************************/
   7          /**
   8           * @file    lock_api.c
   9           * @author  æ¶‚é¸¦ç»¼åˆåè®®å¼€å‘ç»„
  10           * @version v1.0.7
  11           * @date    2020.11.9
  12           * @brief   é—¨é”ä¸‹å‘/ä¸ŠæŠ¥æ•°æ®å¤„ç†å‡½æ•°ï¼Œæ­¤æ–‡ä»¶ä¸‹å‡½æ•°æ— é¡»ç”¨æˆ·ä¿®æ”¹,ç”¨æˆ·éœ€è¦è°ƒç”
             -¨çš„æ–‡ä»¶éƒ½åœ¨è¯¥æ–‡ä»¶å†…
  13           */
  14          
  15          
  16          #define LOCK_API_GLOBAL
  17          
  18          #include "wifi.h"
  19          #include "lock_api.h"
  20          
  21          #ifdef LOCK_API_ENABLE
  22          /**
  23           * @brief  MCUè¯·æ±‚è·å–äº‘ç«¯ä¸´æ—¶å¯†ç 
  24           * @param  Null
  25           * @return Null
  26           * @note   MCUä¸»åŠ¨è°ƒç”¨å®Œæˆååœ¨ temp_pass_handle å‡½æ•°å†…å¯è·å–ä¸´æ—¶å¯†ç å’Œæœ‰æ•ˆæœŸ
  27           */
  28          void mcu_get_temp_pass(void)
  29          { 
  30   1          wifi_uart_write_frame(TEMP_PASS_CMD, 0);
  31   1      }
  32          
  33          /**
  34           * @brief  MCUè¯·æ±‚ä¸´æ—¶å¯†ç è¿”å›å‡½æ•°
  35           * @param[in] {suc_flag} è¯·æ±‚æ ‡å¿—(1:æˆåŠŸ;0:å¤±è´¥)
  36           * @param[in] {gl_time} å¯†ç æœ‰æ•ˆæœŸæ ¼æ—æ—¶é—´(ä»ä½åˆ°é«˜6ä½ï¼Œåˆ†åˆ«ä¸ºå¹´æœˆæ—¥æ—¶åˆ†ç§’)
  37           * @param[in] {pass} ä¸´æ—¶å¯†ç æ•°æ®(ascllç è¡¨ç¤ºï¼Œé•¿åº¦pass_len)
  38           * @param[in] {pass_len} ä¸´æ—¶å¯†ç æ•°æ®é•¿åº¦
  39           * @return Null
  40           * @note   MCUä¸»åŠ¨è°ƒç”¨ mcu_get_temp_pass æˆåŠŸå,è¯¥å‡½æ•°å†…å¯ä¸´æ—¶å¯†ç å’Œæœ‰æ•ˆæœŸ
  41           */
  42          void temp_pass_handle(unsigned char suc_flag, const unsigned char gl_time[], 
  43                                const unsigned char pass[], unsigned char pass_len)
  44          { 
  45   1          //#error "è¯·è‡ªè¡Œå®Œæˆä¸´æ—¶å¯†ç ç›¸å…³å¤„ç†ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
  46   1      
  47   1          /*
  48   1          suc_flagä¸ºæ˜¯å¦è·å–å¯†ç æˆåŠŸæ ‡å¿—ï¼Œä¸º 0 è¡¨ç¤ºå¤±è´¥ï¼Œä¸º 1 è¡¨ç¤ºæˆåŠŸ
  49   1         */
  50   1          /*
  51   1          gl_timeä¸ºå¯†ç æœ‰æ•ˆæœŸæ ¼æ—æ—¶é—´
C51 COMPILER V9.60.0.0   LOCK_API                                                          03/08/2023 18:02:10 PAGE 2   

  52   1          gl_time[0]ä¸ºå¹´ä»½ , 0x00 è¡¨ ç¤º2000 å¹´
  53   1          gl_time[1]ä¸ºæœˆä»½ï¼Œä» 1 å¼€å§‹åˆ°12 ç»“æŸ
  54   1          gl_time[2]ä¸ºæ—¥æœŸï¼Œä» 1 å¼€å§‹åˆ°31 ç»“æŸ
  55   1          gl_time[3]ä¸ºæ—¶é’Ÿï¼Œä» 0 å¼€å§‹åˆ°23 ç»“æŸ
  56   1          gl_time[4]ä¸ºåˆ†é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
  57   1          gl_time[5]ä¸ºç§’é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
  58   1      
  59   1          passæŒ‡å‘ä¸´æ—¶å¯†ç æ•°æ®(ascllç )ï¼Œé•¿åº¦pass_len
  60   1         */
  61   1          if (suc_flag == 1) {
  62   2              //è·å–ä¸´æ—¶å¯†ç æ•°æ®æˆåŠŸ
  63   2          }else {
  64   2              //è·å–ä¸´æ—¶å¯†ç æ•°æ®å‡ºé”™
  65   2          }
  66   1      }
*** WARNING C280 IN LINE 42 OF Drivers\Protocol\WIFI_Tuya\lock_api.c: 'gl_time': unreferenced local variable
*** WARNING C280 IN LINE 43 OF Drivers\Protocol\WIFI_Tuya\lock_api.c: 'pass': unreferenced local variable
*** WARNING C280 IN LINE 43 OF Drivers\Protocol\WIFI_Tuya\lock_api.c: 'pass_len': unreferenced local variable
  67          
  68          /**
  69           * @brief  MCUè¯·æ±‚åŠ¨æ€å¯†ç æ ¡éªŒ
  70           * @param[in] {time} è¯·æ±‚å½“å‰æ ¼æ—æ—¶é—´(ä»ä½åˆ°é«˜6ä½ï¼Œåˆ†åˆ«ä¸ºå¹´æœˆæ—¥æ—¶åˆ†ç§’)
  71           * @param[in] {user_pass} ç”¨æˆ·è¾“å…¥çš„åŠ¨æ€å¯†ç (ä»ä½åˆ°é«˜8ä½ï¼Œå¯†ç ç”¨ASCLLä¼ å…¥ï¼ŒèŒƒå›´'0'-
             -'9')
  72           * @param[in] {admin_num} ç®¡ç†å‘˜å¯†ç ç»„æ•°(0~10ï¼Œè‹¥ä¸º0åˆ™åé¢å‚æ•°æ— æ•ˆ)
  73           * @param[in] {admin_len} ç®¡ç†å‘˜å¯†ç é•¿åº¦(æœ€é•¿8ä¸ªå­—èŠ‚)
  74           * @param[in] {admin_pass} å¤šç»„ç®¡ç†å‘˜å¯†ç (å¤šç»„å¯†ç ä¾æ¬¡æ’åˆ—ï¼Œé•¿åº¦admin_num*admin_lenï¼Œç”
             -¨ASCLLä¼ å…¥ï¼ŒèŒƒå›´'0'-'9')
  75           * @return Null
  76           * @note   1:MCUä¸»åŠ¨è°ƒç”¨
  77                     2:æˆåŠŸå,åœ¨ pass_check_handle å‡½æ•°å†…å¯è·å–åŠ¨æ€å¯†ç æ ¡éªŒç»“æœ
  78           */
  79          void dynamic_pass_check(unsigned char time[], unsigned char user_pass[], unsigned char admin_num,
  80                                  unsigned char admin_len, unsigned char admin_pass[])
  81          { 
  82   1          unsigned char length = 0;
  83   1          unsigned char i = 0;
  84   1      
  85   1          length = set_wifi_uart_buffer(length,(unsigned char *)time, 6);
  86   1          length = set_wifi_uart_buffer(length,(unsigned char *)user_pass, 8);
  87   1          length = set_wifi_uart_byte(length, admin_num);
  88   1      
  89   1          if (admin_num > 0) {
  90   2              length = set_wifi_uart_byte(length, admin_len);
  91   2      
  92   2              for(i=0;i<admin_num;i++) {
  93   3                  length = set_wifi_uart_buffer(length,(unsigned char *)(admin_pass+admin_len*i), admin_len);
  94   3              }
  95   2          }
  96   1      
  97   1          wifi_uart_write_frame(PASS_CHECK_CMD, length);
  98   1      }
  99          
 100          /**
 101           * @brief  MCUè¯·æ±‚æ ¡éªŒåŠ¨æ€å¯†ç è¿”å›å‡½æ•°
 102           * @param[in] {status} æ ¡éªŒæ ‡å¿—(0:æˆåŠŸ;1:å¤±è´¥;2:æœªæ¿€æ´»;3:é•¿åº¦é”™è¯¯)
 103           * @return Null
 104           * @note   MCUä¸»åŠ¨è°ƒç”¨ dynamic_pass_check æˆåŠŸå,è¯¥å‡½æ•°å†…å¯è·å–æ ¡éªŒç»“æœ
 105           */
 106          void pass_check_handle(unsigned char status)
 107          { 
 108   1          //#error "è¯·è‡ªè¡Œå®ŒæˆåŠ¨æ€å¯†ç æ ¡éªŒç»“æœå¤„ç†ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
C51 COMPILER V9.60.0.0   LOCK_API                                                          03/08/2023 18:02:10 PAGE 3   

 109   1      
 110   1          switch (status) {
 111   2              case 0: {
 112   3                  //å¯†ç æ ¸å¯¹é€šè¿‡
 113   3                  break;
 114   3              }
 115   2      
 116   2              case 1: {
 117   3                  //å¯†ç æ ¸å¯¹å¤±è´¥
 118   3                  break;
 119   3              }
 120   2      
 121   2              case 2: {
 122   3                  //è®¾å¤‡æœªæ¿€æ´»
 123   3                  break;
 124   3              }
 125   2      
 126   2              case 3: {
 127   3                  //æ•°æ®é•¿åº¦é”™è¯¯
 128   3                  break;
 129   3              }
 130   2      
 131   2              default:
 132   2              break;
 133   2          }
 134   1      }
 135          
 136          /**
 137           * @brief  MCUè¯·æ±‚è·å–äº‘ç«¯å¤šç»„ä¸´æ—¶å¯†ç 
 138           * @param  Null
 139           * @return Null
 140           * @note   MCUä¸»åŠ¨è°ƒç”¨å®Œæˆååœ¨ mul_temp_pass_data å‡½æ•°å†…å¯è·å–ä¸´æ—¶å¯†ç å‚æ•°å’Œæœ‰æ•ˆæœŸ
             -æ—¶é™
 141           */
 142          void mcu_get_mul_temp_pass(void)
 143          { 
 144   1          wifi_uart_write_frame(MUL_TEMP_PASS_CMD, 0);
 145   1      }
 146          
 147          
 148          /**
 149           * @brief  MCUè¯·æ±‚å¤šç»„ä¸´æ—¶å¯†ç å¤„ç†å‡½æ•°
 150           * @param[in] {suc_flag} è¯·æ±‚æ ‡å¿—(1:æˆåŠŸ;0:å¤±è´¥)
 151           * @param[in] {pass_ser} å½“å‰ç»„å¯†ç ç¼–å·(å®é™…ç¼–å·é¡»+900)
 152           * @param[in] {pass_valcnt} å½“å‰ç»„å¯†ç æœ‰æ•ˆæ¬¡æ•°(0:ä¸é™æ¬¡æ•°;1:ä¸€æ¬¡æ€§)
 153           * @param[in] {pass_sta} å¯†ç å½“å‰çŠ¶æ€(0:æœ‰æ•ˆ;1:è¢«åˆ é™¤æ— æ•ˆ)
 154           * @param[in] {gl_start} å¯†ç ç”Ÿæ•ˆæ—¥æœŸæ ¼æ—æ—¶é—´(ä»ä½åˆ°é«˜6ä½ï¼Œåˆ†åˆ«ä¸ºå¹´æœˆæ—¥æ—¶åˆ†ç§’)
 155           * @param[in] {gl_end} å¯†ç å¤±æ•ˆæ—¥æœŸæ ¼æ—æ—¶é—´(ä»ä½åˆ°é«˜6ä½ï¼Œåˆ†åˆ«ä¸ºå¹´æœˆæ—¥æ—¶åˆ†ç§’)
 156           * @param[in] {pass} ä¸´æ—¶å¯†ç æ•°æ®(ascllç è¡¨ç¤ºï¼Œé•¿åº¦pass_len)
 157           * @param[in] {pass_len} ä¸´æ—¶å¯†ç æ•°æ®é•¿åº¦
 158           * @return Null
 159           * @note   MCUä¸»åŠ¨è°ƒç”¨ mcu_get_mul_temp_pass æˆåŠŸåï¼Œè¯¥å‡½æ•°å†…å¯å¤šæ¬¡åˆ†åˆ«è·å–æ¯ç»„çš„ä¸´
             -æ—¶å¯†ç ä¸æœ‰æ•ˆæœŸé™
 160           */
 161          static void mul_temp_pass_data(unsigned char suc_flag, unsigned char pass_ser, 
 162                                         unsigned char pass_valcnt, unsigned char pass_sta, 
 163                                         const unsigned char gl_start[], const unsigned char gl_end[], 
 164                                         const unsigned char pass[], unsigned char pass_len)
 165          { 
 166   1          //#error "è¯·è‡ªè¡Œå®Œæˆå¤šç»„ä¸´æ—¶å¯†ç ä¿¡æ¯å¤„ç†ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
 167   1      
 168   1          /*
C51 COMPILER V9.60.0.0   LOCK_API                                                          03/08/2023 18:02:10 PAGE 4   

 169   1          suc_flagä¸ºæ˜¯å¦è·å–å¯†ç æˆåŠŸæ ‡å¿—ï¼Œä¸º 0 è¡¨ç¤ºå¤±è´¥ï¼Œä¸º 1 è¡¨ç¤ºæˆåŠŸ
 170   1         */
 171   1          /*
 172   1          pass_serä¸ºå¯†ç ç¼–å·
 173   1          pass_valcntä¸ºå¯†ç æœ‰æ•ˆæ¬¡æ•°
 174   1          pass_staä¸ºå¯†ç å½“å‰çŠ¶æ€
 175   1      
 176   1          gl_startä¸ºå¯†ç ç”Ÿæ•ˆæ—¥æœŸæ ¼æ—æ—¶é—´
 177   1          gl_start[0]ä¸ºå¹´ä»½ , 0x00 è¡¨ ç¤º2000 å¹´
 178   1          gl_start[1]ä¸ºæœˆä»½ï¼Œä» 1 å¼€å§‹åˆ°12 ç»“æŸ
 179   1          gl_start[2]ä¸ºæ—¥æœŸï¼Œä» 1 å¼€å§‹åˆ°31 ç»“æŸ
 180   1          gl_start[3]ä¸ºæ—¶é’Ÿï¼Œä» 0 å¼€å§‹åˆ°23 ç»“æŸ
 181   1          gl_start[4]ä¸ºåˆ†é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
 182   1          gl_start[5]ä¸ºç§’é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
 183   1          gl_endä¸ºå¯†ç æˆªè‡³æ—¥æœŸæ ¼æ—æ—¶é—´ï¼ŒåŒgl_start
 184   1      
 185   1          passæŒ‡å‘ä¸´æ—¶å¯†ç æ•°æ®(ascllç )ï¼Œé•¿åº¦pass_len
 186   1         */
 187   1      
 188   1          /*
 189   1          æ³¨ï¼šè·å–å¤šç»„å¯†ç æˆåŠŸï¼Œè¯¥å‡½æ•°ä¼šè¿›å…¥å¤šæ¬¡ï¼Œ
 190   1              ç›´è‡³å°†å¤šç»„ä¸´æ—¶å¯†ç å…¨éƒ¨è·å–å®Œç»“æŸï¼›
 191   1              è‹¥å¤±è´¥åˆ™åªè¿›å…¥ä¸€æ¬¡ã€‚
 192   1         */
 193   1          if (suc_flag == 1) {
 194   2              //è·å–å¤šç»„ä¸´æ—¶å¯†ç æ•°æ®æˆåŠŸ
 195   2          }else {
 196   2              //è·å–å¤šç»„ä¸´æ—¶å¯†ç æ•°æ®å‡ºé”™
 197   2          }
 198   1      }
*** WARNING C280 IN LINE 161 OF Drivers\Protocol\WIFI_Tuya\lock_api.c: 'pass_ser': unreferenced local variable
*** WARNING C280 IN LINE 162 OF Drivers\Protocol\WIFI_Tuya\lock_api.c: 'pass_valcnt': unreferenced local variable
*** WARNING C280 IN LINE 162 OF Drivers\Protocol\WIFI_Tuya\lock_api.c: 'pass_sta': unreferenced local variable
*** WARNING C280 IN LINE 163 OF Drivers\Protocol\WIFI_Tuya\lock_api.c: 'gl_start': unreferenced local variable
*** WARNING C280 IN LINE 163 OF Drivers\Protocol\WIFI_Tuya\lock_api.c: 'gl_end': unreferenced local variable
*** WARNING C280 IN LINE 164 OF Drivers\Protocol\WIFI_Tuya\lock_api.c: 'pass': unreferenced local variable
*** WARNING C280 IN LINE 164 OF Drivers\Protocol\WIFI_Tuya\lock_api.c: 'pass_len': unreferenced local variable
 199          
 200          /**
 201           * @brief  MCUè¯·æ±‚å¤šç»„ä¸´æ—¶å¯†ç è¿”å›å‡½æ•°
 202           * @param[in] {_data} è¿”å›æ•°æ®
 203           * @return Null
 204           * @note   Null
 205           */
 206          void mul_temp_pass_handle(const unsigned char _data[])
 207          {
 208   1          unsigned char i = 0;
 209   1      
 210   1          unsigned char suc_flag = _data[0];
 211   1          unsigned char pass_num = _data[1];
 212   1          unsigned char pass_len = _data[2];
 213   1          unsigned char offset = 0;
 214   1      
 215   1          if (suc_flag == 1) {
 216   2              for (i=0;i<pass_num;i++) {
 217   3                  offset = i*(15+pass_len);
 218   3                  mul_temp_pass_data(suc_flag, _data[offset+3], _data[offset+4], _data[offset+5], 
 219   3                                     _data+offset+6, _data+offset+12, _data+offset+18, pass_len);
 220   3              }
 221   2          }else {
 222   2              mul_temp_pass_data(suc_flag, 0, 0, 0, 0, 0, 0, 0);
 223   2          }
C51 COMPILER V9.60.0.0   LOCK_API                                                          03/08/2023 18:02:10 PAGE 5   

 224   1      }
 225          
 226          /**
 227           * @brief  MCUè¯·æ±‚è·å–äº‘ç«¯ä¸´æ—¶å¯†ç (å¸¦scheduleåˆ—è¡¨)
 228           * @param  Null
 229           * @return Null
 230           * @note   MCUä¸»åŠ¨è°ƒç”¨å®Œæˆååœ¨ mul_temp_pass_data å‡½æ•°å†…å¯è·å–ç»“æœ
 231           */
 232          void mcu_get_schedule_temp_pass(void)
 233          { 
 234   1          wifi_uart_write_frame(SCHEDULE_TEMP_PASS_CMD, 0);
 235   1      }
 236          
 237          /**
 238           * @brief  scheduleåˆ—è¡¨æ•°æ®å¤„ç†
 239           * @param[in] {schedule_num} scheduleåˆ—è¡¨æ•°é‡
 240           * @param[in] {schedule_data} scheduleåˆ—è¡¨æ•°æ®
 241           * @return Null
 242           * @note   MCUè°ƒç”¨ schedule_temp_pass_data æˆåŠŸåï¼Œè¯¥å‡½æ•°å†…å¯å¯¹ schedule åˆ—è¡¨æ•°æ®è¿›è¡Œå¤„
             -ç†
 243           */
 244          static void schedule_data_process(unsigned char schedule_num, const unsigned char schedule_data[])
 245          {
 246   1         // #error "è¯·è‡ªè¡Œå®Œæˆå¸¦scheduleåˆ—è¡¨å¤„ç†ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
 247   1          
 248   1          unsigned char i = 0;
 249   1          unsigned char offset = 0;
 250   1          
 251   1          for(i=0;i<schedule_num;i++) {
 252   2              /*
 253   2              åœ¨æ­¤æ·»åŠ scheduleåˆ—è¡¨æ•°æ®å¤„ç†
 254   2              schedule_data[offset]: 0ï¼šéå…¨å¤©æœ‰æ•ˆï¼Œåˆ†æ—¶é—´æ®µæœ‰æ•ˆ  1ï¼šå…¨å¤©æœ‰æ•ˆã€‚åé¢çš„èµ·å§
             -‹æ—¶é—´å’Œç»“æŸæ—¶é—´ä¸ºæ— æ•ˆæ•°æ®
 255   2              schedule_data[offset+1]: å¼€å§‹æ—¶é—´ï¼ˆå°æ—¶ï¼‰
 256   2              schedule_data[offset+2]: å¼€å§‹æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰
 257   2              schedule_data[offset+3]: ç»“æŸæ—¶é—´ï¼ˆå°æ—¶ï¼‰
 258   2              schedule_data[offset+4]: ç»“æŸæ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰
 259   2              schedule_data[offset+5]: å‘¨å¾ªç¯  Â Bit0:å‘¨æ—¥Â Bit1:å‘¨ä¸€Â Bit2:å‘¨äºŒÂ Bit3:å‘¨ä¸‰Â Bit4:å‘¨
             -å››Â Bit5:å‘¨äº”Â Bit6:å‘¨å…­
 260   2                                       è‹¥æ­¤æ¡scheduleå‘¨æ—¥ï¼Œå‘¨ä¸‰å¾ªç¯ï¼Œåˆ™ä¸º0x09
 261   2              */
 262   2              
 263   2              offset += 6;
 264   2          }
 265   1      }
*** WARNING C280 IN LINE 244 OF Drivers\Protocol\WIFI_Tuya\lock_api.c: 'schedule_data': unreferenced local variable
 266          
 267          /**
 268           * @brief  MCUè¯·æ±‚å¸¦scheduleåˆ—è¡¨ä¸´æ—¶å¯†ç å¤„ç†å‡½æ•°
 269           * @param[in] {suc_flag} è¯·æ±‚æ ‡å¿—(1:æˆåŠŸ;0:å¤±è´¥)
 270           * @param[in] {pass_ser} å½“å‰ç»„å¯†ç ç¼–å·(å®é™…ç¼–å·é¡»+900)
 271           * @param[in] {pass_valcnt} å½“å‰ç»„å¯†ç æœ‰æ•ˆæ¬¡æ•°(0:ä¸é™æ¬¡æ•°;1:ä¸€æ¬¡æ€§)
 272           * @param[in] {pass_sta} å¯†ç å½“å‰çŠ¶æ€(0:æœ‰æ•ˆ;1:è¢«åˆ é™¤æ— æ•ˆ)
 273           * @param[in] {gl_start} å¯†ç ç”Ÿæ•ˆæ—¥æœŸæ ¼æ—æ—¶é—´(ä»ä½åˆ°é«˜6ä½ï¼Œåˆ†åˆ«ä¸ºå¹´æœˆæ—¥æ—¶åˆ†ç§’)
 274           * @param[in] {gl_end} å¯†ç å¤±æ•ˆæ—¥æœŸæ ¼æ—æ—¶é—´(ä»ä½åˆ°é«˜6ä½ï¼Œåˆ†åˆ«ä¸ºå¹´æœˆæ—¥æ—¶åˆ†ç§’)
 275           * @param[in] {pass} ä¸´æ—¶å¯†ç æ•°æ®(ascllç è¡¨ç¤ºï¼Œé•¿åº¦pass_len)
 276           * @param[in] {pass_len} ä¸´æ—¶å¯†ç æ•°æ®é•¿åº¦
 277           * @param[in] {schedule_num} scheduleåˆ—è¡¨æ•°é‡
 278           * @param[in] {schedule_data} scheduleåˆ—è¡¨æ•°æ®
 279           * @return Null
 280           * @note   MCUä¸»åŠ¨è°ƒç”¨ mcu_get_mul_temp_pass æˆåŠŸåï¼Œè¯¥å‡½æ•°å†…å¯å¤šæ¬¡åˆ†åˆ«è·å–æ¯ç»„çš„ä¸´
             -æ—¶å¯†ç ä¸æœ‰æ•ˆæœŸé™
C51 COMPILER V9.60.0.0   LOCK_API                                                          03/08/2023 18:02:10 PAGE 6   

 281           */
 282          static void schedule_temp_pass_data(unsigned char suc_flag, unsigned char pass_ser, 
 283                                         unsigned char pass_valcnt, unsigned char pass_sta, 
 284                                         const unsigned char gl_start[], const unsigned char gl_end[], 
 285                                         const unsigned char pass[], unsigned char pass_len,
 286                                         unsigned char schedule_num, const unsigned char schedule_data[])
 287          { 
 288   1          //#error "è¯·è‡ªè¡Œå®Œæˆå¸¦scheduleåˆ—è¡¨ä¸´æ—¶å¯†ç ä¿¡æ¯å¤„ç†ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
 289   1      
 290   1          /*
 291   1          suc_flagä¸ºæ˜¯å¦è·å–å¯†ç æˆåŠŸæ ‡å¿—ï¼Œä¸º 0 è¡¨ç¤ºå¤±è´¥ï¼Œä¸º 1 è¡¨ç¤ºæˆåŠŸ
 292   1         */
 293   1          /*
 294   1          æ³¨ï¼šè·å–å¤šç»„å¯†ç æˆåŠŸï¼Œè¯¥å‡½æ•°ä¼šè¿›å…¥å¤šæ¬¡ï¼Œ
 295   1              ç›´è‡³å°†å¤šç»„ä¸´æ—¶å¯†ç å…¨éƒ¨è·å–å®Œç»“æŸï¼›
 296   1              è‹¥å¤±è´¥åˆ™åªè¿›å…¥ä¸€æ¬¡ã€‚
 297   1         */
 298   1          if (suc_flag == 1) {
 299   2              //è·å–ä¸´æ—¶å¯†ç æ•°æ®æˆåŠŸ
 300   2              /*
 301   2              pass_serä¸ºå¯†ç ç¼–å·
 302   2              pass_valcntä¸ºå¯†ç æœ‰æ•ˆæ¬¡æ•°
 303   2              pass_staä¸ºå¯†ç å½“å‰çŠ¶æ€
 304   2      
 305   2              gl_startä¸ºå¯†ç ç”Ÿæ•ˆæ—¥æœŸæ ¼æ—æ—¶é—´
 306   2              gl_start[0]ä¸ºå¹´ä»½ , 0x00 è¡¨ ç¤º2000 å¹´
 307   2              gl_start[1]ä¸ºæœˆä»½ï¼Œä» 1 å¼€å§‹åˆ°12 ç»“æŸ
 308   2              gl_start[2]ä¸ºæ—¥æœŸï¼Œä» 1 å¼€å§‹åˆ°31 ç»“æŸ
 309   2              gl_start[3]ä¸ºæ—¶é’Ÿï¼Œä» 0 å¼€å§‹åˆ°23 ç»“æŸ
 310   2              gl_start[4]ä¸ºåˆ†é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
 311   2              gl_start[5]ä¸ºç§’é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
 312   2              gl_endä¸ºå¯†ç æˆªè‡³æ—¥æœŸæ ¼æ—æ—¶é—´ï¼ŒåŒgl_start
 313   2      
 314   2              passæŒ‡å‘ä¸´æ—¶å¯†ç æ•°æ®(ascllç )ï¼Œé•¿åº¦pass_len
 315   2              */
 316   2              
 317   2              //æ­¤å¤„æ·»åŠ å¯†ç æ•°æ®å¤„ç†
 318   2              
 319   2              schedule_data_process(schedule_num, schedule_data);
 320   2          }else {
 321   2              //è·å–ä¸´æ—¶å¯†ç æ•°æ®å‡ºé”™
 322   2          }
 323   1      }
*** WARNING C280 IN LINE 282 OF Drivers\Protocol\WIFI_Tuya\lock_api.c: 'pass_ser': unreferenced local variable
*** WARNING C280 IN LINE 283 OF Drivers\Protocol\WIFI_Tuya\lock_api.c: 'pass_valcnt': unreferenced local variable
*** WARNING C280 IN LINE 283 OF Drivers\Protocol\WIFI_Tuya\lock_api.c: 'pass_sta': unreferenced local variable
*** WARNING C280 IN LINE 284 OF Drivers\Protocol\WIFI_Tuya\lock_api.c: 'gl_start': unreferenced local variable
*** WARNING C280 IN LINE 284 OF Drivers\Protocol\WIFI_Tuya\lock_api.c: 'gl_end': unreferenced local variable
*** WARNING C280 IN LINE 285 OF Drivers\Protocol\WIFI_Tuya\lock_api.c: 'pass': unreferenced local variable
*** WARNING C280 IN LINE 285 OF Drivers\Protocol\WIFI_Tuya\lock_api.c: 'pass_len': unreferenced local variable
 324          
 325          /**
 326           * @brief  MCUè¯·æ±‚ä¸´æ—¶å¯†ç (å¸¦scheduleåˆ—è¡¨)è¿”å›
 327           * @param[in] {_data} è¿”å›æ•°æ®
 328           * @return Null
 329           * @note   Null
 330           */
 331          void schedule_temp_pass_handle(const unsigned char _data[])
 332          {
 333   1          unsigned char i = 0;
 334   1      
 335   1          unsigned char suc_flag = _data[0];
C51 COMPILER V9.60.0.0   LOCK_API                                                          03/08/2023 18:02:10 PAGE 7   

 336   1          unsigned char pass_num = _data[1];
 337   1          unsigned char pass_len = _data[2];
 338   1        //  unsigned char pack_num = _data[3] & 0x7f;
 339   1        //  unsigned char next_pack_flag = _data[3] >> 7;
 340   1          unsigned char offset = 4;
 341   1      
 342   1          if (suc_flag == 1) {
 343   2              for (i=0;i<pass_num;i++) {
 344   3                  schedule_temp_pass_data(suc_flag, _data[offset], _data[offset+1], _data[offset+2], _data+offse
             -t+3, 
 345   3                                     _data+offset+9, _data+offset+15, pass_len, _data[offset+15+pass_len],_data+
             -offset+15+pass_len+1);
 346   3                  offset += 15 + pass_len + 1 + 6*_data[offset+15+pass_len];
 347   3              }
 348   2          }else {
 349   2              schedule_temp_pass_data(suc_flag, 0, 0, 0, 0, 0, 0, 0, 0, 0);
 350   2          }
 351   1      }
 352          
 353          #ifdef OFFLINE_DYN_PW_ENABLE
              /**
               * @brief  ç¦»çº¿åŠ¨æ€å¯†ç 
               * @param[in] {green_time} æ ¼æ—æ—¶é—´
                              green_time[0]ä¸ºå¹´ä»½ï¼Œ0x00 è¡¨ç¤º2000 å¹´
                              green_time[1]ä¸ºæœˆä»½ï¼Œä» 1 å¼€å§‹åˆ°12 ç»“æŸ
                              green_time[2]ä¸ºæ—¥æœŸï¼Œä» 1 å¼€å§‹åˆ°31 ç»“æŸ
                              green_time[3]ä¸ºæ—¶é’Ÿï¼Œä» 0 å¼€å§‹åˆ°23 ç»“æŸ
                              green_time[4]ä¸ºåˆ†é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                              green_time[5]ä¸ºç§’é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
               * @param[in] {pw} ç¦»çº¿åŠ¨æ€å¯†ç 
               * @param[in] {pw_len} ç¦»çº¿åŠ¨æ€å¯†ç é•¿åº¦
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œè°ƒç”¨åï¼Œå¯åœ¨offline_dynamic_password_resultå‡½æ•°ä¸­å¯¹ç»“æœè¿›è¡Œå¤„ç†
               */
              void offline_dynamic_password(unsigned char green_time[],unsigned char pw[],unsigned char pw_len)
              {
                  unsigned char length = 0;
                  
                  length = set_wifi_uart_buffer(length,green_time,6);
                  length = set_wifi_uart_byte(length,pw_len);
                  length = set_wifi_uart_buffer(length,pw,pw_len);
                  
                  wifi_uart_write_frame(OFFLINE_DYN_PW_CMD,length);
              }
              
              /**
               * @brief  ç¦»çº¿åŠ¨æ€å¯†ç ç»“æœ
               * @param[in] {result_data} ç»“æœæ•°æ®
               * @return Null
               * @note   MCUéœ€è¦å…ˆè‡ªè¡Œè°ƒç”¨offline_dynamic_passwordå‡½æ•°åï¼Œåœ¨æ­¤å‡½æ•°å¯¹æ¥æ”¶çš„ç»“æœè¿›è¡
             -Œå¤„ç†
               */
              void offline_dynamic_password_result(unsigned char result_data[])
              {
                  //#error "è¯·è‡ªè¡Œå®Œæˆç¦»çº¿åŠ¨æ€å¯†ç ç»“æœå¤„ç†ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  unsigned char result; //å¯†ç æ­£ç¡®æ€§
                  unsigned char type; //å¯†ç ç±»å‹
                  unsigned char decode_len; //è§£å¯†åæ•°æ®é•¿åº¦
                  unsigned char decode[DECODE_MAX_LEN]; //è§£å¯†æ•°æ®
                  
                  result = result_data[0];
                  if(0 == result) {
C51 COMPILER V9.60.0.0   LOCK_API                                                          03/08/2023 18:02:10 PAGE 8   

                      //æ­£ç¡®
                  }else {
                      //é”™è¯¯
                      return; //é”™è¯¯æ—¶ï¼Œæ— åç»­æ•°æ®
                  }
                  
                  type = result_data[1];
                  switch(type) {
                      case 0:
                          //é™æ—¶å¼€é—¨å¯†ç 
                      break;
                      
                      case 1:
                          //å•æ¬¡å¼€é—¨å¯†ç 
                      break;
                      
                      case 2:
                          //æ¸…é™¤å¯†ç 
                      break;
                      
                      default:
                      break;
                  }
                  
                  decode_len = result_data[2];
                  my_memcpy(decode,&result_data[3],decode_len);
                  
                  //å¯æ·»åŠ è§£å¯†æ•°æ®å¤„ç†
                  
              }
              #endif
 426          
 427          #ifdef PICTURE_UPLOAD_ENABLE
              /**
               * @brief  å›¾ç‰‡ä¸Šä¼ äº‹ä»¶çŠ¶æ€é€šçŸ¥
               * @param[in] {event} äº‹ä»¶ä¿¡æ¯ç¼–ç 
               * @param[in] {picture} æ˜¯å¦æºå¸¦å›¾ç‰‡ä¿¡æ¯
               * @param[in] {pic_num} ä¸Šä¼ å›¾ç‰‡å¼ æ•°(<=10)
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œè°ƒç”¨åï¼Œå¯åœ¨ picture_event_state_notice_result å‡½æ•°ä¸­å¯¹ç»“æœè¿›è¡Œå¤„
             -ç†
               */
              void picture_event_state_notice(unsigned short event, unsigned char picture, unsigned char pic_num)
              {
                  unsigned char length = 0;
                
                  length = set_wifi_uart_byte(length, (event >> 8) & 0xff);
                  length = set_wifi_uart_byte(length, event & 0xff);
                  length = set_wifi_uart_byte(length, picture);
                  length = set_wifi_uart_byte(length, pic_num);
                  
                  wifi_uart_write_frame(PICTURE_EVENT_STATE_CMD,length);
              }
              
              /**
               * @brief  å›¾ç‰‡ä¸Šä¼ äº‹ä»¶çŠ¶æ€é€šçŸ¥ç»“æœ
               * @param[in] {result} ç»“æœ
               * @return Null
               * @note   MCUéœ€è¦å…ˆè‡ªè¡Œè°ƒç”¨ picture_event_state_notice å‡½æ•°åï¼Œåœ¨æ­¤å‡½æ•°å¯¹æ¥æ”¶çš„ç»“æœè
             -¿›è¡Œå¤„ç†
               */
              void picture_event_state_notice_result(unsigned char result)
C51 COMPILER V9.60.0.0   LOCK_API                                                          03/08/2023 18:02:10 PAGE 9   

              {
                  #error "è¯·è‡ªè¡Œå®Œæˆå›¾ç‰‡ä¸Šä¼ æ—¶é—´çŠ¶æ€é€šçŸ¥ç»“æœå¤„ç†ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  if (0 == result) {
                      //ä¿¡æ¯æ¥æ”¶æˆåŠŸ
                  }else {
                      //ä¿¡æ¯æ¥æ”¶å¤±è´¥
                  }
              }
              
              /**
               * @brief  å›¾ç‰‡ä¸Šä¼ 
               * @param[in] {p_time} æ—¶é—´æ•°æ®
               * @param[in] {picture_id} å›¾ç‰‡idå·
               * @param[in] {pic_total_num} å›¾ç‰‡æ€»åŒ…æ•°
               * @param[in] {pic_num} å½“å‰åŒ…åºå·ï¼ˆä»0å¼€å§‹ï¼‰
               * @param[in] {p_pic_data} å›¾ç‰‡æ•°æ®
               * @param[in] {pic_data_len} å›¾ç‰‡æ•°æ®é•¿åº¦
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œè°ƒç”¨åï¼Œå¯åœ¨ picture_upload_result å‡½æ•°ä¸­å¯¹ç»“æœè¿›è¡Œå¤„ç†
               */
              void picture_upload(unsigned char p_time[], unsigned short picture_id, unsigned short pic_total_num, unsig
             -ned short pic_num, \
                                                          unsigned char p_pic_data[], unsigned char pic_data_len)
              {
                  unsigned char length = 0;
                  
                  length = set_wifi_uart_buffer(length, p_time, 7);
                  length = set_wifi_uart_byte(length, (picture_id >> 8) & 0xff);
                  length = set_wifi_uart_byte(length, picture_id & 0xff);
                  length = set_wifi_uart_byte(length, (pic_total_num >> 8) & 0xff);
                  length = set_wifi_uart_byte(length, pic_total_num & 0xff);
                  length = set_wifi_uart_byte(length, (pic_num >> 8) & 0xff);
                  length = set_wifi_uart_byte(length, pic_num & 0xff);
                  length = set_wifi_uart_buffer(length, p_pic_data, pic_data_len);
                  
                  wifi_uart_write_frame(PICTURE_UPLOAD_CMD,length);
              }
              
              /**
               * @brief  å›¾ç‰‡ä¸Šä¼ ç»“æœ
               * @param[in] {result} ç»“æœ
               * @return Null
               * @note   MCUéœ€è¦å…ˆè‡ªè¡Œè°ƒç”¨ picture_upload å‡½æ•°åï¼Œåœ¨æ­¤å‡½æ•°å¯¹æ¥æ”¶çš„ç»“æœè¿›è¡Œå¤„ç†
               */
              void picture_upload_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆå›¾ç‰‡ä¸Šä¼ ç»“æœå¤„ç†ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  if (0 == result) {
                      //ä¿¡æ¯æ¥æ”¶æˆåŠŸ
                  }else {
                      //ä¿¡æ¯æ¥æ”¶å¤±è´¥
                  }
              }
              
              /**
               * @brief  å›¾ç‰‡ä¸Šä¼ ç»“æœåé¦ˆ
               * @param[in] {p_value} ç»“æœæ•°æ®
               * @param[in] {data_len} ç»“æœæ•°æ®é•¿åº¦
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå¯¹æ¥æ”¶çš„ç»“æœè¿›è¡Œå¤„ç†
               */
              void picture_upload_return(unsigned char p_value[], unsigned short data_len)
C51 COMPILER V9.60.0.0   LOCK_API                                                          03/08/2023 18:02:10 PAGE 10  

              {
                  #error "è¯·è‡ªè¡Œå®Œæˆå›¾ç‰‡ä¸Šä¼ ç»“æœåé¦ˆå¤„ç†ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  
                  unsigned short pic_id; //å›¾ç‰‡idå·
                  unsigned char p_time[6]; //å½“å‰å›¾ç‰‡ä¸Šä¼ çš„æ—¶é—´
                  unsigned char upload_result; //å›¾ç‰‡ä¸Šä¼ ç»“æœ
                  
                  if(9 != data_len) {
                      //æ•°æ®é•¿åº¦é”™è¯¯
                      return;
                  }
                  
                  pic_id = (p_value[0] << 8) | p_value[1];
                  my_memcpy(p_time, &p_value[2], 6);
                  upload_result = p_value[8];
                  
                  /*
                  //è¯·è‡ªè¡Œå¤„ç†åé¦ˆç»“æœ
                  //pic_idä¸ºå›¾ç‰‡idå·   
                  //p_time[6]ä¸­æ˜¯å½“å‰å›¾ç‰‡ä¸Šä¼ çš„æ—¶é—´ï¼Œp_time[0]~p_time[5]ä¾æ¬¡æ˜¯ å¹´ æœˆ æ—¥ æ—¶ åˆ† ç§’
                  */
                  switch(upload_result) {
                      case 0:
                          //å›¾ç‰‡ä¸Šä¼ æˆåŠŸ
                      break;
                      
                      case 1:
                          //ç½‘ç»œæ–­å¼€æ— æ³•ä¸Šä¼ æˆåŠŸ
                      break;
                      
                      case 2:
                          //å›¾ç‰‡å¤ªå¤§è¶…å‡º40k
                      break;
                      
                      case 3:
                          //è¶…æ—¶æœªæ”¶åˆ°mcuçš„å›¾ç‰‡ä¿¡æ¯
                      break;
                      
                      case 4:
                          //å…¶å®ƒåŸå› å¤±è´¥
                      break;
                      
                      default:break;
                  }
                  
                  unsigned char length = 0;
                  
                  //è¯·åˆ¤æ–­æ˜¯å¦è¿˜æœ‰åç»­å›¾ç‰‡ä¸Šä¼ ï¼Œé€‰æ‹©å›å¤æ•°æ®
                  
                  length = set_wifi_uart_byte(length, 0); //æ— åç»­å›¾ç‰‡ä¸Šä¼ 
                  //length = set_wifi_uart_byte(length, 1); //æœ‰åç»­å›¾ç‰‡ä¸Šä¼ 
                  
                  wifi_uart_write_frame(PICTURE_UPLOAD_RETURN_CMD,length);
              }
              
              /**
               * @brief  å›¾ç‰‡ä¸Šä¼ çŠ¶æ€è·å–
               * @param  Null
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œè°ƒç”¨åï¼Œå¯åœ¨ picture_upload_state_get_result å‡½æ•°ä¸­å¯¹ç»“æœè¿›è¡Œå¤„ç
             -†
               */
C51 COMPILER V9.60.0.0   LOCK_API                                                          03/08/2023 18:02:10 PAGE 11  

              void picture_upload_state_get(void)
              {
                  wifi_uart_write_frame(PICTURE_UPLOAD_STATE_GET_CMD, 0);
              }
              
              /**
               * @brief  å›¾ç‰‡ä¸Šä¼ çŠ¶æ€è·å–ç»“æœ
               * @param[in] {p_value} ç»“æœæ•°æ®
               * @param[in] {data_len} ç»“æœæ•°æ®é•¿åº¦
               * @return Null
               * @note   MCUéœ€è¦å…ˆè‡ªè¡Œè°ƒç”¨ picture_upload_state_get å‡½æ•°åï¼Œåœ¨æ­¤å‡½æ•°å¯¹æ¥æ”¶çš„ç»“æœè¿›
             -è¡Œå¤„ç†
               */
              void picture_upload_state_get_result(unsigned char p_value[], unsigned short data_len)
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆå›¾ç‰‡ä¸Šä¼ çŠ¶æ€è·å–ç»“æœå¤„ç†ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  unsigned char pic_upload_state; //å›¾ç‰‡ä¸Šä¼ çŠ¶æ€
                  unsigned short event_infor; //äº‹ä»¶ä¿¡æ¯ç¼–ç 
                  unsigned short pic_id; //å›¾ç‰‡idå·
                  unsigned char p_time[6]; //å½“å‰å›¾ç‰‡ä¸Šä¼ çš„æ—¶é—´
                  
                  if(11 != data_len) {
                      //æ•°æ®é•¿åº¦é”™è¯¯
                      return;
                  }
                  
                  pic_upload_state = p_value[0];
                  event_infor = (p_value[1] << 8) | p_value[2];
                  pic_id = (p_value[3] << 8) | p_value[4];
                  my_memcpy(p_time, &p_value[5], 6);
                  
                  //è¯·åœ¨æ­¤å¤„ç†è·å–åˆ°çš„æ•°æ®
                  
              }
              
              #endif
 612          
 613          #ifdef LOCK_KEEP_ALIVE
              /**
               * @brief  ä¿æ´»IOå”¤é†’
               * @param[in] Null
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°é€»è¾‘ä»£ç 
               */
              void keep_alive_awake(void)
              {
                  #error "è¯·åœ¨æ­¤å®Œæˆä¿æ´»IOå”¤é†’æ“ä½œä»£ç ï¼Œä»¥å”¤é†’æ¨¡å—ï¼Œå¹¶åˆ é™¤è¯¥è¡Œ"
                  //æ­¤å‡½æ•°ç”¨äºMCUå”¤é†’æ¨¡å—ï¼Œå”¤é†’æ–¹å¼ä¸ºIOä½ç”µå¹³å”¤é†’ï¼Œå”¤é†’åä¿æŒä½ç”µå¹³ï¼Œå…·ä½
             -“IOè¯·å‚è€ƒç¡¬ä»¶è®¾è®¡ã€‚
                  
              }
              
              /**
               * @brief  è·å–WIFIçŠ¶æ€
               * @param  Null
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œè°ƒç”¨åï¼Œå¯åœ¨ get_wifi_state_result å‡½æ•°ä¸­å¯¹ç»“æœè¿›è¡Œå¤„ç†
               */
              void mcu_get_wifi_state(void)
              {
                  wifi_uart_write_frame(GET_WIFI_STATE_CMD, 0);
              }
C51 COMPILER V9.60.0.0   LOCK_API                                                          03/08/2023 18:02:10 PAGE 12  

              
              /**
               * @brief  mcuæ”¶åˆ°WiFiçŠ¶æ€
               * @param[in] {p_data} æ•°æ®
               * @return Null
               * @note   MCUéœ€è¦å…ˆè‡ªè¡Œè°ƒç”¨ mcu_get_wifi_state å‡½æ•°åï¼Œåœ¨æ­¤å‡½æ•°å¯¹æ¥æ”¶çš„ç»“æœè¿›è¡Œå¤„
             -ç†
               */
              void get_wifi_state_result(const unsigned char p_data[])
              {
                  #error "è¯·è‡ªè¡Œå®ŒæˆwifiçŠ¶æ€å¤„ç†ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  switch(p_data[0]) {
                      case 0x00:
                          //çŠ¶æ€1  smartconfigé…ç½®çŠ¶æ€
                      break;
                      
                      case 0x01:
                          //çŠ¶æ€2  APé…ç½®çŠ¶æ€
                      break;
                      
                      case 0x02:
                          //çŠ¶æ€3  WIFIå·²é…ç½®ä½†æœªè¿ä¸Šè·¯ç”±å™¨
                      break;
                      
                      case 0x03:
                          //çŠ¶æ€4  WIFIå·²é…ç½®ä¸”è¿ä¸Šè·¯ç”±å™¨
                      break;
                      
                      case 0x04:
                          //çŠ¶æ€5  å·²è¿ä¸Šè·¯ç”±å™¨ä¸”è¿æ¥åˆ°äº‘ç«¯
                      break;
                      
                      case 0x05:
                          //çŠ¶æ€6  WIFIè®¾å¤‡å¤„äºä½åŠŸè€—æ¨¡å¼
                      break;
                      
                      case 0xff:
                          //æ— æ•ˆçŠ¶æ€  åˆå§‹åŒ–æœªå®Œæˆ
                      break;
                      
                      default:break;
                  }
                  
                  switch(p_data[1]) {
                      case 0x00:
                          //æœªæ¿€æ´»
                      break;
                      
                      case 0x01:
                          //å·²æ¿€æ´»
                      break;
                      
                      default:break;
                  } 
              }
              #endif
 692          
 693          
 694          #ifdef PHOTO_LOCK_PICTURE_UPLOAD_ENABLE
              /**
               * @brief  MCUå‘é€äº‹ä»¶è§¦å‘æŠ“æ‹é€šçŸ¥
               * @param[in] {event_infor_num} äº‹ä»¶ä¿¡æ¯ç¼–ç 
C51 COMPILER V9.60.0.0   LOCK_API                                                          03/08/2023 18:02:10 PAGE 13  

               * @param[in] {capture_flag} æ˜¯å¦æŠ“æ‹å›¾ç‰‡
               * @param[in] {capture_type} æŠ“æ‹ç±»å‹
               * @param[in] {capture_num} æŠ“æ‹å›¾ç‰‡å¼ æ•°
               * @param[in] {time_flag} æ—¶é—´æ ‡å¿—ä½  0:ä¸å¸¦æ—¶é—´ 1:æœ¬åœ°æ—¶é—´ 2:æ ¼æ—æ—¶é—´
               * @param[in] {p_time} æ—¶é—´æ•°æ®
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œè°ƒç”¨åï¼Œå¯åœ¨ event_trigger_capture_notice_result å‡½æ•°ä¸­å¯¹ç»“æœè¿›è¡Œå
             -¤„ç†
               */
              void mcu_event_trigger_capture_notice(unsigned short event_infor_num, unsigned char capture_flag, unsigned
             - char capture_type,
                                                      unsigned char capture_num, unsigned char time_flag, unsigned char 
             -p_time[])
              {
                  unsigned short send_len = 0;
                  
                  send_len = set_wifi_uart_byte(send_len,EVENT_TRIGGER_CAPTURE_NOTICE_SUBCMD);
                  send_len = set_wifi_uart_byte(send_len,(event_infor_num >> 8) & 0xff);
                  send_len = set_wifi_uart_byte(send_len,event_infor_num & 0xff);
                  send_len = set_wifi_uart_byte(send_len,capture_flag);
                  send_len = set_wifi_uart_byte(send_len,capture_type);
                  send_len = set_wifi_uart_byte(send_len,capture_num);
                  send_len = set_wifi_uart_byte(send_len,time_flag);
                  send_len = set_wifi_uart_buffer(send_len, p_time, 6);
                  
                  wifi_uart_write_frame(PHOTO_LOCK_PICTURE_UPLOAD_CMD, send_len);
              }
              
              
              /**
               * @brief  äº‹ä»¶è§¦å‘æŠ“æ‹é€šçŸ¥æ•°æ®å¤„ç†
               * @param[in] {result} ç»“æœæ•°æ®
               * @return Null
               * @note   MCUéœ€è¦å…ˆè‡ªè¡Œè°ƒç”¨ mcu_event_trigger_capture_notice å‡½æ•°åï¼Œåœ¨æ­¤å‡½æ•°å¯¹æ¥æ”¶çš„ç
             -»“æœè¿›è¡Œå¤„ç†
               */
              static void event_trigger_capture_notice_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆäº‹ä»¶è§¦å‘æŠ“æ‹é€šçŸ¥æ•°æ®å¤„ç†ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  
                  if(0 == result) {
                      //ä¿¡æ¯æ¥æ”¶æˆåŠŸ
                  }else {
                      //ä¿¡æ¯æ¥æ”¶å¤±è´¥
                  }
              }
              
              /**
               * @brief  æ‹ç…§é—¨é”å›¾ç‰‡ä¸Šä¼ ç›¸å…³åŠŸèƒ½
               * @param[in] {p_data} æ•°æ®
               * @return Null
               * @note   
               */
              void photo_lock_picture_upload_func(const unsigned char p_data[])
              {
                  event_trigger_capture_notice_result(p_data[0]); //äº‹ä»¶è§¦å‘æŠ“æ‹é€šçŸ¥
              }
              #endif
 752          
 753          #endif
 754          

C51 COMPILER V9.60.0.0   LOCK_API                                                          03/08/2023 18:02:10 PAGE 14  


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    904    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      72
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  18 WARNING(S),  0 ERROR(S)

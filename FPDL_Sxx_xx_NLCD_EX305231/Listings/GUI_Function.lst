C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      05/23/2023 14:43:20 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE GUI_FUNCTION
OBJECT MODULE PLACED IN .\Objects\GUI_Function.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Softwares\Application\GUI_Function.c LARGE OMF2 OPTIMIZE(9,SPEED) BROWSE
                    - INCDIR(.\Drivers\Lib\c;.\Drivers\Lib\H;.\Drivers\Lib\IAP_Lib;.\Drivers\Lib\TouchKey_lib;.\Drivers\Physical;.\Drivers\Pr
                    -otocol;.\Softwares\Application;.\Softwares\Basic;.\Softwares\ModuleLogic;.\Drivers\Protocol\YC_NFC;.\Drivers\Protocol\WI
                    -FI_Tuya) DEBUG PRINT(.\Listings\GUI_Function.lst) TABS(2) OBJECT(.\Objects\GUI_Function.obj)

line level    source

   1          #include "gpio.h"
   2          //Protocol layer
   3          #include "MFC_MF17622.h"
   4          #include "EEPROM.h"
   5          #include "BeepMgr.h"
   6          #include "TuyaWIFI.h"
   7          #include "FingerPrint.h"
   8          //Logic layer
   9          #include "AppUnlock.h"
  10          #include "Motor.h"
  11          #include "FP.h"
  12          #include "LCD.h"
  13          #include "MFC.h"
  14          //Application layer
  15          #include "GUI_Function.h"
  16          #include "global_variable.h"
  17          #include "Font.h"
  18          #include "Voice_Menu.h"
  19          #include "Font_Menu.h"
  20          
  21          
  22          extern screen_t CurrentScreen;
  23          extern DataInputMgr_t DataInputMgr;
  24          extern VoiceMenuMgr_t VoiceMenuMgr;
  25          extern PasscodeInputMgr_t PasscodeInputMgr;
  26          extern uint8_t LEDsCtrlSwitch;
  27          extern uint8_t GUI_ToggleFlag_05s;
  28          extern keycode_t gui_keycode;
  29          
  30          
  31          
  32          void GoToMainMenu(void)//进入主菜单
  33          {
  34   1        VoiceMenuMgr.MenuPoint=0;
  35   1        #ifdef Function_TuyaWifi
                VoiceMenuMgr.TotalMenuNum = 6;
                #else
  38   1        VoiceMenuMgr.TotalMenuNum = 5;
  39   1        #endif
  40   1        CurrentScreen = SCREEN_MainMenu;
  41   1      }
  42          
  43          void GoToFpMenu(void)//进入指纹菜单
  44          {
  45   1        VoiceMenuMgr.MenuPoint=0;
  46   1        #ifdef Function_Enable_ID_Del
  47   1        VoiceMenuMgr.TotalMenuNum = 5;
  48   1        #else
                VoiceMenuMgr.TotalMenuNum = 4;
                #endif
  51   1        CurrentScreen = SCREEN_FpMenu;
  52   1      }
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      05/23/2023 14:43:20 PAGE 2   

  53          void GoToPasswordMenu(void)//进入密码菜单
  54          {
  55   1        VoiceMenuMgr.MenuPoint=0;
  56   1        #ifdef Function_Enable_ID_Del
  57   1        VoiceMenuMgr.TotalMenuNum = 5;
  58   1        #else
                VoiceMenuMgr.TotalMenuNum = 4;
                #endif
  61   1        CurrentScreen = SCREEN_PasscodeMenu;
  62   1      }
  63          void GoToCardMenu(void)//进入卡片菜单
  64          {
  65   1        VoiceMenuMgr.MenuPoint=0;
  66   1        #ifdef Function_Enable_ID_Del
  67   1        VoiceMenuMgr.TotalMenuNum = 4;
  68   1        #else
                VoiceMenuMgr.TotalMenuNum = 3;
                #endif
  71   1        CurrentScreen = SCREEN_CardUserMenu;
  72   1      }
  73          void GoToSystemConfigMenu(void)//进入系统设置菜单
  74          {
  75   1        VoiceMenuMgr.MenuPoint=0;
  76   1        #ifdef Function_VoiceEnabledEnglish
                VoiceMenuMgr.TotalMenuNum = 7;
                #else
  79   1        VoiceMenuMgr.TotalMenuNum = 6;
  80   1        #endif
  81   1        CurrentScreen = SCREEN_SystemConfigMenu;
  82   1      }
  83          void GoToSystemVersion(void)//进入系统版本号菜单
  84          {
  85   1        VoiceMenuMgr.MenuPoint=0;
  86   1        VoiceMenuMgr.TotalMenuNum = 2;
  87   1        CurrentScreen = SCREEN_SystemVersion;
  88   1      }
  89          
  90          void GotoLogMenu(void)//进入日志菜单
  91          {
  92   1        VoiceMenuMgr.MenuPoint=0;
  93   1        VoiceMenuMgr.TotalMenuNum = 3;
  94   1        CurrentScreen = SCREEN_EventLogMenu;
  95   1      }
  96          
  97          bool_t IfSystemIsInFactoryDefaultStatus(void)//如果系统处于出厂默认状态
  98          {
  99   1        if ( ( CheckMemoryMgr.FpUserNum == 0x00 )
 100   1            &&(CheckMemoryMgr.FpMasterNum == 0x00 )
 101   1            &&(CheckMemoryMgr.CardUserNum == 0x00 )
 102   1            &&(CheckMemoryMgr.PasscodeMasterNum == 0x00 )
 103   1            &&(CheckMemoryMgr.PasscodeUserNum == 0x00 ) )
 104   1        {
 105   2          return bTRUE;
 106   2        }
 107   1        else
 108   1        {
 109   2          return bFALSE;
 110   2        }
 111   1      }
 112          
 113          bool_t IfSystemWithoutSecondIdentity(void)//如果系统没有第二身份
 114          {
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      05/23/2023 14:43:20 PAGE 3   

 115   1        if  ( (((CheckMemoryMgr.FpUserNum+CheckMemoryMgr.FpMasterNum) == 0x00 )&&((CheckMemoryMgr.PasscodeMasterN
             -um + CheckMemoryMgr.PasscodeUserNum)== 0x00))
 116   1          ||(((CheckMemoryMgr.FpUserNum+CheckMemoryMgr.FpMasterNum) == 0x00 )&&(CheckMemoryMgr.CardUserNum == 0x00
             - ))
 117   1          ||(((CheckMemoryMgr.PasscodeMasterNum + CheckMemoryMgr.PasscodeUserNum)== 0x00)&&(CheckMemoryMgr.CardUse
             -rNum == 0x00 ))
 118   1          )
 119   1        {
 120   2          return bTRUE;
 121   2        }
 122   1        else
 123   1        {
 124   2          return bFALSE;
 125   2        }
 126   1      }
 127          
 128          bool_t CompareTwoArrayIsSame(uint8_t Point1[],uint8_t Point2[],uint8_t Lenth)//比较两个数组是否相同
 129          {
 130   1        uint8_t i;
 131   1        for (i=0;i<Lenth;i++)
 132   1        {
 133   2          if (Point1[i]!=Point2[i]){
 134   3            return bFALSE;
 135   3          }
 136   2        }
 137   1        return bTRUE;
 138   1      }
 139          
 140          void UnlockModeJudgment(void)//开锁模式有效性判断
 141          {
 142   1        if  ( IfSystemWithoutSecondIdentity() == bTRUE )
 143   1        {
 144   2          UserIdentifyResultMgr.UnlockingMode = SingalMode;
 145   2          EEPROM_WriteSequential(UnlockModeStartAddr,&UserIdentifyResultMgr.UnlockingMode,1);
 146   2        }
 147   1      }
 148          
 149          bool_t is_valid_date(uint8_t year, uint8_t month, uint8_t date)//判断是不是有效日期
 150          {
 151   1          uint8_t monttbuffer[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
 152   1          uint16_t y;
 153   1          uint8_t m,d;
 154   1          y=((year/16)*10)+(year%16)+2000;
 155   1          m = ((month/16)*10)+(month%16);
 156   1          d = ((date/16)*10) + (date%16);
 157   1              if (((y % 4 == 0) && (y % 100 != 0)) 
 158   1            || (y % 400 == 0)
 159   1            )
 160   1              {
 161   2                      monttbuffer[1] = 29; 
 162   2          }
 163   1              if ( (m > 0) 
 164   1            && (m < 13)
 165   1            && (d > 0) 
 166   1            && (d <= monttbuffer[m - 1])
 167   1            )
 168   1              {
 169   2            return bTRUE;
 170   2          }
 171   1          else{
 172   2            return bFALSE;
 173   2          }
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      05/23/2023 14:43:20 PAGE 4   

 174   1      }
 175          
 176          void Config_AntiPrying_Interrupt(void)//设置防撬
 177          {
 178   1        if (PickAlarmEnableMgr.Enable == bTRUE)
 179   1        {
 180   2          EnableAntiPrying_Interrupt();
 181   2        }
 182   1        else{
 183   2          DisableAntiPrying_Interrupt();
 184   2        }
 185   1      }
 186          
 187          void UnlockSuccess(uint8_t UnlockType)//开锁成功
 188          {
 189   1        UserIdentifyResultMgr.IdentifyType = UnlockType;
 190   1        GUI_SetMotorToOpenAndCloseDoor();
 191   1        //Enable_KEYLED_WATERLIGHT(); 
 192   1        CurrentScreen = SCREEN_IdentifySuccess;
 193   1        UserIdentifyResultMgr.TimeCnt = Def_MessageBoxTimeDelay;
 194   1      }
 195          
 196          void RefreshSystemSleepTime(void)//更新系统休眠时间
 197          {
 198   1        if ( ( CurrentScreen == SCREEN_Main )
 199   1           ||( CurrentScreen ==SCREEN_Initialization)
 200   1           ||( CurrentScreen ==SCREEN_LowBattery )
 201   1          )
 202   1        {
 203   2          SystemPowerMgr.SleepDelayTimerCnt = DEF_SystemSleepDelayTime_MainScreen;
 204   2        }
 205   1        else
 206   1        {
 207   2          SystemPowerMgr.SleepDelayTimerCnt = DEF_SystemSleepDelayTime_MenuScreen;
 208   2        }
 209   1      }
 210          
 211          void SystemConfigSave(void)//系统设置保存
 212          {
 213   1        #ifdef Function_VoiceEnabledEnglish
                  EEPROM_WriteSequential(SystemLanguageStartAddr, (uint8_t*)&SystemLanguage, 1);
                #endif
 216   1          EEPROM_WriteSequential(UnlockModeStartAddr, (uint8_t*)&UserIdentifyResultMgr.UnlockingMode, 1);
 217   1          EEPROM_WriteSequential(VolumeSwitchStartAddr, (uint8_t*)&VoiceMgr.Enable, 1);
 218   1          EEPROM_WriteSequential(PickAlarmSwitchStartAddr, (uint8_t*)&PickAlarmEnableMgr.Enable, 1);
 219   1      }
 220          
 221          void SystemConfigLoad(void)//系统设置加载
 222          {
 223   1        uint8_t temp;
 224   1        bool_t temp_BOOL;
 225   1        #ifdef Function_VoiceEnabledEnglish
                EEPROM_ReadSequential(SystemLanguageStartAddr,&temp,1);
                if (temp == Chinese)
                {
                  SystemLanguage = Chinese;
                }
                else
                {
                  SystemLanguage = English;
                }
                #else
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      05/23/2023 14:43:20 PAGE 5   

 236   1        SystemLanguage = Chinese;
 237   1        #endif
 238   1        EEPROM_ReadSequential(UnlockModeStartAddr,&temp,1);
 239   1        if (temp == DoubleMode)
 240   1        {
 241   2          UserIdentifyResultMgr.UnlockingMode = DoubleMode;
 242   2        }
 243   1        else
 244   1        {
 245   2          UserIdentifyResultMgr.UnlockingMode = SingalMode;
 246   2        }
 247   1        
 248   1        EEPROM_ReadSequential(VolumeSwitchStartAddr,(uint8_t*)&temp_BOOL,1);
 249   1      
 250   1        if (temp_BOOL == bFALSE)
 251   1        {
 252   2            VoiceMgr.Enable = bFALSE;
 253   2        }
 254   1        else
 255   1        {
 256   2            VoiceMgr.Enable = bTRUE;
 257   2        }
 258   1        
 259   1        EEPROM_ReadSequential(PickAlarmSwitchStartAddr,(uint8_t*)&temp_BOOL,1);
 260   1          
 261   1        #ifdef Function_AntiPryingDefaultDisabled
 262   1        if (temp_BOOL == bTRUE)
 263   1        {
 264   2            PickAlarmEnableMgr.Enable = bTRUE;
 265   2        }
 266   1        else
 267   1        {
 268   2            PickAlarmEnableMgr.Enable = bFALSE;
 269   2        }
 270   1        #else
                if (temp_BOOL == bFALSE)
                {
                    PickAlarmEnableMgr.Enable = bFALSE;
                }
                else
                {
                    PickAlarmEnableMgr.Enable = bTRUE;
                }
                #endif
 280   1          
 281   1        Config_AntiPrying_Interrupt();
 282   1        
 283   1      }
 284          
 285          /****************************************************************/
 286          void ReadLockBrand(void)//读取锁品牌
 287          {
 288   1        uint8_t temp;
 289   1        
 290   1        EEPROM_ReadSequential(LockBrandStartAddr,&temp,1);
 291   1        if ( temp == 0x55 )
 292   1        {
 293   2          EEPROM_ReadSequential(LockBrandStartAddr+1,&LockBrand.LockBrandDisDataBuff[0],224);
 294   2          LockBrand.LockBrandDataValid = bTRUE;
 295   2        }
 296   1        else{
 297   2          LockBrand.LockBrandDataValid = bFALSE;
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      05/23/2023 14:43:20 PAGE 6   

 298   2        } 
 299   1      }
 300          
 301          void WriteLockBrand(void)//写入锁品牌
 302          { 
 303   1        #ifdef Function_ScreenDisplay
                uint8_t temp;
                temp = 0x55;
                LockBrand.GotBrandData = bFALSE;
                if ( MFC_ReadLockBrandData(&LockBrand.LockBrandDisDataBuff[0]) == S_SUCCESS )
                {
                  EEPROM_WriteSequential(LockBrandStartAddr,&temp,1);
                  
              //    if ( LockBrand.BrandType == SmallBrand )
              //    {
                    EEPROM_WriteSequential(LockBrandStartAddr+1,&LockBrand.LockBrandDisDataBuff[0],224);
              //    }
              //    else if ( LockBrand.BrandType == BigBrand )
              //    {
              //      EEPROM_WriteSequential(LockBrandStartAddr+1,&LockBrand.LockBrandDisDataBuff[0],512);
              //    }
                  LockBrand.GotBrandData = bTRUE;
                  LockBrand.LockBrandDataValid = bTRUE;
                }
                #endif
 323   1      }
 324          
 325          void SystemConfigReset(void)//系统设置恢复出厂
 326          {
 327   1        UserIdentifyResultMgr.UnlockingMode = SingalMode;
 328   1        VoiceMgr.Enable = bTRUE;
 329   1        
 330   1        #ifdef Function_AntiPryingDefaultDisabled
 331   1          PickAlarmEnableMgr.Enable = bFALSE;
 332   1        #else
                  PickAlarmEnableMgr.Enable = bTRUE;
                #endif
 335   1        
 336   1        Config_AntiPrying_Interrupt();
 337   1      
 338   1        SystemConfigSave();
 339   1      }
 340          
 341          //ID输入效果显示生成
 342          void GUI_DataInputCreat(uint8_t StartPage,uint8_t StartColumn,uint8_t InputNum,uint16_t DefaultValue)
 343          {
 344   1        #ifdef Function_ScreenDisplay
                uint8_t temp,i;
                #endif
 347   1        uint16_t value;
 348   1      
 349   1        if( DataInputMgr.Status == InputIdle )
 350   1        {
 351   2          DataInputMgr.Status = InputStart;
 352   2          DataInputMgr.Value = DefaultValue;
 353   2          DataInputMgr.InputNum = InputNum;
 354   2      
 355   2          if ( DefaultValue == 0x0000 ){
 356   3            DataInputMgr.InputPoint = 0;
 357   3          }
 358   2          else{
 359   3            DataInputMgr.InputPoint = InputNum;
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      05/23/2023 14:43:20 PAGE 7   

 360   3          }
 361   2        }
 362   1          
 363   1        else if ( DataInputMgr.Status == InputStart )
 364   1        {
 365   2          if (DataInputMgr.InputPoint > DataInputMgr.InputNum ){
 366   3            return;
 367   3          }
 368   2      
 369   2          value = DataInputMgr.Value;
 370   2          #ifdef Function_ScreenDisplay
                  for (i=0;i<DataInputMgr.InputPoint;i++)
                  { 
                    temp = value%10;
                    DisOneDigital16x8(StartPage,StartColumn+(8*(DataInputMgr.InputPoint-i-1)),temp,NormalDisplay);
                    value/=10;
                  }
              
                  for (i=DataInputMgr.InputPoint;i<(DataInputMgr.InputNum+1);i++)   //"+1" for clear underline
                  {
                    DisZF16x8(StartPage,StartColumn+(8*i),ZF_kongge,NormalDisplay);
                  }
                  
                  if ( GUI_ToggleFlag_05s == 1 )
                  {
                    DisZF16x8(StartPage,StartColumn+(8*DataInputMgr.InputPoint),ZF_kongge,NormalDisplay);
                  }
                  else{
                    DisZF16x8(StartPage,StartColumn+(8*DataInputMgr.InputPoint),ZF_underline,NormalDisplay);
                  }
                  #else
 391   2          StartPage = 0; StartColumn = 0;//无意义，注掉不影响，会报warming
 392   2          #endif
 393   2        }
 394   1      
 395   1      }
 396          
 397          
 398          void GUI_UserIDinputButtonMonitor(keycode_t keycode)//GUI_用户ID输入按钮监视器
 399          {
 400   1        if ( (keycode < KEY_NINE)||(keycode == KEY_NINE) )
 401   1        {
 402   2          DEF_ButtonPress_Voice;
 403   2          PasscodeUserRegisterMgr.OverTimeCnt = Def_GuiTimeDelayCnt5s;
 404   2          if ( DataInputMgr.InputPoint < DataInputMgr.InputNum )
 405   2          {
 406   3            DataInputMgr.Value = DataInputMgr.Value*10+gui_keycode;
 407   3            DataInputMgr.InputPoint++;
 408   3          }
 409   2        }
 410   1        else if ( keycode == KEY_ASTERISK )
 411   1        {
 412   2          DEF_ButtonPress_Voice;
 413   2          PasscodeUserRegisterMgr.OverTimeCnt = Def_GuiTimeDelayCnt5s;
 414   2          if ( DataInputMgr.InputPoint > 0 )
 415   2          {
 416   3            DataInputMgr.InputPoint--;
 417   3            DataInputMgr.Value/=10;
 418   3          }
 419   2          else
 420   2          {
 421   3            DataInputMgr.Status = InputExit;
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      05/23/2023 14:43:20 PAGE 8   

 422   3          }
 423   2        }
 424   1        else if ( keycode == KEY_POUNDSIGN )
 425   1        {
 426   2          //DEF_ButtonPress_Voice;
 427   2          PasscodeUserRegisterMgr.OverTimeCnt = Def_GuiTimeDelayCnt5s;
 428   2          if ( DataInputMgr.InputPoint == 0 )
 429   2          {
 430   3            DataInputMgr.Status = InputExit;
 431   3          }
 432   2          else
 433   2          {
 434   3            DataInputMgr.Status = InputEnd;
 435   3          }
 436   2        }
 437   1      }
 438          
 439          void GUI_PasscodeInputCreat(uint8_t StartPage,uint8_t StartColumn)//GUI密码输入显示效果生成
 440          {
 441   1        uint8_t i=0;
 442   1        StartColumn=0;//无意义，注掉不影响，会报warming
 443   1        if (PasscodeInputMgr.Point > 16)
 444   1        {
 445   2          return;
 446   2        }
 447   1        #ifdef Function_ScreenDisplay
                Clear_Screen_Page(StartPage);
                Clear_Screen_Page(StartPage+1);
                for (i=0;i<PasscodeInputMgr.Point;i++)
                {
                  DisZF16x8(StartPage,(8*i)+(64-(PasscodeInputMgr.Point*4)),ZF_xinghao,NormalDisplay);
                }
                #else
 455   1        StartPage=0;//无意义，注掉不影响，会报warming
 456   1        #endif
 457   1      }
 458          
 459          void GUI_PasscodeInputButtonMonitor(keycode_t keycode)//GUI按键密码输入监视器
 460          {
 461   1        if ( (keycode < KEY_NINE)||(keycode == KEY_NINE) )//0-9
 462   1        {
 463   2          PasscodeUserRegisterMgr.OverTimeCnt = Def_GuiTimeDelayCnt5s;
 464   2          if ( CurrentScreen != SCREEN_PickLockAlarm ){
 465   3            DEF_ButtonPress_Voice;
 466   3          }
 467   2          if ( PasscodeInputMgr.Point <  PasscodeInputMgr.PasscodeLen )
 468   2          {
 469   3            PasscodeInputMgr.InputBuff[PasscodeInputMgr.Point] = gui_keycode;
 470   3            PasscodeInputMgr.Point++;
 471   3          }
 472   2        }
 473   1        else if ( keycode == KEY_ASTERISK )
 474   1        {
 475   2          PasscodeUserRegisterMgr.OverTimeCnt = Def_GuiTimeDelayCnt5s;
 476   2          if ( CurrentScreen != SCREEN_PickLockAlarm && CurrentScreen != SCREEN_ManagerIdentify){
 477   3            DEF_ButtonPress_Voice;
 478   3          }
 479   2          
 480   2          if ( PasscodeInputMgr.Point > 0 )
 481   2          {
 482   3            PasscodeInputMgr.Status = PasscodeInputExit;  
 483   3          }
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      05/23/2023 14:43:20 PAGE 9   

 484   2          else
 485   2          {
 486   3            PasscodeInputMgr.Status = PasscodeInputExit;
 487   3          }
 488   2        }
 489   1        else if ( keycode == KEY_POUNDSIGN )
 490   1        {
 491   2          PasscodeUserRegisterMgr.OverTimeCnt = Def_GuiTimeDelayCnt5s;
 492   2          if ( CurrentScreen != SCREEN_PickLockAlarm ){
 493   3            DEF_ButtonPress_Voice;
 494   3          }
 495   2          if ( PasscodeInputMgr.Point == 0 )
 496   2          {
 497   3            PasscodeInputMgr.Status = PasscodeInputExit;
 498   3          }
 499   2          else
 500   2          {
 501   3            PasscodeInputMgr.Status = PasscodeInputEnd;
 502   3          }
 503   2        }
 504   1      }
 505          
 506          void PasscodeUserIdentify(void)//密码用户认证
 507          {
 508   1        if ( PasscodeUserIdentifyMgr.Status != PasscodeIdentifyIdle )
 509   1        {
 510   2          if (PasscodeUserIdentifyMgr.Status == PasscodeIdentifyStart )
 511   2          {
 512   3            //PasscodeUserIdentifyMgr.TimeCnt = 240;
 513   3            PasscodeUserIdentifyMgr.Status = PasscodeIdentifyPasscodeInput;
 514   3          }
 515   2          else if (PasscodeUserIdentifyMgr.Status == PasscodeIdentifyPasscodeInput)
 516   2          {
 517   3            #ifdef Function_ScreenDisplay
                    Clear_Screen_Page(3);
                    Clear_Screen_Page(6);
                    Clear_Screen_Page(7);
                    GUI_PasscodeInputCreat(4,0);
                    #endif
 523   3            if (PasscodeInputMgr.Status == PasscodeInputEnd)
 524   3            {
 525   4              if ( IfSystemIsInFactoryDefaultStatus()==bTRUE )
 526   4              {
 527   5                if( (PasscodeInputMgr.InputBuff[0]==0x01)
 528   5                  &&(PasscodeInputMgr.InputBuff[1]==0x01)
 529   5                  &&(PasscodeInputMgr.InputBuff[2]==0x01)
 530   5                  &&(PasscodeInputMgr.InputBuff[3]==0x01)
 531   5                  &&(PasscodeInputMgr.InputBuff[4]==0x01)
 532   5                  &&(PasscodeInputMgr.InputBuff[5]==0x01)
 533   5                  &&(PasscodeInputMgr.InputBuff[6]==0x01)
 534   5                  &&(PasscodeInputMgr.InputBuff[8]==0x01)
 535   5                  &&(PasscodeInputMgr.InputBuff[9]==0x01)
 536   5                  )
 537   5                {
 538   6                  PasscodeUserIdentifyMgr.Status = PasscodeIdentifyAgingTestSuccess;
 539   6                }
 540   5                else if ((PasscodeInputMgr.InputBuff[0]==0x01)
 541   5                    &&(PasscodeInputMgr.InputBuff[1]==0x03)
 542   5                    &&(PasscodeInputMgr.InputBuff[2]==0x05)
 543   5                    &&(PasscodeInputMgr.InputBuff[3]==0x07)
 544   5                    &&(PasscodeInputMgr.Point == 4)
 545   5                    )
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      05/23/2023 14:43:20 PAGE 10  

 546   5                {
 547   6                  PasscodeUserIdentifyMgr.Status = PasscodeIdentifyCheckVersionSuccess;
 548   6                }
 549   5                else
 550   5                {
 551   6                  PasscodeUserIdentifyMgr.Status = PasscodeIdentifyFail;
 552   6                }
 553   5              }
 554   4              else
 555   4              {
 556   5                PasscodeUserIdentifyMgr.UserID = PasscodeIdendify(PasscodeInputMgr.InputBuff);
 557   5                if ( PasscodeUserIdentifyMgr.UserID != 0x00 )//Identify success
 558   5                {
 559   6                  PasscodeUserIdentifyMgr.Status = PasscodeIdentifySuccess;
 560   6                  //PasscodeUserIdentifyMgr.TimeCnt =Def_IdendtifySuccessScreenTimeDelay;
 561   6                  UserIdentifyResultMgr.PasscodeType = LocalPasscode;
 562   6                  //GUI_Flag_RefreshLCD = bTRUE;
 563   6                }
 564   5                else
 565   5                {
 566   6                  if ( PasscodeInputMgr.Point == 10 )
 567   6                  {
 568   7                    PasscodeUserIdentifyMgr.Status = PasscodeIdentifyFail;
 569   7                    //PasscodeUserIdentifyMgr.TimeCnt =Def_IdendtifyFailScreenTimeDelay;
 570   7                    #ifdef Function_TuyaWifi
                            WifiMgr.PostMgr.Flag.Bits.RequestGreenTime = 1;
                            PasscodeUserIdentifyMgr.Status = PasscodeIdentifyIdle;
                            #endif
 574   7                  }
 575   6                  else if ((PasscodeInputMgr.Point == 12)||( PasscodeInputMgr.Point == 13 ))
 576   6                  {
 577   7                    #ifdef Function_AppUnlock
 578   7                    PasscodeUserIdentifyMgr.UserID = AppPasscodeIdentify(PasscodeInputMgr.InputBuff,PasscodeInputMgr.P
             -oint);
 579   7                    if ( PasscodeUserIdentifyMgr.UserID != 0x00 )//App unlock success
 580   7                    {
 581   8                      PasscodeUserIdentifyMgr.Status = PasscodeIdentifySuccess;
 582   8                      //PasscodeUserIdentifyMgr.TimeCnt =Def_IdendtifySuccessScreenTimeDelay;
 583   8                      UserIdentifyResultMgr.PasscodeType = AppPasscode;
 584   8                      //GUI_Flag_RefreshLCD = bTRUE;
 585   8                    }
 586   7                    else
 587   7                    #endif
 588   7                    {
 589   8                      PasscodeUserIdentifyMgr.Status = PasscodeIdentifyFail;
 590   8                      //PasscodeUserIdentifyMgr.TimeCnt =Def_IdendtifyFailScreenTimeDelay;
 591   8                      //GUI_Flag_RefreshLCD = bTRUE;
 592   8                    }
 593   7                  }
 594   6                  else
 595   6                  {
 596   7                    PasscodeUserIdentifyMgr.Status = PasscodeIdentifyFail;
 597   7                    //PasscodeUserIdentifyMgr.TimeCnt =Def_IdendtifyFailScreenTimeDelay;
 598   7                    //GUI_Flag_RefreshLCD = bTRUE;
 599   7                  }
 600   6                }
 601   5              }
 602   4            }
 603   3            else if (PasscodeInputMgr.Status == PasscodeInputExit)
 604   3            {
 605   4              PasscodeUserIdentifyMgr.Status = PasscodeIdentifyIdle;
 606   4              PasscodeUserRegisterMgr.TimeCnt = 0;  
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      05/23/2023 14:43:20 PAGE 11  

 607   4              //GUI_Flag_RefreshLCD = bTRUE;
 608   4            }
 609   3          }
 610   2        }
 611   1      }
 612          
 613          uint8_t PasscodeIdendify(uint8_t *BUFF1)//密码验证
 614          {
 615   1          uint8_t i,k;
 616   1        int j;
 617   1        uint8_t PasscodeLen;
 618   1        for (i=0;i<(DEF_MAX_PASSCODEMASTER+DEF_MAX_PASSCODEUSER);i++)
 619   1        {
 620   2          if ( PasscodeMemoryMgr[i].Status != PasscodeIsValid ){
 621   3            continue;
 622   3          }
 623   2      
 624   2          PasscodeLen = 0;
 625   2          for (j=11;j>=0;j--)
 626   2          {
 627   3            if(j%2==1)
 628   3            {
 629   4              if ( (PasscodeMemoryMgr[i].PasscodeBuff[j/2]&0xf) != 0xF )
 630   4              {
 631   5                PasscodeLen = j+1;
 632   5                break;
 633   5              }
 634   4            }
 635   3            else
 636   3            {
 637   4              if ( ((PasscodeMemoryMgr[i].PasscodeBuff[j/2]>>4)&0xf) != 0xF )
 638   4              {
 639   5                PasscodeLen = j+1;
 640   5                break;
 641   5              }
 642   4            }
 643   3          }
 644   2          
 645   2          for (j=0;j<(16-PasscodeLen+1);j++)
 646   2          {
 647   3            for (k=0;k<PasscodeLen;k++)
 648   3            {
 649   4              if(k%2==1)
 650   4              {
 651   5                if (((PasscodeMemoryMgr[i].PasscodeBuff[k/2]&0xf) != *(BUFF1+k+j)))
 652   5                {
 653   6                  break;
 654   6                }
 655   5              }
 656   4                else
 657   4              {
 658   5                if ((((PasscodeMemoryMgr[i].PasscodeBuff[k/2]>>4)&0xf) != *(BUFF1+k+j)))
 659   5                {
 660   6                  break;
 661   6                }
 662   5              }
 663   4            }
 664   3            if (k == PasscodeLen){
 665   4              return PasscodeMemoryMgr[i].UserID;
 666   4            }
 667   3          }
 668   2        }
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      05/23/2023 14:43:20 PAGE 12  

 669   1        return 0;
 670   1      }
 671          
 672          uint8_t AppPasscodeIdentify(uint8_t BUFF[],unsigned int pwd_len )//APP密码识别
 673          {
 674   1        uint8_t i,j;
 675   1        uint8_t UserPasscodeLen;
 676   1        uint8_t temp[12];
 677   1        unsigned int mode=0,result=0;
 678   1        
 679   1        ReadPasscodeUserMemoryFromEEPROM();
 680   1             //ReadPasscodeMaster02MemoryFromEEPROM();
 681   1      
 682   1        for (i=0;i<DEF_MAX_PASSCODEMASTER;i++)
 683   1        {
 684   2          UserPasscodeLen = 0;
 685   2          for(j=0;j<6;j++)
 686   2          {
 687   3            temp[2*j]=PasscodeMemoryMgr[i].PasscodeBuff[j]>>4;
 688   3            temp[2*j+1]=PasscodeMemoryMgr[i].PasscodeBuff[j]&0x0f;
 689   3          }
 690   2          for (j=0;j<pwd_len;j++)
 691   2          {
 692   3            if ( temp[j] < 10)
 693   3            {
 694   4              UserPasscodeLen++;
 695   4            }
 696   3            else
 697   3            {
 698   4              break;
 699   4            }
 700   3          }
 701   2          if(pwd_decrypt(temp,i,UserPasscodeLen,BUFF,pwd_len,&mode,&result)>0)             
 702   2          {
 703   3            return i+1;
 704   3          }
 705   2          
 706   2        }
 707   1        return 0;
 708   1      }
 709          
 710          void ShowLockBrand(void)//显示锁品牌
 711          {
 712   1        #ifdef Function_ScreenDisplay
                code uint8_t Welcome_Str[8]={HZ_huan,HZ_yingjie,HZ_shiyong,HZ_yong,HZ_zhineng,HZ_neng,HZ_suomen,HZ_end};
              
                if ( LockBrand.LockBrandDataValid == bTRUE )
                {
                  DisImage_RAM(6,8,112,16,&LockBrand.LockBrandDisDataBuff[0],NormalDisplay);
                }
                else if( LockBrand.LockBrandDataValid == bFALSE )
                {
                  DisHZ16x14Str(6,16,Welcome_Str,NormalDisplay);
                }
                #endif
 724   1      }
 725          
 726          void GUI_Update_Version(void)//更新版本号
 727          {
 728   1        #ifdef Function_ScreenDisplay
                 code uint8_t SystemVersionStr[]={HZ_xi,HZ_tong,HZ_ban,HZ_ben,HZ_end};
                //code uint8_t FPM_Version[]={"FPM:126"};
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      05/23/2023 14:43:20 PAGE 13  

                uint8_t ModelStr[]={"Sxxx-xxx"};
                uint8_t VersionStr[]={"100.100"};
                #endif
 734   1      
 735   1        if ( VoiceDataTransferMgr.VoicePlayEnd == bTRUE )
 736   1        {
 737   2          if (VoiceMenuMgr.MenuPoint < VoiceMenuMgr.TotalMenuNum )
 738   2          {
 739   3            PLAY_VOICE_MULTISEGMENTS(SystemVersionVoiceBuff[VoiceMenuMgr.MenuPoint]);
 740   3            VoiceMenuMgr.MenuPoint++;
 741   3          }
 742   2        }
 743   1        
 744   1        #ifdef Function_ScreenDisplay
                DisHZ16x14Str(0,32,SystemVersionStr,NormalDisplay);
                ModelStr[1]=DEF_CustomerNumber/100+0x30;
                ModelStr[2]=DEF_CustomerNumber%100/10+0x30;
                ModelStr[3]=DEF_CustomerNumber%10+0x30;
                ModelStr[5]=DEF_ModelNumber/100+0x30;
                ModelStr[6]=DEF_ModelNumber%100/10+0x30;
                ModelStr[7]=DEF_ModelNumber%10+0x30;  
                DisEN16x8Str(3,20,ModelStr,NormalDisplay);
                //Main Board Hardware Version
                VersionStr[0]=DEF_HardwareVerion/100+0x30;
                VersionStr[1]=DEF_HardwareVerion%100/10+0x30;
                VersionStr[2]=DEF_HardwareVerion%10+0x30;
                //Main Board Firmware Version
                VersionStr[4]=DEF_FirmwareVerion/100+0x30;
                VersionStr[5]=DEF_FirmwareVerion%100/10+0x30;
                VersionStr[6]=DEF_FirmwareVerion%10+0x30;
              
                DisEN16x8Str(5,20,VersionStr,NormalDisplay);
                #endif
 764   1      }
 765          
 766          void ReadPasscodeUserMemoryFromEEPROM(void)//从EEPROM内存读取密码用户
 767          {
 768   1        EEPROM_ReadSequential(PasscodeUserMemoryStartAddr,&PasscodeMemoryMgr[0].UserID,(8*(DEF_MAX_PASSCODEUSER+D
             -EF_MAX_PASSCODEMASTER)));
 769   1      }
 770          
 771          void WritePasscodeUserMemoryToEEPROM(void)//从EEPROM内存写入密码用户
 772          {
 773   1        EEPROM_WriteSequential(PasscodeUserMemoryStartAddr,&PasscodeMemoryMgr[0].UserID,(8*(DEF_MAX_PASSCODEUSER+
             -DEF_MAX_PASSCODEMASTER)));
 774   1      }
 775          
 776          bool_t GUI_CompareTwoPasscodes(uint8_t *BUFF1,uint8_t *BUFF2)//比较两个密码是否相等
 777          {
 778   1        if (  ( *BUFF1 == *BUFF2)
 779   1          &&(*(BUFF1+1) == *(BUFF2+1))
 780   1          &&(*(BUFF1+2) == *(BUFF2+2))
 781   1          &&(*(BUFF1+3) == *(BUFF2+3))
 782   1          &&(*(BUFF1+4) == *(BUFF2+4))
 783   1          &&(*(BUFF1+5) == *(BUFF2+5))
 784   1          &&(*(BUFF1+6) == *(BUFF2+6))
 785   1          &&(*(BUFF1+7) == *(BUFF2+7))
 786   1          &&(*(BUFF1+8) == *(BUFF2+8))
 787   1          &&(*(BUFF1+9) == *(BUFF2+9))
 788   1          &&(*(BUFF1+10) == *(BUFF2+10))
 789   1          &&(*(BUFF1+11) == *(BUFF2+11))
 790   1           )
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      05/23/2023 14:43:20 PAGE 14  

 791   1        {
 792   2          return bTRUE;
 793   2        }
 794   1        else
 795   1        {
 796   2          return bFALSE;
 797   2        }
 798   1      }
 799          
 800          bool_t IfPasscodeUserIDisRegistered(uint8_t UserID)//如果密码用户ID已注册
 801          {
 802   1        uint8_t i;
 803   1        for (i=0;i<(DEF_MAX_PASSCODEUSER+DEF_MAX_PASSCODEMASTER);i++)
 804   1        {
 805   2          if (PasscodeMemoryMgr[i].UserID == UserID )
 806   2          {
 807   3            return bTRUE;
 808   3          }
 809   2        }
 810   1        return bFALSE;
 811   1      }
 812          
 813          uint8_t CheckHowManyRegisteredPasscodeMaster( void )//检查注册密码管理员数量
 814          {
 815   1        uint8_t i,MasterNum;
 816   1        MasterNum =0;
 817   1        for (i=0;i<(DEF_MAX_PASSCODEMASTER);i++)
 818   1        {
 819   2          if ( IfPasscodeUserIDisRegistered(i+1) == bTRUE )
 820   2          {
 821   3            MasterNum++;
 822   3          }
 823   2        }
 824   1        return MasterNum;
 825   1      }
 826          
 827          uint8_t CheckHowManyRegisteredPasscodeUser( void )//检查注册密码用户数量
 828          {
 829   1        uint8_t i,UserNum;
 830   1        UserNum =0;
 831   1        for (i=DEF_MAX_PASSCODEMASTER;i<(DEF_MAX_PASSCODEUSER+DEF_MAX_PASSCODEMASTER);i++)
 832   1        {
 833   2          if ( IfPasscodeUserIDisRegistered(i+1) == bTRUE )
 834   2          {
 835   3              UserNum++;
 836   3          }
 837   2        }
 838   1        return UserNum;
 839   1      }
 840          
 841          void DeletePasscodeUserfromMemory(uint8_t UserID)//从EEPROM内存中删除密码用户
 842          {
 843   1        uint8_t i,j;
 844   1      
 845   1        for (i=0;i<(DEF_MAX_PASSCODEUSER+DEF_MAX_PASSCODEMASTER);i++)
 846   1        {
 847   2          if (PasscodeMemoryMgr[i].UserID == UserID )
 848   2          {
 849   3            PasscodeMemoryMgr[i].Status = PasscodeIsInvalid;
 850   3            PasscodeMemoryMgr[i].UserID = 0xFF;
 851   3            for (j=0;j<6;j++)
 852   3            {
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      05/23/2023 14:43:20 PAGE 15  

 853   4              PasscodeMemoryMgr[i].PasscodeBuff[j] = 0xFF;
 854   4            }
 855   3            break;
 856   3          }
 857   2        } 
 858   1      
 859   1        WritePasscodeUserMemoryToEEPROM();
 860   1      }
 861          
 862          void DeleteAllPasscodeMasterfromMemory(void)//从EEPROM内存中删除全部密码管理员
 863          {
 864   1        uint8_t i,j;
 865   1      
 866   1        for (i=0;i<DEF_MAX_PASSCODEMASTER;i++)
 867   1        {
 868   2      
 869   2          PasscodeMemoryMgr[i].Status = PasscodeIsInvalid;
 870   2          PasscodeMemoryMgr[i].UserID = 0xFF;
 871   2          for (j=0;j<6;j++)
 872   2          {
 873   3            PasscodeMemoryMgr[i].PasscodeBuff[j] = 0xFF;
 874   3          }
 875   2      
 876   2        } 
 877   1        WritePasscodeUserMemoryToEEPROM();
 878   1      }
 879          
 880          void DeleteAllPasscodeUserfromMemory(void)//从EEPROM内存中删除全部密码用户
 881          {
 882   1        uint8_t i,j;
 883   1      
 884   1        for (i=DEF_MAX_PASSCODEMASTER;i<(DEF_MAX_PASSCODEMASTER+DEF_MAX_PASSCODEUSER);i++)
 885   1        {
 886   2      
 887   2          PasscodeMemoryMgr[i].Status = PasscodeIsInvalid;
 888   2          PasscodeMemoryMgr[i].UserID = 0xFF;
 889   2          for (j=0;j<6;j++)
 890   2          {
 891   3            PasscodeMemoryMgr[i].PasscodeBuff[j] = 0xFF;
 892   3          }
 893   2      
 894   2        } 
 895   1        WritePasscodeUserMemoryToEEPROM();
 896   1      }
 897          
 898          status_t SavePasscodeUserToMemory(uint8_t *Point,uint8_t UserID)//保存密码用户到内存
 899          {
 900   1        uint8_t j;
 901   1        for (j=0;j<6;j++)
 902   1        {
 903   2          PasscodeMemoryMgr[UserID-1].PasscodeBuff[j] = (*(Point+2*j))<<4|((*(Point+2*j+1)&0X0f));
 904   2        }
 905   1        PasscodeMemoryMgr[UserID-1].UserID = UserID;
 906   1        PasscodeMemoryMgr[UserID-1].Status = PasscodeIsValid;
 907   1        WritePasscodeUserMemoryToEEPROM();
 908   1        return S_SUCCESS;
 909   1      }
 910          
 911          uint8_t Get_Availabe_PasscodeMasterID(void)//获取已注册密码管理员ID
 912          {
 913   1        uint8_t i;
 914   1        for (i=0;i<DEF_MAX_PASSCODEMASTER;i++)
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      05/23/2023 14:43:20 PAGE 16  

 915   1        {
 916   2          if ( PasscodeMemoryMgr[i].Status != PasscodeIsValid ){
 917   3            return (i+1);
 918   3          }
 919   2        }
 920   1        return 0;
 921   1      }
 922          
 923          uint8_t Get_Availabe_PasscodeUserID(void)//获取已注册密码用户ID
 924          {
 925   1        uint8_t i;
 926   1        for (i=DEF_MAX_PASSCODEMASTER;i<(DEF_MAX_PASSCODEMASTER+DEF_MAX_PASSCODEUSER);i++)
 927   1        {
 928   2          if ( PasscodeMemoryMgr[i].Status != PasscodeIsValid ){
 929   3            return (i+1);
 930   3          }
 931   2        }
 932   1        return 0;
 933   1      }
 934          
 935          void ReadRegisteredFPuserFromLocalList(void)
 936          {
 937   1        uint8_t i,j,USERID,Checksum,UserIdByte;
 938   1        
 939   1        ReadFPuserIdListFromEEPROM();
 940   1      
 941   1        Checksum = 0x00;
 942   1      
 943   1        for ( i=0;i<32;i++)
 944   1        {
 945   2          Checksum+=CheckHomManyRegisteredFPuser.UserIdList[i];
 946   2        }
 947   1      
 948   1        if (Checksum!=CheckHomManyRegisteredFPuser.UserIdListChecksum)
 949   1        {
 950   2          ResetFPuserIdListInEEPROM();
 951   2          CheckHomManyRegisteredFPuser.UserNum = 0x00;
 952   2          CheckHomManyRegisteredFPuser.StressUserNum = 0x00;
 953   2          CheckHomManyRegisteredFPuser.MasterNum = 0x00;
 954   2        }
 955   1        else
 956   1        {   
 957   2          USERID = 0x00;
 958   2          CheckHomManyRegisteredFPuser.UserNum = 0x00;
 959   2          CheckHomManyRegisteredFPuser.StressUserNum = 0x00;
 960   2          CheckHomManyRegisteredFPuser.MasterNum = 0x00;
 961   2          for ( i=0;i<32;i++)
 962   2          {
 963   3            UserIdByte = CheckHomManyRegisteredFPuser.UserIdList[i];
 964   3            for (j=0;j<8;j++)
 965   3            { 
 966   4              if ( (UserIdByte&0x01) !=0 )
 967   4              {
 968   5                if ( USERID < DEF_MAX_FPMASTER )
 969   5                {
 970   6                  CheckHomManyRegisteredFPuser.MasterNum++;
 971   6                  FpUserMemoryMgr[USERID].UserID = USERID;
 972   6                  FpUserMemoryMgr[USERID].RegisterStatus = Registered;
 973   6                  FpUserMemoryMgr[USERID].UserPriority = Master;
 974   6                }
 975   5                else if ( USERID < (DEF_MAX_FPMASTER+DEF_MAX_FPUSER))
 976   5                {
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      05/23/2023 14:43:20 PAGE 17  

 977   6                  CheckHomManyRegisteredFPuser.UserNum++;
 978   6                  FpUserMemoryMgr[USERID].UserID = USERID;
 979   6                  FpUserMemoryMgr[USERID].RegisterStatus = Registered;
 980   6                  FpUserMemoryMgr[USERID].UserPriority = User;
 981   6                }
 982   5                
 983   5              }
 984   4              else
 985   4              {
 986   5                if ( USERID < DEF_MAX_FPMASTER )
 987   5                {
 988   6                  FpUserMemoryMgr[USERID].UserID = USERID;
 989   6                  FpUserMemoryMgr[USERID].RegisterStatus = UnRegistered;
 990   6                  FpUserMemoryMgr[USERID].UserPriority = Master;
 991   6                }
 992   5                else if ( USERID < (DEF_MAX_FPMASTER+DEF_MAX_FPUSER))
 993   5                {
 994   6                  FpUserMemoryMgr[USERID].UserID = USERID;
 995   6                  FpUserMemoryMgr[USERID].RegisterStatus = UnRegistered;
 996   6                  FpUserMemoryMgr[USERID].UserPriority = User;
 997   6                }
 998   5              }
 999   4              UserIdByte>>=1;
1000   4              USERID++;
1001   4            }
1002   3          }
1003   2        }
1004   1      }
1005          
1006          /*******************************************************/
1007          /*******************************************************/
1008          /*******************************************************/
1009          void CheckHowManyRegisteredFPuserFromFPM(void)
1010          {
1011   1        //uint8_t FPindexTable[32];
1012   1        uint8_t i,j,USERID;
1013   1        
1014   1        if ( CheckHomManyRegisteredFPuser.Status == StartCheckHowManyRegisteredFPuser )
1015   1          {
1016   2            FPM_SendReadIndexTableCmd();
1017   2            CheckHomManyRegisteredFPuser.TimeCnt = Def_GuiTimeDelayCnt05s;//Def_FPMcmdTimeOutDelay;
1018   2            CheckHomManyRegisteredFPuser.Status = WaitForCheckHowManyRegisteredFPuserCmdAck;
1019   2            FpmAckMgr.Status = WaitACK;
1020   2          }
1021   1        else if ( CheckHomManyRegisteredFPuser.Status == WaitForCheckHowManyRegisteredFPuserCmdAck)
1022   1          {
1023   2            if (FpmAckMgr.Status == GotACK)
1024   2            {
1025   3              if ( FpmAckMgr.ErrorCode == Error_NONE)
1026   3              {
1027   4                USERID = 0x00;
1028   4                CheckHomManyRegisteredFPuser.UserNum = 0x00;
1029   4                CheckHomManyRegisteredFPuser.StressUserNum = 0x00;
1030   4                CheckHomManyRegisteredFPuser.MasterNum = 0x00;
1031   4                for ( i=0;i<32;i++)
1032   4                  {
1033   5                    for (j=0;j<8;j++)
1034   5                    { 
1035   6                      if ( (FpmAckMgr.Buff[10+i]&0x01) !=0 )
1036   6                      {
1037   7                        if ( USERID < DEF_MAX_FPMASTER )
1038   7                        {
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      05/23/2023 14:43:20 PAGE 18  

1039   8                          CheckHomManyRegisteredFPuser.MasterNum++;
1040   8                          FpUserMemoryMgr[USERID].UserID = USERID;
1041   8                          FpUserMemoryMgr[USERID].RegisterStatus = Registered;
1042   8                          FpUserMemoryMgr[USERID].UserPriority = Master;
1043   8                        }
1044   7                        else if ( USERID < (DEF_MAX_FPMASTER+DEF_MAX_FPUSER))
1045   7                        {
1046   8                          CheckHomManyRegisteredFPuser.UserNum++;
1047   8                          FpUserMemoryMgr[USERID].UserID = USERID;
1048   8                          FpUserMemoryMgr[USERID].RegisterStatus = Registered;
1049   8                          FpUserMemoryMgr[USERID].UserPriority = User;
1050   8                        }
1051   7                      }
1052   6                      else
1053   6                      {
1054   7                        if ( USERID < DEF_MAX_FPMASTER )
1055   7                        {
1056   8                          FpUserMemoryMgr[USERID].UserID = USERID;
1057   8                          FpUserMemoryMgr[USERID].RegisterStatus = UnRegistered;
1058   8                          FpUserMemoryMgr[USERID].UserPriority = Master;
1059   8                        }
1060   7                        else if ( USERID < (DEF_MAX_FPMASTER+DEF_MAX_FPUSER))
1061   7                        {
1062   8                          FpUserMemoryMgr[USERID].UserID = USERID;
1063   8                          FpUserMemoryMgr[USERID].RegisterStatus = UnRegistered;
1064   8                          FpUserMemoryMgr[USERID].UserPriority = User;
1065   8                        }
1066   7                      }
1067   6                      
1068   6                      FpmAckMgr.Buff[10+i]>>=1;
1069   6                      USERID++;
1070   6                    }
1071   5                  }
1072   4                CheckHomManyRegisteredFPuser.Status = CheckHomManyRegisteredFPuserSuccess;
1073   4              }
1074   3              else{
1075   4                DEBUG_MARK;
1076   4                CheckHomManyRegisteredFPuser.Status = CheckHomManyRegisteredFPuserFail;
1077   4              }
1078   3            }
1079   2            if ( CheckHomManyRegisteredFPuser.TimeCnt-- < 1 )
1080   2            {
1081   3              CheckHomManyRegisteredFPuser.Status = CheckHomManyRegisteredFPuserFail;
1082   3            }
1083   2          }
1084   1        
1085   1      }
1086          
1087          void GUI_GetUserNumList(void)//获取用户数量
1088          {
1089   1      
1090   1        if ( CheckMemoryMgr.Status == StartCheckMemory)
1091   1        {
1092   2          CheckHomManyRegisteredFPuser.Status = StartCheckHowManyRegisteredFPuser;
1093   2          CheckHomManyRegisteredFPuser.FailTimes = 0x00;
1094   2          CheckMemoryMgr.Status = WaitForReadFPuserNum;
1095   2        }
1096   1        else if ( CheckMemoryMgr.Status == WaitForReadFPuserNum )
1097   1        {
1098   2          //CheckHowManyRegistereFPuser();
1099   2          CheckHowManyRegisteredFPuserFromFPM();
1100   2          if ( CheckHomManyRegisteredFPuser.Status == CheckHomManyRegisteredFPuserSuccess )
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      05/23/2023 14:43:20 PAGE 19  

1101   2          {
1102   3            CheckMemoryMgr.FpUserNum = CheckHomManyRegisteredFPuser.UserNum;
1103   3            CheckMemoryMgr.FpMasterNum = CheckHomManyRegisteredFPuser.MasterNum;
1104   3            CheckMemoryMgr.CardUserNum = CheckHowManyRegisteredCardUser();
1105   3            CheckMemoryMgr.PasscodeMasterNum = CheckHowManyRegisteredPasscodeMaster();
1106   3            CheckMemoryMgr.PasscodeUserNum = CheckHowManyRegisteredPasscodeUser();
1107   3            CheckMemoryMgr.Status = CheckMemorySuccess;
1108   3          }
1109   2          else if ( CheckHomManyRegisteredFPuser.Status == CheckHomManyRegisteredFPuserFail )
1110   2          {
1111   3            if ( CheckHomManyRegisteredFPuser.FailTimes++ < 3 )
1112   3            {
1113   4              CheckHomManyRegisteredFPuser.Status = StartCheckHowManyRegisteredFPuser;//retry
1114   4            }
1115   3            else
1116   3            {
1117   4              ReadRegisteredFPuserFromLocalList();
1118   4              CheckMemoryMgr.FpUserNum = CheckHomManyRegisteredFPuser.UserNum;
1119   4              CheckMemoryMgr.FpMasterNum = CheckHomManyRegisteredFPuser.MasterNum;
1120   4              CheckMemoryMgr.CardUserNum = CheckHowManyRegisteredCardUser();
1121   4              CheckMemoryMgr.PasscodeMasterNum = CheckHowManyRegisteredPasscodeMaster();
1122   4              CheckMemoryMgr.PasscodeUserNum = CheckHowManyRegisteredPasscodeUser();
1123   4              #ifdef Function_FaceRecoginition      
                      CheckMemoryMgr.FaceMasterNum = CheckHowManyRegisteredFaceMaster();
                      CheckMemoryMgr.FaceUserNum = CheckHowManyRegisteredFaceUser();
                      #endif    
1127   4              CheckMemoryMgr.Status = CheckMemoryFail;
1128   4            }
1129   3          }
1130   2        }
1131   1      }
1132          
1133          uint8_t TranslateNumberToVoice(uint8_t value)//将数字转换为语音
1134          {
1135   1        return 12+(2*value);
1136   1      }
1137          
1138          #ifdef Function_Enable_ID_Del
1139          void ReportRegisterID(uint16_t type, uint16_t ID)
1140          {
1141   1        uint8_t voiceType[] = {VOICE_Fingerprint, VOICE_Password, VOICE_Card};
1142   1        uint8_t voiceBuf[7] = {0};
1143   1        if (type >= 0 && type <= 2 && ID >= 1 && ID <= 999)
1144   1        {
1145   2          voiceBuf[0] = VOICE_Add;
1146   2          voiceBuf[1] = voiceType[type];
1147   2          voiceBuf[2] = VOICE_ID;
1148   2          voiceBuf[3] = TranslateNumberToVoice(ID / 100);
1149   2          voiceBuf[4] = TranslateNumberToVoice(ID / 10 % 10);
1150   2          voiceBuf[5] = TranslateNumberToVoice(ID % 10);
1151   2          voiceBuf[6] = DEF_VoiceSegmentEndFlag;
1152   2          PLAY_VOICE_MULTISEGMENTS(voiceBuf);
1153   2        }
1154   1      }
1155          #endif
1156          
1157          void SaveSystemTime( void )
1158          {
1159   1        SystemTime.year   =   TempSystemTime.year;
1160   1        SystemTime.month  =   TempSystemTime.month;
1161   1        SystemTime.date   =   TempSystemTime.date;
1162   1        SystemTime.day    =   TempSystemTime.day;
C51 COMPILER V9.60.0.0   GUI_FUNCTION                                                      05/23/2023 14:43:20 PAGE 20  

1163   1        SystemTime.hour   =   TempSystemTime.hour;
1164   1        SystemTime.minute =   TempSystemTime.minute;
1165   1        SystemTime.second =   TempSystemTime.second;
1166   1      }
1167          
1168          void GotSystemTime( void )
1169          {
1170   1        TempSystemTime.year   = SystemTime.year;
1171   1        TempSystemTime.month  = SystemTime.month;
1172   1        TempSystemTime.date   = SystemTime.date;
1173   1        TempSystemTime.day    = SystemTime.day;
1174   1        TempSystemTime.hour   = SystemTime.hour;
1175   1        TempSystemTime.minute = SystemTime.minute;
1176   1        TempSystemTime.second = SystemTime.second;
1177   1      }
1178          
1179          
1180          
1181          
1182          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3946    ----
   CONSTANT SIZE    =     22    ----
   XDATA SIZE       =   ----      93
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.60.0.0   MFC_MF17622                                                       05/23/2023 14:43:18 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MFC_MF17622
OBJECT MODULE PLACED IN .\Objects\MFC_MF17622.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Drivers\Protocol\MFC_MF17622.c LARGE OMF2 OPTIMIZE(9,SPEED) BROWSE INCDI
                    -R(.\Drivers\Lib\c;.\Drivers\Lib\H;.\Drivers\Lib\IAP_Lib;.\Drivers\Lib\TouchKey_lib;.\Drivers\Physical;.\Drivers\Protocol
                    -;.\Softwares\Application;.\Softwares\Basic;.\Softwares\ModuleLogic;.\Drivers\Protocol\YC_NFC;.\Drivers\Protocol\WIFI_Tuy
                    -a) DEBUG PRINT(.\Listings\MFC_MF17622.lst) TABS(2) OBJECT(.\Objects\MFC_MF17622.obj)

line level    source

   1          #include "IO.h"
   2          #include "I2cBus.h"
   3          #include "MFC_MF17622.h"
   4          #include "FM17622_LPCD_API.h"
   5          #include "GUI_Function.h"
   6          #include "Basic_Function.h"
   7          #include "global_variable.h"
   8          
   9          //******************************************************************/
  10          //                         函数定义                                 /
  11          //******************************************************************/
  12          sint8_t PcdHalt(void);
  13          sint8_t PcdReset(void);
  14          void PcdAntennaOn(void);
  15          void PcdAntennaOff(void);
  16          sint8_t PcdRequest(uint8_t req_code,uint8_t *pTagType);   
  17          sint8_t PcdAnticoll(uint8_t *pSnr);
  18          sint8_t PcdSelect(uint8_t *pSnr);
  19          sint8_t PcdAuthState(uint8_t auth_mode,uint8_t addr,
  20                            uint8_t *pKey,uint8_t *pSnr);     
  21          sint8_t PcdRead(uint8_t addr,uint8_t *pData);     
  22          sint8_t PcdWrite(uint8_t addr,uint8_t *pData);    
  23          sint8_t PcdValue(uint8_t dd_mode,uint8_t addr,uint8_t *pValue);   
  24          sint8_t PcdBakValue(uint8_t sourceaddr, uint8_t goaladdr);                                 
  25          sint8_t PcdComMF522(uint8_t Command, uint8_t *pInData, 
  26                           uint8_t InLenByte,uint8_t *pOutData, 
  27                           uint16_t  *pOutLenBit);
  28          void CalulateCRC(uint8_t *pIndata,uint8_t len,
  29                           uint8_t *pOutData);
  30          void WriteRawRC(uint8_t Address,uint8_t value);
  31          uint8_t ReadRawRC(uint8_t Address); 
  32          void SetBitMask(uint8_t reg,uint8_t mask); 
  33          void ClearBitMask(uint8_t reg,uint8_t mask); 
  34          sint8_t Read_Block(uint8_t Block,uint8_t *Buf);
  35          sint8_t Write_Block(uint8_t Block);
  36          void PcdAntennaTestOn(void);
  37          
  38          extern sint8_t KK[8]; // 数据加密密钥
  39          static uint8_t RF_Buffer[18]; // 射频卡数据缓冲区
  40          static uint8_t UID[5];
  41          static uint8_t Password_Buffer[6]={0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
  42          //extern void Des_Encrypt(sint8_t* In, sint8_t* K,sint8_t* Out);
  43          //extern void Des_Decrypt(sint8_t* In, sint8_t* K,sint8_t* Out);
  44          static uint8_t des_on; // DES加密标志
  45          
  46          static uint8_t TestVal;
  47          static uint8_t TestBuff[20];
  48          
  49          static uint8_t HAL_SPI2_RXBUFF;
  50          #ifdef Function_CardReaderUseSPI
              //******************************************************************/
              //功    能：读RC522寄存器
C51 COMPILER V9.60.0.0   MFC_MF17622                                                       05/23/2023 14:43:18 PAGE 2   

              //参数说明：Address[IN]:寄存器地址
              //返    回：读出的值
              //******************************************************************/
              uint8_t ReadRawRC(uint8_t Address)
              {
                uint8_t ucResult,ReadData;
                uint8_t TempNFC_TX;
                HAL_StatusTypeDef HAL_STATUS;
                
                SET_MFC_CS_L;
                Hardware_DelayX1us(10);
              //  Hardware_DelayMs(10);
                ucResult = (Address<<1)|0x80;
                
                HAL_STATUS = HAL_SPI_Transmit(&hspi2,&ucResult,1,10);
                
                TempNFC_TX=0x00;
                HAL_STATUS = HAL_SPI_TransmitReceive(&hspi2,&TempNFC_TX,&HAL_SPI2_RXBUFF,1,10);
                
                SET_MFC_CS_H;
              
              //  Hardware_DelayMs(10);
                Hardware_DelayX1us(10);
                return HAL_SPI2_RXBUFF;
              }
              
              //******************************************************************/
              //功    能：写RC522寄存器
              //参数说明：Address[IN]:寄存器地址
              //          value[IN]:写入的值
              //******************************************************************/
              void  WriteRawRC(uint8_t Address, uint8_t value)
              {
                uint8_t temp;
                HAL_StatusTypeDef HAL_STATUS;
                
                SET_MFC_CS_L;
                Hardware_DelayX1us(10);
                
                temp = Address<<1;
                HAL_STATUS = HAL_SPI_Transmit(&hspi2,&temp,1,500);
                HAL_STATUS = HAL_SPI_Transmit(&hspi2,&value,1,500);
                SET_MFC_CS_H;
                //Hardware_DelayX1us(100);
              }
              
              #else
 100          uint8_t ReadRawRC(uint8_t Address)
 101          {
 102   1        uint8_t ucResult;
 103   1        I2C_ReadRandom(I2CADDR_MFC,Address,&ucResult);
 104   1        return ucResult;
 105   1      }
 106          void WriteRawRC(uint8_t Address, uint8_t value)
 107          {  
 108   1        I2C_WriteRandom(I2CADDR_MFC,Address,value);
 109   1      }
 110          #endif
 111          
 112          //******************************************************************/
 113          //功    能：置RC522寄存器位
 114          //参数说明：reg[IN]:寄存器地址
C51 COMPILER V9.60.0.0   MFC_MF17622                                                       05/23/2023 14:43:18 PAGE 3   

 115          //          mask[IN]:置位值
 116          //******************************************************************/
 117          void SetBitMask(uint8_t reg,uint8_t mask)  
 118          {
 119   1        sint8_t tmp = 0x00;
 120   1        tmp = ReadRawRC(reg)| mask;
 121   1        WriteRawRC(reg, tmp);  // set bit mask
 122   1      }
 123          
 124          //******************************************************************/
 125          //功    能：清RC522寄存器位
 126          //参数说明：reg[IN]:寄存器地址
 127          //          mask[IN]:清位值
 128          //******************************************************************/
 129          void ClearBitMask(uint8_t reg,uint8_t mask)  
 130          {
 131   1        sint8_t tmp = 0x00;
 132   1        tmp = ReadRawRC(reg)&(~mask);
 133   1        WriteRawRC(reg, tmp)        ;  // clear bit mask
 134   1      } 
 135          
 136          status_t FM17622_SoftReset(void)
 137          { 
 138   1        unsigned char reg_data;
 139   1        WriteRawRC(CommandReg,PCD_RESETPHASE);
 140   1        Hardware_DelayMs(3); 
 141   1        reg_data = ReadRawRC(CommandReg);
 142   1        if(reg_data == 0x20)
 143   1          return S_SUCCESS;
 144   1        else
 145   1          return S_FAIL;
 146   1      }
 147          //******************************************************************/
 148          //功    能：复位RC522
 149          //返    回: 成功返回MI_OK
 150          //******************************************************************/
 151          sint8_t PcdReset(void)
 152          {
 153   1        //SET_MFC_RST_H;
 154   1        //Hardware_DelayMs(1);
 155   1        SET_MFC_RST_L;
 156   1        Hardware_DelayX1us(10);
 157   1        SET_MFC_RST_H;
 158   1        Hardware_DelayX1us(50);
 159   1      
 160   1        WriteRawRC(CommandReg,PCD_RESETPHASE);
 161   1        Hardware_DelayMs(5)                  ;
 162   1      
 163   1        WriteRawRC(RFCfgReg,0x58)       ; 
 164   1      
 165   1        /* 增益调整 GsN前后两位独立 CWGsCfg最大0x3F ModGsCfg最大0x3F*/
 166   1      #ifdef ProjectIs_AutoBarLock_S11Z04
                
                WriteRawRC(GsNReg,0xFF)     ; 
                WriteRawRC(CWGsCfgReg,0x3F)   ; 
                WriteRawRC(ModGsCfgReg,0x3F)   ; 
              #else
 172   1        WriteRawRC(GsNReg,0xFF); 
 173   1        WriteRawRC(CWGsCfgReg,0x3F); 
 174   1        WriteRawRC(ModGsCfgReg,0x3F);
 175   1      #endif
 176   1      
C51 COMPILER V9.60.0.0   MFC_MF17622                                                       05/23/2023 14:43:18 PAGE 4   

 177   1        WriteRawRC(ModeReg,0x3D);
 178   1        WriteRawRC(TReloadRegL,30);
 179   1        WriteRawRC(TReloadRegH,0);
 180   1        
 181   1        WriteRawRC(TModeReg,0x8D);
 182   1        WriteRawRC(TPrescalerReg,0x3E);  
 183   1          
 184   1      //  WriteRawRC(TxASKReg,0x40)            ; // FOR DEBUG AND TEST
 185   1        return MI_OK; 
 186   1      }
 187          
 188          //******************************************************************/
 189          //开启天线发射  
 190          //每次启动或关闭天险发射之间应至少有1ms的间隔
 191          //******************************************************************/
 192          void PcdAntennaOn(void)
 193          {
 194   1        //uint8_t i;
 195   1        /*
 196   1        WriteRawRC(TxASKReg,0x40)       ;
 197   1        Hardware_DelayMs(3)            ;
 198   1        i = ReadRawRC(TxControlReg)     ;
 199   1        if(!(i&0x03))
 200   1          SetBitMask(TxControlReg, 0x03);
 201   1        i=ReadRawRC(TxASKReg)       ;
 202   1        */
 203   1        WriteRawRC(TxASKReg,0x40)       ;
 204   1        SetBitMask(TxControlReg, 0x03);
 205   1      }
 206          
 207          //******************************************************************/
 208          //开启天线发射  
 209          //每次启动或关闭天险发射之间应至少有1ms的间隔
 210          //******************************************************************/
 211          void PcdAntennaTestOn(void)
 212          {
 213   1      //*
 214   1        SET_MFC_RST_H                         ;
 215   1        Hardware_DelayMs(15); // 2010.10.09 ???? FOR DEBUG
 216   1        
 217   1        WriteRawRC(TxControlReg,0x02)    ;
 218   1      }
 219          
 220          
 221          //******************************************************************/
 222          //关闭天线发射
 223          //******************************************************************/
 224          void PcdAntennaOff(void)
 225          {
 226   1        //return;
 227   1          ClearBitMask(TxControlReg, 0x03);
 228   1      }
 229          
 230          //******************************************************************/
 231          //功    能：通过RC522和ISO14443卡通讯
 232          //参数说明：Command[IN]:RC522命令字
 233          //          pInData[IN]:通过RC522发送到卡片的数据
 234          //          InLenByte[IN]:发送数据的字节长度
 235          //          pOutData[OUT]:接收到的卡片返回数据
 236          //          *pOutLenBit[OUT]:返回数据的位长度
 237          //******************************************************************/
 238          sint8_t PcdComMF522(uint8_t Command  ,uint8_t *pInData , 
C51 COMPILER V9.60.0.0   MFC_MF17622                                                       05/23/2023 14:43:18 PAGE 5   

 239                           uint8_t InLenByte,uint8_t *pOutData, 
 240                           uint16_t  *pOutLenBit                       )
 241          {
 242   1        sint8_t status = MI_ERR                          ;
 243   1        uint8_t irqEn   = 0x00                  ;
 244   1        uint8_t waitFor = 0x00                  ;
 245   1        uint8_t lastBits                        ;
 246   1        uint8_t n                               ;
 247   1        uint16_t  i                               ;
 248   1        switch (Command)
 249   1        {
 250   2          case PCD_AUTHENT:
 251   2            irqEn   = 0x12                            ;
 252   2            waitFor = 0x10                            ;
 253   2            break                                     ;
 254   2          case PCD_TRANSCEIVE:
 255   2            irqEn   = 0x20;//0x77                            ;
 256   2            waitFor = 0x30                            ;
 257   2            break                                     ;
 258   2          default:
 259   2            break                                     ;
 260   2        }
 261   1        WriteRawRC(ComIEnReg,irqEn|0x80)              ; //
 262   1        ClearBitMask(ComIrqReg,0x80)                  ;
 263   1        WriteRawRC(CommandReg,PCD_IDLE)               ;
 264   1        SetBitMask(FIFOLevelReg,0x80)                 ; // 清空FIFO 
 265   1        for(i=0; i<InLenByte; i++)
 266   1          WriteRawRC(FIFODataReg,pInData[i])          ; // 数据写入FIFO 
 267   1        WriteRawRC(CommandReg, Command)               ; // 命令写入命令寄存器
 268   1        if(Command == PCD_TRANSCEIVE)
 269   1          SetBitMask(BitFramingReg,0x80)              ; // 开始发送     
 270   1        
 271   1        PcdAntennaOn()                                ;//开启天线发射
 272   1        
 273   1        i = 100                                         ; //根据时钟频率调整，操作M1等待时间15ms
 274   1        do 
 275   1        {
 276   2          n = ReadRawRC(ComIrqReg)                    ;
 277   2          i--                                         ;
 278   2        }
 279   1        while((i!=0)&&!(n&0x01)&&!(n&waitFor))        ;
 280   1        ClearBitMask(BitFramingReg,0x80)              ;
 281   1        if(i!=0)
 282   1        {
 283   2          if(!(ReadRawRC(ErrorReg)&0x1B))
 284   2          {
 285   3            status = MI_OK                            ;
 286   3            if (n&irqEn&0x01)
 287   3              status = MI_NOTAGERR                    ;
 288   3            if(Command==PCD_TRANSCEIVE)
 289   3            {
 290   4              n = ReadRawRC(FIFOLevelReg)             ;
 291   4              lastBits = ReadRawRC(ControlReg)&0x07   ;
 292   4              if(lastBits)
 293   4                *pOutLenBit = (n-1)*8 + lastBits      ;
 294   4              else
 295   4                *pOutLenBit = n*8                     ;
 296   4              if(n==0)
 297   4                n = 1                                 ;
 298   4              if(n>MAXRLEN)
 299   4                n = MAXRLEN                           ;
 300   4              
C51 COMPILER V9.60.0.0   MFC_MF17622                                                       05/23/2023 14:43:18 PAGE 6   

 301   4             for (i=0; i<n; i++)
 302   4              { 
 303   5                pOutData[i]= ReadRawRC(FIFODataReg)  ; 
 304   5              }
 305   4              
 306   4              DEBUG_MARK;
 307   4            }
 308   3          }
 309   2          else
 310   2            status = MI_ERR;        
 311   2        }
 312   1        else{
 313   2          PcdAntennaOff();
 314   2        }
 315   1        SetBitMask(ControlReg,0x80);// stop timer now
 316   1        WriteRawRC(CommandReg,PCD_IDLE); 
 317   1        return status;
 318   1      }
 319          
 320          //******************************************************************/
 321          //功    能：寻卡                                                    /
 322          //参数说明: req_code[IN]:寻卡方式                                   /
 323          //                0x52 = 寻感应区内所有符合14443A标准的卡           /
 324          //                0x26 = 寻未进入休眠状态的卡                       /
 325          //          pTagType[OUT]：卡片类型代码                             /
 326          //                0x4400 = Mifare_UltraLight                        /
 327          //                0x0400 = Mifare_One(S50)                          /
 328          //                0x0200 = Mifare_One(S70)                          /
 329          //                0x0800 = Mifare_Pro(X)                            /
 330          //                0x4403 = Mifare_DESFire                           /
 331          //返    回: 成功返回MI_OK                                           /
 332          //******************************************************************/
 333          sint8_t PcdRequest(uint8_t req_code,uint8_t *pTagType)
 334          {
 335   1        sint8_t status;  
 336   1        uint16_t  unLen;
 337   1        uint8_t ucComMF522Buf[MAXRLEN]; 
 338   1      
 339   1        ClearBitMask(Status2Reg,0x08);
 340   1        WriteRawRC(BitFramingReg,0x07);
 341   1        SetBitMask(TxControlReg,0x03);
 342   1       
 343   1        ucComMF522Buf[0] = req_code;
 344   1      
 345   1        status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,
 346   1                             1,ucComMF522Buf,&unLen);
 347   1        if ((status == MI_OK) && (unLen == 0x10))
 348   1        {    
 349   2          *pTagType     = ucComMF522Buf[0];
 350   2          *(pTagType+1) = ucComMF522Buf[1];
 351   2        }
 352   1        else
 353   1          status = MI_ERR;
 354   1        return status;
 355   1      }
 356          
 357          //******************************************************************/
 358          //功    能：防冲撞                                                  /
 359          //参数说明: pSnr[OUT]:卡片序列号，4字节                             /
 360          //返    回: 成功返回MI_OK                                           /
 361          //******************************************************************/
 362          sint8_t PcdAnticoll(uint8_t *pSnr)
C51 COMPILER V9.60.0.0   MFC_MF17622                                                       05/23/2023 14:43:18 PAGE 7   

 363          {
 364   1          sint8_t status;
 365   1          uint8_t i,snr_check=0;
 366   1          uint16_t  unLen;
 367   1          uint8_t ucComMF522Buf[MAXRLEN]; 
 368   1          
 369   1        //return MI_OK;
 370   1        
 371   1          ClearBitMask(Status2Reg,0x08);
 372   1          WriteRawRC(BitFramingReg,0x00);
 373   1          ClearBitMask(CollReg,0x80);
 374   1       
 375   1          ucComMF522Buf[0] = PICC_ANTICOLL1;
 376   1          ucComMF522Buf[1] = 0x20;
 377   1      
 378   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
 379   1      
 380   1          if (status == MI_OK)
 381   1          {
 382   2             for (i=0; i<4; i++)
 383   2               {   
 384   3                   *(pSnr+i)  = ucComMF522Buf[i];
 385   3                   snr_check ^= ucComMF522Buf[i];
 386   3               }
 387   2               if (snr_check != ucComMF522Buf[i])
 388   2               {   status = MI_ERR;    }
 389   2          }
 390   1          
 391   1          SetBitMask(CollReg,0x80);
 392   1          return status;
 393   1      }
 394          
 395          /////////////////////////////////////////////////////////////////////
 396          //功    能：选定卡片
 397          //参数说明: pSnr[IN]:卡片序列号，4字节
 398          //返    回: 成功返回MI_OK
 399          /////////////////////////////////////////////////////////////////////
 400          sint8_t PcdSelect(uint8_t *pSnr)
 401          {
 402   1          sint8_t status;
 403   1          uint8_t i;
 404   1          uint16_t  unLen;
 405   1          uint8_t ucComMF522Buf[MAXRLEN]; 
 406   1          
 407   1          ucComMF522Buf[0] = PICC_ANTICOLL1;
 408   1          ucComMF522Buf[1] = 0x70;
 409   1          ucComMF522Buf[6] = 0;
 410   1          for (i=0; i<4; i++)
 411   1          {
 412   2            ucComMF522Buf[i+2] = *(pSnr+i);
 413   2            ucComMF522Buf[6]  ^= *(pSnr+i);
 414   2          }
 415   1          CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
 416   1        
 417   1          ClearBitMask(Status2Reg,0x08);
 418   1      
 419   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
 420   1          
 421   1          if ((status == MI_OK) && (unLen == 0x18))
 422   1          {   status = MI_OK;  }
 423   1          else
 424   1          {   status = MI_ERR;    }
C51 COMPILER V9.60.0.0   MFC_MF17622                                                       05/23/2023 14:43:18 PAGE 8   

 425   1      
 426   1          return status;
 427   1      }
 428          
 429          //******************************************************************/
 430          //功    能：验证卡片密码
 431          //参数说明: auth_mode[IN]: 密码验证模式
 432          //                 0x60 = 验证A密钥
 433          //                 0x61 = 验证B密钥 
 434          //          addr[IN]：块地址
 435          //          pKey[IN]：密码
 436          //          pSnr[IN]：卡片序列号，4字节
 437          //返    回: 成功返回MI_OK
 438          //******************************************************************/
 439          sint8_t PcdAuthState(uint8_t auth_mode,uint8_t addr,
 440                            uint8_t *pKey,uint8_t *pSnr    )
 441          {
 442   1          sint8_t status;
 443   1          uint16_t  unLen;
 444   1          uint8_t i,ucComMF522Buf[MAXRLEN]; 
 445   1      
 446   1          ucComMF522Buf[0] = auth_mode;
 447   1          ucComMF522Buf[1] = addr;
 448   1          for (i=0; i<6; i++)
 449   1          {    ucComMF522Buf[i+2] = *(pKey+i);   }
 450   1          for (i=0; i<6; i++)
 451   1          {    ucComMF522Buf[i+8] = *(pSnr+i);   }
 452   1          
 453   1          status = PcdComMF522(PCD_AUTHENT,ucComMF522Buf,12,ucComMF522Buf,&unLen);
 454   1          if ((status != MI_OK) || (!(ReadRawRC(Status2Reg) & 0x08)))
 455   1          {   status = MI_ERR;   }
 456   1          
 457   1          return status;
 458   1      }
 459          
 460          //******************************************************************/
 461          //功    能：读取M1卡一块数据
 462          //参数说明: addr[IN]：块地址
 463          //          pData[OUT]：读出的数据，16字节
 464          //返    回: 成功返回MI_OK
 465          //******************************************************************/
 466          sint8_t PcdRead(uint8_t addr,uint8_t *pData)
 467          {
 468   1          sint8_t status                                  ;
 469   1          uint16_t  unLen                                 ;
 470   1          uint8_t i                                       ;
 471   1          uint8_t ucComMF522Buf[MAXRLEN]                  ; 
 472   1      
 473   1          ucComMF522Buf[0] = PICC_READ                         ;
 474   1          ucComMF522Buf[1] = addr                              ;
 475   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2])       ;   
 476   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,
 477   1                               ucComMF522Buf,&unLen           );
 478   1          if ((status == MI_OK) && (unLen == 0x90))
 479   1          {
 480   2              for (i=0; i<16; i++)
 481   2                  *(pData+i) = ucComMF522Buf[i];   
 482   2          }
 483   1          else
 484   1            status = MI_ERR;       
 485   1          return status;
 486   1      }
C51 COMPILER V9.60.0.0   MFC_MF17622                                                       05/23/2023 14:43:18 PAGE 9   

 487          
 488          //******************************************************************/
 489          //功    能：读取M1卡一块数据
 490          //参数说明: addr[IN]：块地址
 491          //          pData[OUT]：读出的数据，16字节
 492          //返    回: 成功返回MI_OK
 493          //******************************************************************/
 494          sint8_t Read_Block(uint8_t Block,uint8_t *Buf)
 495          {
 496   1        sint8_t result                                             ;
 497   1      
 498   1        result = PcdAuthState(0x60,Block,Password_Buffer,UID)   ;
 499   1        if(result!=MI_OK)
 500   1          return result                                         ;
 501   1        result = PcdRead(Block,Buf)                             ;
 502   1      //  return result; // 2011.01.03
 503   1        
 504   1        if(result!=MI_OK)     return   result                   ;
 505   1        if(Block!=0x00&&des_on)
 506   1        {
 507   2          /*
 508   2          Des_Decrypt((sint8_t *)Buf,KK,(sint8_t *)Buf);
 509   2          Des_Decrypt((sint8_t *)&Buf[8],KK,(sint8_t *)&Buf[8]);  
 510   2          */
 511   2        }
 512   1        return MI_OK                                          ; 
 513   1      }
 514          
 515          //******************************************************************/
 516          //功    能：写数据到M1卡一块
 517          //参数说明: addr[IN]：块地址
 518          //          pData[IN]：写入的数据，16字节
 519          //返    回: 成功返回MI_OK
 520          //******************************************************************/
 521          sint8_t PcdWrite(uint8_t addr,uint8_t *pData)
 522          {
 523   1        sint8_t status                                             ;
 524   1        uint16_t  unLen                                     ;
 525   1        uint8_t i;uint8_t ucComMF522Buf[MAXRLEN]                  ; 
 526   1          
 527   1        ucComMF522Buf[0] = PICC_WRITE                           ;
 528   1        ucComMF522Buf[1] = addr                                 ;
 529   1        CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2])          ;
 530   1        status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,
 531   1                             ucComMF522Buf,&unLen          )    ;
 532   1        if(  ( status != MI_OK)||(unLen != 4)
 533   1           ||((ucComMF522Buf[0]&0x0F)!= 0x0A))
 534   1          status = MI_ERR                                       ;           
 535   1        if (status == MI_OK)
 536   1        {
 537   2          for (i=0; i<16; i++)
 538   2            ucComMF522Buf[i] = *(pData+i)                       ;  
 539   2          CalulateCRC(ucComMF522Buf,16,&ucComMF522Buf[16])      ;
 540   2          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,
 541   2                               18,ucComMF522Buf,&unLen     )    ;
 542   2          if(  (status != MI_OK)||(unLen != 4 )
 543   2             ||((ucComMF522Buf[0]&0x0F)!= 0x0A))
 544   2            status = MI_ERR                                     ;   
 545   2        }    
 546   1        return status                                           ;
 547   1      }
 548          //******************************************************************/
C51 COMPILER V9.60.0.0   MFC_MF17622                                                       05/23/2023 14:43:18 PAGE 10  

 549          //功    能：写数据到M1卡一块
 550          //参数说明: addr[IN]：块地址
 551          //          pData[IN]：写入的数据，16字节
 552          //返    回: 成功返回MI_OK
 553          //******************************************************************/
 554          
 555          sint8_t Write_Block(uint8_t Block)
 556          {
 557   1        sint8_t result                                             ;
 558   1        if(des_on)
 559   1        {
 560   2      /*    Des_Encrypt((sint8_t *)RF_Buffer    ,KK,
 561   2                      (sint8_t *)RF_Buffer        )                ;// for debug
 562   2          Des_Encrypt((sint8_t *)&RF_Buffer[8],KK,
 563   2                      (sint8_t *)&RF_Buffer[8]    )                ;// for debug  
 564   2      */                
 565   2        }
 566   1        result = PcdAuthState(0x60,Block,Password_Buffer,UID)   ;
 567   1        if(result!=MI_OK)
 568   1          return result                                         ;  
 569   1        result = PcdWrite(Block,RF_Buffer)                      ;
 570   1        return result                                           ;  
 571   1      }
 572          
 573          //******************************************************************/
 574          //功    能：扣款和充值
 575          //参数说明: dd_mode[IN]：命令字
 576          //               0xC0 = 扣款
 577          //               0xC1 = 充值
 578          //          addr[IN]：钱包地址
 579          //          pValue[IN]：4字节增(减)值，低位在前
 580          //返    回: 成功返回MI_OK
 581          //******************************************************************/
 582          sint8_t PcdValue(uint8_t dd_mode,uint8_t addr,uint8_t *pValue)
 583          {
 584   1          sint8_t status;
 585   1          uint16_t  unLen;
 586   1          uint8_t i,ucComMF522Buf[MAXRLEN]; 
 587   1          
 588   1          ucComMF522Buf[0] = dd_mode;
 589   1          ucComMF522Buf[1] = addr;
 590   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 591   1       
 592   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 593   1      
 594   1          if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
 595   1          {   status = MI_ERR;   }
 596   1              
 597   1          if (status == MI_OK)
 598   1          {
 599   2              for (i=0; i<16; i++)
 600   2              {    ucComMF522Buf[i] = *(pValue+i);   }
 601   2              CalulateCRC(ucComMF522Buf,4,&ucComMF522Buf[4]);
 602   2              unLen = 0;
 603   2              status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,6,ucComMF522Buf,&unLen);
 604   2              if (status != MI_ERR)
 605   2              {    status = MI_OK;    }
 606   2          }
 607   1          
 608   1          if (status == MI_OK)
 609   1          {
 610   2              ucComMF522Buf[0] = PICC_TRANSFER;
C51 COMPILER V9.60.0.0   MFC_MF17622                                                       05/23/2023 14:43:18 PAGE 11  

 611   2              ucComMF522Buf[1] = addr;
 612   2              CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]); 
 613   2         
 614   2              status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 615   2      
 616   2              if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
 617   2              {   status = MI_ERR;   }
 618   2          }
 619   1          return status;
 620   1      }
 621          
 622          //******************************************************************/
 623          //功    能：备份钱包
 624          //参数说明: sourceaddr[IN]：源地址
 625          //          goaladdr[IN]：目标地址
 626          //返    回: 成功返回MI_OK
 627          //******************************************************************/
 628          sint8_t PcdBakValue(uint8_t sourceaddr, uint8_t goaladdr)
 629          {
 630   1          sint8_t status;
 631   1          uint16_t  unLen;
 632   1          uint8_t ucComMF522Buf[MAXRLEN]; 
 633   1      
 634   1          ucComMF522Buf[0] = PICC_RESTORE;
 635   1          ucComMF522Buf[1] = sourceaddr;
 636   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 637   1       
 638   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 639   1      
 640   1          if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
 641   1          {   status = MI_ERR;   }
 642   1          
 643   1          if (status == MI_OK)
 644   1          {
 645   2              ucComMF522Buf[0] = 0;
 646   2              ucComMF522Buf[1] = 0;
 647   2              ucComMF522Buf[2] = 0;
 648   2              ucComMF522Buf[3] = 0;
 649   2              CalulateCRC(ucComMF522Buf,4,&ucComMF522Buf[4]);
 650   2       
 651   2              status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,6,ucComMF522Buf,&unLen);
 652   2              if (status != MI_ERR)
 653   2              {    status = MI_OK;    }
 654   2          }
 655   1          
 656   1          if (status != MI_OK)
 657   1          {    return MI_ERR;   }
 658   1          
 659   1          ucComMF522Buf[0] = PICC_TRANSFER;
 660   1          ucComMF522Buf[1] = goaladdr;
 661   1      
 662   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 663   1       
 664   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 665   1      
 666   1          if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
 667   1          {   status = MI_ERR;   }
 668   1      
 669   1          return status;
 670   1      }
 671          
 672          
C51 COMPILER V9.60.0.0   MFC_MF17622                                                       05/23/2023 14:43:18 PAGE 12  

 673          //******************************************************************/
 674          //功    能：命令卡片进入休眠状态
 675          //返    回: 成功返回MI_OK
 676          //******************************************************************/
 677          sint8_t PcdHalt(void)
 678          {
 679   1          sint8_t status;
 680   1          uint16_t  unLen;
 681   1          uint8_t ucComMF522Buf[MAXRLEN]; 
 682   1      
 683   1          ucComMF522Buf[0] = PICC_HALT;
 684   1          ucComMF522Buf[1] = 0;
 685   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 686   1       
 687   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 688   1          return status;
 689   1      //    return MI_OK;
 690   1      }
 691          
 692          //******************************************************************/
 693          //功    能：命令卡片进入休眠状态
 694          //返    回: 成功返回MI_OK
 695          //******************************************************************/
 696          sint8_t MIF_Halt(void)
 697          {
 698   1          sint8_t status;
 699   1          uint16_t  unLen;
 700   1          uint8_t ucComMF522Buf[MAXRLEN]; 
 701   1      
 702   1          ucComMF522Buf[0] = PICC_HALT;
 703   1          ucComMF522Buf[1] = 0;
 704   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 705   1       
 706   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 707   1          return status ;  
 708   1      //    return MI_OK;
 709   1      }
 710          
 711          
 712          
 713          //******************************************************************/
 714          //用MF522计算CRC16函数
 715          //******************************************************************/
 716          void CalulateCRC(uint8_t *pIndata,uint8_t len,uint8_t *pOutData)
 717          {
 718   1          uint8_t i,n;
 719   1          ClearBitMask(DivIrqReg,0x04);
 720   1          WriteRawRC(CommandReg,PCD_IDLE);
 721   1          SetBitMask(FIFOLevelReg,0x80);
 722   1          for (i=0; i<len; i++)
 723   1          {   WriteRawRC(FIFODataReg, *(pIndata+i));   }
 724   1          WriteRawRC(CommandReg, PCD_CALCCRC);
 725   1          i = 0xFF;
 726   1          do 
 727   1          {
 728   2              n = ReadRawRC(DivIrqReg);
 729   2              i--;
 730   2          }
 731   1          while ((i!=0) && !(n&0x04));
 732   1          pOutData[0] = ReadRawRC(CRCResultRegL);
 733   1          pOutData[1] = ReadRawRC(CRCResultRegM);
 734   1      }
C51 COMPILER V9.60.0.0   MFC_MF17622                                                       05/23/2023 14:43:18 PAGE 13  

 735          
 736          
 737          status_t Find_Card(void)
 738          {
 739   1      
 740   1        //sint8_t status = MI_ERR ;
 741   1        uint8_t irqEn  = 0x00    ;
 742   1        uint8_t waitFor = 0x00   ;
 743   1        //uint8_t lastBits         ;
 744   1        uint8_t n                ;
 745   1        uint16_t  i              ;
 746   1       
 747   1       //ClearBitMask(ComIrqReg,0x80);    //release IRQ PIN
 748   1        ClearBitMask(Status2Reg,0x08);
 749   1        WriteRawRC(BitFramingReg,0x07);
 750   1        SetBitMask(TxControlReg,0x03);
 751   1        Hardware_DelayMs(6);
 752   1        irqEn  = 0x20;//0x77;
 753   1        waitFor = 0x30;
 754   1      
 755   1        WriteRawRC(ComIEnReg,irqEn|0x80); //
 756   1        ClearBitMask(ComIrqReg,0x80);
 757   1        WriteRawRC(CommandReg,PCD_IDLE);
 758   1        SetBitMask(FIFOLevelReg,0x80); // 清空FIFO 
 759   1        WriteRawRC(FIFODataReg,0x52); // 数据写入FIFO 
 760   1        WriteRawRC(CommandReg, PCD_TRANSCEIVE); // 命令写入命令寄存器
 761   1      
 762   1        SetBitMask(BitFramingReg,0x80); // 开始发送  
 763   1         
 764   1        PcdAntennaOn();//开启天线发射
 765   1         
 766   1        i = 15; //根据时钟频率调整，操作M1等待时间15ms
 767   1        do 
 768   1        {
 769   2          n = ReadRawRC(ComIrqReg);
 770   2          i--;
 771   2          if (PINMACRO_NFC_IRQ_STATUS == 0 )
 772   2          {
 773   3            //PcdAntennaOff();
 774   3            return S_SUCCESS;
 775   3          }
 776   2        }
 777   1        while((i!=0)&&!(n&0x01)&&!(n&waitFor));
 778   1      
 779   1        //PcdAntennaOff();
 780   1      
 781   1        return S_FAIL;
 782   1       
 783   1      }
 784          
 785          status_t MFC_Auto_Reader(uint8_t *Point)
 786          {
 787   1        uint8_t i;
 788   1         
 789   1      //  return S_FAIL;      
 790   1        //TOUCH_SUSPEND();
 791   1        if ( Find_Card() == S_SUCCESS )
 792   1        {
 793   2          DEBUG_MARK;
 794   2          if(PcdAnticoll(UID)==MI_OK)
 795   2          {   
 796   3            DEBUG_MARK;
C51 COMPILER V9.60.0.0   MFC_MF17622                                                       05/23/2023 14:43:18 PAGE 14  

 797   3            if ( PcdSelect(UID) == MI_OK )
 798   3            {
 799   4              PcdAntennaOff();
 800   4              SetBitMask(ControlReg,0x80);// stop timer now
 801   4                WriteRawRC(CommandReg,PCD_IDLE); 
 802   4              
 803   4              for (i=0;i<4;i++)
 804   4              {
 805   5                *Point = UID[i];
 806   5                Point++;
 807   5              } 
 808   4              //TOUCH_RESUME();   
 809   4              DEBUG_MARK;
 810   4              return S_SUCCESS;
 811   4            }
 812   3          }
 813   2        }
 814   1        PcdAntennaOff();
 815   1        SetBitMask(ControlReg,0x80);// stop timer now
 816   1          WriteRawRC(CommandReg,PCD_IDLE); 
 817   1        //TOUCH_RESUME();
 818   1        return S_FAIL;
 819   1      }
 820          
 821          status_t MFC_ReadLockBrandData(uint8_t *buff)
 822          {
 823   1        uint16_t i;
 824   1        uint8_t BrandBuff[512];
 825   1        status_t TempResult;
 826   1        
 827   1        TempResult = S_FAIL;
 828   1        if ( Find_Card() == S_SUCCESS )
 829   1        {
 830   2          if(PcdAnticoll(UID)==MI_OK)
 831   2          {
 832   3            if( PcdSelect(UID)==MI_OK )
 833   3            {
 834   4              if ( Read_Block(0x04,BrandBuff) == MI_OK )  //for save identify byte
 835   4              { 
 836   5                if (   (BrandBuff[0] == 0x11)
 837   5                   &&(BrandBuff[1] == 0x55)
 838   5                   &&(BrandBuff[2] == 0xAA)
 839   5                   &&(BrandBuff[3] == 0xDD)
 840   5                   &&(BrandBuff[4] == 0xBB)
 841   5                   &&(BrandBuff[5] == 0x11)
 842   5                   &&(BrandBuff[6] == 0x55)
 843   5                   &&(BrandBuff[7] == 0xAA)
 844   5                   &&(BrandBuff[8] == 0xDD)
 845   5                   &&(BrandBuff[9] == 0xBB)
 846   5                   )
 847   5                {
 848   6                  /******* samll log, display on buttom of screen *******/
 849   6                  for ( i=0;i<7;i++)
 850   6                  {
 851   7                    if ( Read_Block(4*i+8,&BrandBuff[(2*i)*16]) != MI_OK ){
 852   8                      break;
 853   8                    }
 854   7                    if ( Read_Block(4*i+9,&BrandBuff[((2*i)+1)*16]) != MI_OK ){
 855   8                      break;
 856   8                    }
 857   7                    CLRWDT();
 858   7                  }
C51 COMPILER V9.60.0.0   MFC_MF17622                                                       05/23/2023 14:43:18 PAGE 15  

 859   6                  if ( i==7 )
 860   6                  {
 861   7                    for (i=0;i<224;i++)
 862   7                    {
 863   8                      *(buff+i)=BrandBuff[i];
 864   8                    }
 865   7                    TempResult = S_SUCCESS;
 866   7                    LockBrand.BrandType = SmallBrand;
 867   7                  }
 868   6                }
 869   5                else if (   (BrandBuff[0] == 0x12)
 870   5                   &&(BrandBuff[1] == 0x55)
 871   5                   &&(BrandBuff[2] == 0xAA)
 872   5                   &&(BrandBuff[3] == 0xDD)
 873   5                   &&(BrandBuff[4] == 0xBB)
 874   5                   &&(BrandBuff[5] == 0x12)
 875   5                   &&(BrandBuff[6] == 0x55)
 876   5                   &&(BrandBuff[7] == 0xAA)
 877   5                   &&(BrandBuff[8] == 0xDD)
 878   5                   &&(BrandBuff[9] == 0xBB)
 879   5                   )
 880   5                {
 881   6                  /******* big log, display on center of screen *******/
 882   6                  for ( i=0;i<11;i++)
 883   6                  {
 884   7                    if ( Read_Block(4*i+8,&BrandBuff[(3*i)*16]) != MI_OK ){
 885   8                      break;
 886   8                    }
 887   7                    if ( Read_Block(4*i+9,&BrandBuff[((3*i)+1)*16]) != MI_OK ){
 888   8                      break;
 889   8                    }
 890   7                    if ( i<10 )
 891   7                    {
 892   8                      if ( Read_Block(4*i+10,&BrandBuff[((3*i)+2)*16]) != MI_OK ){
 893   9                        break;
 894   9                      }
 895   8                    }
 896   7                    CLRWDT();
 897   7                  }
 898   6                  if ( i==11 )
 899   6                  {
 900   7                    for (i=0;i<512;i++)
 901   7                    {
 902   8                      *(buff+i)=BrandBuff[i];
 903   8                    }
 904   7                    TempResult = S_SUCCESS;
 905   7                    LockBrand.BrandType = BigBrand;
 906   7                  }
 907   6                } 
 908   5                else if (   (BrandBuff[0] == 0xEE)
 909   5                   &&(BrandBuff[1] == 0x55)
 910   5                   &&(BrandBuff[2] == 0xAA)
 911   5                   &&(BrandBuff[3] == 0xDD)
 912   5                   &&(BrandBuff[4] == 0xBB)
 913   5                   &&(BrandBuff[5] == 0xEE)
 914   5                   &&(BrandBuff[6] == 0x55)
 915   5                   &&(BrandBuff[7] == 0xAA)
 916   5                   &&(BrandBuff[8] == 0xDD)
 917   5                   &&(BrandBuff[9] == 0xBB)
 918   5                   )
 919   5                {
 920   6                  TempResult = S_SUCCESS;
C51 COMPILER V9.60.0.0   MFC_MF17622                                                       05/23/2023 14:43:18 PAGE 16  

 921   6                  LockBrand.BrandType = DefaultBigBrand;
 922   6                }
 923   5                else if (   (BrandBuff[0] == 0xEF)
 924   5                   &&(BrandBuff[1] == 0x55)
 925   5                   &&(BrandBuff[2] == 0xAA)
 926   5                   &&(BrandBuff[3] == 0xDD)
 927   5                   &&(BrandBuff[4] == 0xBB)
 928   5                   &&(BrandBuff[5] == 0xEF)
 929   5                   &&(BrandBuff[6] == 0x55)
 930   5                   &&(BrandBuff[7] == 0xAA)
 931   5                   &&(BrandBuff[8] == 0xDD)
 932   5                   &&(BrandBuff[9] == 0xBB)
 933   5                   )
 934   5                {
 935   6                  TempResult = S_SUCCESS;
 936   6                  LockBrand.BrandType = DefaultSmallBrand;
 937   6                }
 938   5                
 939   5              }
 940   4            }
 941   3          }
 942   2        }
 943   1      
 944   1        PcdAntennaOff();
 945   1        SetBitMask(ControlReg,0x80);// stop timer now
 946   1          WriteRawRC(CommandReg,PCD_IDLE); 
 947   1        
 948   1        return TempResult;
 949   1      }
 950          
 951          status_t MFC_FrmFunctionConfigSwitch(void)
 952          {
 953   1        //uint8_t i;
 954   1        uint8_t BrandBuff[224];
 955   1        status_t TempResult;
 956   1        
 957   1        TempResult = S_FAIL;
 958   1        if ( Find_Card() == S_SUCCESS )
 959   1        {
 960   2          if(PcdAnticoll(UID)==MI_OK)
 961   2          {
 962   3            if( PcdSelect(UID)==MI_OK )
 963   3            {
 964   4              if ( Read_Block(0x04,BrandBuff) == MI_OK )  //for save identify byte
 965   4              { 
 966   5                if (   (BrandBuff[0] == 0x22)
 967   5                   &&(BrandBuff[1] == 0x66)
 968   5                   &&(BrandBuff[2] == 0x88)
 969   5                   &&(BrandBuff[3] == 0xCC)
 970   5                   &&(BrandBuff[4] == 0x44)
 971   5                   &&(BrandBuff[5] == 0x22)
 972   5                   &&(BrandBuff[6] == 0x66)
 973   5                   &&(BrandBuff[7] == 0x88)
 974   5                   &&(BrandBuff[8] == 0xCC)
 975   5                   &&(BrandBuff[9] == 0x44)
 976   5                   )
 977   5                {
 978   6                  TempResult = S_SUCCESS;
 979   6                  
 980   6                }
 981   5              }
 982   4            }
C51 COMPILER V9.60.0.0   MFC_MF17622                                                       05/23/2023 14:43:18 PAGE 17  

 983   3          }
 984   2        }
 985   1      
 986   1        PcdAntennaOff();
 987   1        SetBitMask(ControlReg,0x80);// stop timer now
 988   1          WriteRawRC(CommandReg,PCD_IDLE); 
 989   1        
 990   1        return TempResult;
 991   1      }
 992          
 993          
 994          void MFC_POWERDOWN(void)
 995          {
 996   1        #ifdef Function_FM17622_LPCD
 997   1        if ( IfSystemIsNoCardUser() == bFALSE )   //System has card user
 998   1        {
 999   2          if ( Lpcd_Init_Register() == S_SUCCESS )
1000   2          {
1001   3            //NFC唤醒
1002   3            EnableNFCIRQ_Interrupt();
1003   3          }
1004   2        }
1005   1        #endif
1006   1        SET_MFC_RST_L;
1007   1        Hardware_DelayMs(1);
1008   1        SET_MFC_CS_H;
1009   1      }
1010          
1011          void MFC_WAKEUP(void)
1012          { 
1013   1        DisableNFCIRQ_Interrupt();
1014   1      
1015   1        SET_MFC_RST_H;
1016   1        
1017   1        Hardware_DelayMs(1);
1018   1      
1019   1        SET_MFC_CS_H;
1020   1      
1021   1        Lpcd_ClearIrq();
1022   1        
1023   1        DEBUG_MARK;
1024   1      }
1025          
1026          
1027          void MFC_Init(void)
1028          {
1029   1        PcdReset();//复位RC522
1030   1        //PcdAntennaOn();//开启天线发射 
1031   1        PcdAntennaOff();
1032   1        
1033   1        DEBUG_MARK;
1034   1      }
1035          
1036          
1037          void MFC_Test(void)
1038          {
1039   1             uint8_t i;
1040   1              TestVal = 0x00;
1041   1             DEBUG_MARK;
1042   1        TestVal = ReadRawRC(RFCfgReg);//,0x78)       ; 
1043   1        DEBUG_MARK;
1044   1        TestVal = ReadRawRC(GsNReg);//,0xFF)        ; 
C51 COMPILER V9.60.0.0   MFC_MF17622                                                       05/23/2023 14:43:18 PAGE 18  

1045   1        DEBUG_MARK;
1046   1        TestVal = ReadRawRC(CWGsCfgReg);//,0x3F)     ; 
1047   1        DEBUG_MARK;
1048   1        TestVal = ReadRawRC(ModGsCfgReg);//,0x3F)     ; 
1049   1        DEBUG_MARK;
1050   1        
1051   1        TestVal = ReadRawRC(ModeReg);//,0x3D)             ;
1052   1        DEBUG_MARK;
1053   1        TestVal = ReadRawRC(TReloadRegL);//,30)           ;
1054   1        DEBUG_MARK;
1055   1        TestVal = ReadRawRC(TReloadRegH);//,0)            ;
1056   1        DEBUG_MARK;
1057   1        
1058   1        TestVal = ReadRawRC(TModeReg);//,0x8D)            ;
1059   1        DEBUG_MARK;
1060   1        TestVal = ReadRawRC(TPrescalerReg);//,0x3E)       ;
1061   1        DEBUG_MARK;
1062   1          TestVal = ReadRawRC(TPrescalerReg);//,0x3E)       ;
1063   1        DEBUG_MARK;
1064   1          TestVal = ReadRawRC(TPrescalerReg);//,0x3E)       ;
1065   1        DEBUG_MARK;
1066   1        //PcdAntennaOn();//开启天线发射 
1067   1        //Hardware_DelayMs(1);
1068   1        //Find_Card();
1069   1        //PcdAntennaOff();
1070   1         for(i=0; i<10; i++)
1071   1          TestBuff[i]=i;
1072   1          
1073   1         for(i=0; i<10; i++)
1074   1            WriteRawRC(FIFODataReg,TestBuff[i])          ; // 数据写入FIFO 
1075   1        DEBUG_MARK;     
1076   1        for(i=0; i<10; i++)
1077   1          TestBuff[i]=0xFF;   
1078   1        DEBUG_MARK; 
1079   1        
1080   1        //i=0;  
1081   1        
1082   1        TestVal = (FIFODataReg<<1)|0x80;
1083   1        for(i=0; i<10; i++)
1084   1        {
1085   2          
1086   2          TestBuff[i] = ReadRawRC(FIFODataReg)          ; //
1087   2          /*
1088   2          SET_MFC_CS_L;
1089   2          Hardware_DelayX1us(100);
1090   2        
1091   2          HAL_SPI_Transmit(&hspi2,&TestVal,1,10);
1092   2          Hardware_DelayMs(10);
1093   2          HAL_SPI_Receive(&hspi2,&TestBuff[i],1,10);
1094   2        //  HAL_STATUS = HAL_SPI_TransmitReceive(&hspi2,&ucResult,&ReadData,1,500);
1095   2          Hardware_DelayMs(10);
1096   2          SET_MFC_CS_H;
1097   2      
1098   2        //  Hardware_DelayMs(10);
1099   2          Hardware_DelayX1us(100);
1100   2        */
1101   2        DEBUG_MARK;   
1102   2        }   
1103   1      }
1104          
1105          
1106          
C51 COMPILER V9.60.0.0   MFC_MF17622                                                       05/23/2023 14:43:18 PAGE 19  



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4262    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     52    1017
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

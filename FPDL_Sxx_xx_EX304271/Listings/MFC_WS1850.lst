C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/25/2023 17:24:16 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MFC_WS1850
OBJECT MODULE PLACED IN .\Objects\MFC_WS1850.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Drivers\Protocol\MFC_WS1850.c LARGE OMF2 OPTIMIZE(9,SPEED) BROWSE INCDIR
                    -(.\Drivers\Lib\c;.\Drivers\Lib\H;.\Drivers\Lib\IAP_Lib;.\Drivers\Lib\TouchKey_lib;.\Drivers\Physical;.\Drivers\Protocol;
                    -.\Softwares\Application;.\Softwares\Basic;.\Softwares\ModuleLogic) DEBUG PRINT(.\Listings\MFC_WS1850.lst) TABS(2) OBJECT
                    -(.\Objects\MFC_WS1850.obj)

line level    source

   1          #include "IO.h"
   2          #include "I2cBus.h"
   3          #include "StdTypes.h"
   4          #include "Basic_Function.h"
   5          
   6          #define MAXRLEN        18
   7          #define MIN_STRENGTH  228
   8          //******************************************************************/
   9          //                    RC522 FIFO长度定义                            /
  10          //******************************************************************/
  11          #define DEF_FIFO_LENGTH             64           //FIFO size=64byte
  12          
  13          //******************************************************************/
  14          //                       RC522命令字                                /
  15          //******************************************************************/
  16          #define PCD_SLEEP                 0x10           //取消当前命令
  17          #define PCD_IDLE                  0x00           //取消当前命令
  18          #define PCD_AUTHENT               0x0E           //验证密钥
  19          #define PCD_RECEIVE               0x08           //接收数据
  20          #define PCD_TRANSMIT              0x04           //发送数据
  21          #define PCD_TRANSCEIVE            0x0C           //发送并接收数据
  22          #define PCD_RESETPHASE            0x0F           //复位
  23          #define PCD_CALCCRC               0x03           //CRC计算
  24          
  25          //******************************************************************/
  26          //                   Mifare_One卡片命令字                          */
  27          //******************************************************************/
  28          #define PICC_REQIDL               0x26           //寻天线区内未进入休眠状态
  29          #define PICC_REQALL               0x52           //寻天线区内全部卡
  30          #define PICC_ANTICOLL1            0x93           //防冲撞
  31          #define PICC_ANTICOLL2            0x95           //防冲撞
  32          #define PICC_AUTHENT1A            0x60           //验证A密钥
  33          #define PICC_AUTHENT1B            0x61           //验证B密钥
  34          #define PICC_READ                 0x30           //读块
  35          #define PICC_WRITE                0xA0           //写块
  36          #define PICC_DECREMENT            0xC0           //扣款
  37          #define PICC_INCREMENT            0xC1           //充值
  38          #define PICC_RESTORE              0xC2           //调块数据到缓冲区
  39          #define PICC_TRANSFER             0xB0           //保存缓冲区中数据
  40          #define PICC_HALT                 0x50           //休眠
  41          
  42          //******************************************************************/
  43          //                        MF522寄存器定义                           /
  44          //******************************************************************/
  45          // PAGE 0
  46          #define     RFU00                 0x00    
  47          #define     CommandReg            0x01    
  48          #define     ComIEnReg             0x02    
  49          #define     DivlEnReg             0x03    
  50          #define     ComIrqReg             0x04    
  51          #define     DivIrqReg             0x05
  52          #define     ErrorReg              0x06    
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/25/2023 17:24:16 PAGE 2   

  53          #define     Status1Reg            0x07    
  54          #define     Status2Reg            0x08    
  55          #define     FIFODataReg           0x09
  56          #define     FIFOLevelReg          0x0A
  57          #define     WaterLevelReg         0x0B
  58          #define     ControlReg            0x0C
  59          #define     BitFramingReg         0x0D
  60          #define     CollReg               0x0E
  61          #define     RFU0F                 0x0F
  62          // PAGE 1     
  63          #define     RFU10                 0x10
  64          #define     ModeReg               0x11
  65          #define     TxModeReg             0x12
  66          #define     RxModeReg             0x13
  67          #define     TxControlReg          0x14
  68          #define     TxASKReg              0x15
  69          #define     TxSelReg              0x16
  70          #define     RxSelReg              0x17
  71          #define     RxThresholdReg        0x18
  72          #define     DemodReg              0x19
  73          #define     RFU1A                 0x1A
  74          #define     RFU1B                 0x1B
  75          #define     MifareReg             0x1C
  76          #define     RFU1D                 0x1D
  77          #define     RFU1E                 0x1E
  78          #define     SerialSpeedReg        0x1F
  79          // PAGE 2    
  80          #define     RFU20                 0x20  
  81          #define     CRCResultRegM         0x21
  82          #define     CRCResultRegL         0x22
  83          #define     RFU23                 0x23
  84          #define     ModWidthReg           0x24
  85          #define     RFU25                 0x25
  86          #define     RFCfgReg              0x26
  87          #define     GsNReg                0x27
  88          #define     CWGsCfgReg            0x28
  89          #define     ModGsCfgReg           0x29
  90          #define     TModeReg              0x2A
  91          #define     TPrescalerReg         0x2B
  92          #define     TReloadRegH           0x2C
  93          #define     TReloadRegL           0x2D
  94          #define     TCounterValueRegH     0x2E
  95          #define     TCounterValueRegL     0x2F
  96          // PAGE 3      
  97          #define     RFU30                 0x30
  98          #define     TestSel1Reg           0x31
  99          #define     TestSel2Reg           0x32
 100          #define     TestPinEnReg          0x33
 101          #define     TestPinValueReg       0x34
 102          #define     TestBusReg            0x35
 103          #define     AutoTestReg           0x36
 104          #define     VersionReg            0x37
 105          #define     AnalogTestReg         0x38
 106          #define     TestDAC1Reg           0x39  
 107          #define     TestDAC2Reg           0x3A   
 108          #define     TestADCReg            0x3B   
 109          #define     RFU3C                 0x3C   
 110          #define     RFU3D                 0x3D   
 111          #define     RFU3E                 0x3E   
 112          #define     RFU3F                 0x3F
 113          
 114          //******************************************************************/
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/25/2023 17:24:16 PAGE 3   

 115          //                    RC522通讯返回错误代码                         /
 116          //******************************************************************/
 117          #define MI_ERR                      0xFE 
 118          //#define MI_ERR                         //(-2)
 119          
 120          
 121          // Mifare Error Codes 
 122          // Each function returns a status value, which corresponds to the 
 123          // mifare error codes. 
 124          
 125          #define MI_OK                          0 
 126          #define MI_CHK_OK                      0 
 127          #define MI_CRC_ZERO                    0 
 128          
 129          #define MI_CRC_NOTZERO                 1 
 130          
 131          #define MI_NOTAGERR                 0xFF 
 132          #define MI_CHK_S_FAILED             0xFF 
 133          #define MI_CRCERR                   0xFE 
 134          #define MI_CHK_COMPERR              0xFE 
 135          #define MI_EMPTY                    0xFD 
 136          #define MI_AUTHERR                  0xFC 
 137          #define MI_PARITYERR                0xFB 
 138          #define MI_CODEERR                  0xFA 
 139          
 140          #define MI_SERNRERR                 0xF8 
 141          #define MI_KEYERR                   0xF7 
 142          #define MI_NOTAUTHERR               0xF6 
 143          #define MI_BITCOUNTERR              0xF5 
 144          #define MI_BYTECOUNTERR             0xF4 
 145          #define MI_IDLE                     0xF3 
 146          #define MI_TRANSERR                 0xF2 
 147          #define MI_WRITEERR                 0xF1 
 148          #define MI_INCRERR                  0xF0 
 149          #define MI_DECRERR                  0xEF 
 150          #define MI_READERR                  0xEE 
 151          #define MI_OVFLERR                  0xED 
 152          #define MI_POLLING                  0xEC 
 153          #define MI_FRAMINGERR               0xEB 
 154          #define MI_ACCESSERR                0xEA 
 155          #define MI_UNKNOWN_COMMAND          0xE9 
 156          #define MI_COLLERR                  0xE8 
 157          #define MI_RESETERR                 0xE7 
 158          #define MI_INITERR                  0xE7 
 159          #define MI_INTERFACEERR             0xE7 
 160          #define MI_ACCESSTIMEOUT            0xE5 
 161          #define MI_NOBITWISEANTICOLL        0xE4 
 162          #define MI_QUIT                     0xE2 
 163          
 164          #define MI_RECBUF_OVERFLOW          0xCF 
 165          #define MI_SENDBYTENR               0xCE 
 166          
 167          #define MI_SENDBUF_OVERFLOW         0xCC 
 168          #define MI_BAUDRATE_NOT_SUPPORTED   0xCB 
 169          #define MI_SAME_BAUDRATE_REQUIRED   0xCA 
 170          
 171          #define MI_WRONG_PARAMETER_VALUE    0xC5 
 172          
 173          #define MI_BREAK                    0x9E 
 174          #define MI_NY_IMPLEMENTED           0x9D 
 175          #define MI_NO_MFRC                  0x9C 
 176          #define MI_MFRC_NOTAUTH             0x9B 
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/25/2023 17:24:16 PAGE 4   

 177          #define MI_WRONG_DES_MODE           0x9A 
 178          #define MI_HOST_AUTH_S_FAILED         0x99 
 179          
 180          #define MI_WRONG_LOAD_MODE          0x97 
 181          #define MI_WRONG_DESKEY             0x96 
 182          #define MI_MKLOAD_S_FAILED            0x95 
 183          #define MI_FIFOERR                  0x94 
 184          #define MI_WRONG_ADDR               0x93 
 185          #define MI_DESKEYLOAD_S_FAILED        0x92 
 186          
 187          #define MI_WRONG_SEL_CNT            0x8F 
 188          #define MI_RC531_WRONG_READVALUE    0x8E //LI ADDED 09-4-24 
 189          #define MI_WRONG_TEST_MODE          0x8C 
 190          #define MI_TEST_S_FAILED              0x8B 
 191          #define MI_TOC_ERROR                0x8A 
 192          #define MI_COMM_ABORT               0x89 
 193          #define MI_INVALID_BASE             0x88 
 194          #define MI_MFRC_RESET               0x87 
 195          #define MI_WRONG_VALUE              0x86 
 196          #define MI_VALERR                   0x85
 197          //******************************************************************/
 198          //                         函数定义                                 /
 199          //******************************************************************/
 200          sint8_t PcdHalt(void);
 201          sint8_t PcdReset(void);
 202          void PcdAntennaOn(void);
 203          void PcdAntennaOff(void);
 204          sint8_t PcdRequest(uint8_t req_code,uint8_t *pTagType);   
 205          sint8_t PcdAnticoll(uint8_t *pSnr);
 206          sint8_t PcdSelect(uint8_t *pSnr);
 207          sint8_t PcdAuthState(uint8_t auth_mode,uint8_t addr,
 208                            uint8_t *pKey,uint8_t *pSnr);     
 209          sint8_t PcdRead(uint8_t addr,uint8_t *pData);     
 210          sint8_t PcdWrite(uint8_t addr,uint8_t *pData);    
 211          sint8_t PcdValue(uint8_t dd_mode,uint8_t addr,uint8_t *pValue);   
 212          sint8_t PcdBakValue(uint8_t sourceaddr, uint8_t goaladdr);                                 
 213          sint8_t PcdComMF522(uint8_t Command, uint8_t *pInData, 
 214                           uint8_t InLenByte,uint8_t *pOutData, 
 215                           uint16_t  *pOutLenBit);
 216          void CalulateCRC(uint8_t *pIndata,uint8_t len,
 217                           uint8_t *pOutData);
 218          void WriteRawRC(uint8_t Address,uint8_t value);
 219          uint8_t ReadRawRC(uint8_t Address); 
 220          void SetBitMask(uint8_t reg,uint8_t mask); 
 221          void ClearBitMask(uint8_t reg,uint8_t mask); 
 222          sint8_t Read_Block(uint8_t Block,uint8_t *Buf);
 223          sint8_t Write_Block(uint8_t Block);
 224          void PcdAntennaTestOn(void);
 225          
 226          extern sint8_t KK[8]; // 数据加密密钥
 227          static uint8_t RF_Buffer[18]; // 射频卡数据缓冲区
 228          static uint8_t UID[5];
 229          static uint8_t Password_Buffer[6]={0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
 230          //extern void Des_Encrypt(sint8_t* In, sint8_t* K,sint8_t* Out);
 231          //extern void Des_Decrypt(sint8_t* In, sint8_t* K,sint8_t* Out);
 232          static uint8_t des_on; // DES加密标志
 233          
 234          static uint8_t TestVal;
 235          static uint8_t TestBuff[20];
 236          
 237          static uint8_t HAL_SPI2_RXBUFF;
 238          #ifdef Function_CardReaderUseSPI
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/25/2023 17:24:16 PAGE 5   

              //******************************************************************/
              //功    能：读RC522寄存器
              //参数说明：Address[IN]:寄存器地址
              //返    回：读出的值
              //******************************************************************/
              uint8_t ReadRawRC(uint8_t Address)
              {
                uint8_t ucResult;
                HAL_StatusTypeDef HAL_STATUS;
                
                SET_MFC_CS_L;
                Hardware_DelayX1us(10);
              //  Hardware_DelayMs(10);
                ucResult = (Address<<1)|0x80;
                
                HAL_STATUS = HAL_SPI_Transmit(&hspi1,&ucResult,1,10);
                HAL_STATUS = HAL_SPI_Receive(&hspi1,&HAL_SPI2_RXBUFF,1,10);
                SET_MFC_CS_H;
              
              //  Hardware_DelayMs(10);
                Hardware_DelayX1us(10);
                return HAL_SPI2_RXBUFF;
              }
              
              //******************************************************************/
              //功    能：写RC522寄存器
              //参数说明：Address[IN]:寄存器地址
              //          value[IN]:写入的值
              //******************************************************************/
              void  WriteRawRC(uint8_t Address, uint8_t value)
              {
                uint8_t temp;
                HAL_StatusTypeDef HAL_STATUS;
                
                SET_MFC_CS_L;
                Hardware_DelayX1us(10);
                
                temp = Address<<1;
                HAL_STATUS = HAL_SPI_Transmit(&hspi1,&temp,1,500);
                HAL_STATUS = HAL_SPI_Transmit(&hspi1,&value,1,500);
                SET_MFC_CS_H;
                //Hardware_DelayX1us(100);
              }
              
              #else
 284          uint8_t ReadRawRC(uint8_t Address)
 285          {
 286   1        uint8_t ucResult;
 287   1        I2C_ReadRandom(I2CADDR_MFC,Address,&ucResult);
 288   1        return ucResult;
 289   1      }
 290          void WriteRawRC(uint8_t Address, uint8_t value)
 291          {  
 292   1        I2C_WriteRandom(I2CADDR_MFC,Address,value);
 293   1      }
 294          #endif
 295          
 296          //******************************************************************/
 297          //功    能：置RC522寄存器位
 298          //参数说明：reg[IN]:寄存器地址
 299          //          mask[IN]:置位值
 300          //******************************************************************/
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/25/2023 17:24:16 PAGE 6   

 301          void SetBitMask(uint8_t reg,uint8_t mask)  
 302          {
 303   1        sint8_t tmp = 0x00;
 304   1        tmp = ReadRawRC(reg)| mask;
 305   1        WriteRawRC(reg, tmp);  // set bit mask
 306   1      }
 307          
 308          //******************************************************************/
 309          //功    能：清RC522寄存器位
 310          //参数说明：reg[IN]:寄存器地址
 311          //          mask[IN]:清位值
 312          //******************************************************************/
 313          void ClearBitMask(uint8_t reg,uint8_t mask)  
 314          {
 315   1        sint8_t tmp = 0x00;
 316   1        tmp = ReadRawRC(reg)&(~mask);
 317   1        WriteRawRC(reg, tmp)        ;  // clear bit mask
 318   1      } 
 319          
 320          //******************************************************************/
 321          //功    能：复位RC522
 322          //返    回: 成功返回MI_OK
 323          //******************************************************************/
 324          sint8_t PcdReset(void)
 325          {
 326   1        //SET_MFC_RST_H;
 327   1        //Hardware_DelayMs(1);
 328   1        SET_MFC_RST_L;
 329   1        Hardware_DelayX1us(10);
 330   1        SET_MFC_RST_H;
 331   1        Hardware_DelayX1us(50);
 332   1        
 333   1        WriteRawRC(CommandReg,PCD_RESETPHASE);
 334   1        Hardware_DelayMs(5);
 335   1        
 336   1        WriteRawRC(RFCfgReg,0x48)       ; 
 337   1        /* 增益调整 GsN前后两位独立 CWGsCfg最大0x3F ModGsCfg最大0x3F*/
 338   1        WriteRawRC(GsNReg,0xFF); 
 339   1        WriteRawRC(CWGsCfgReg,0x3F); 
 340   1        WriteRawRC(ModGsCfgReg,0x3F); 
 341   1        
 342   1        
 343   1        WriteRawRC(ModeReg,0x3D);
 344   1        WriteRawRC(TReloadRegL,30);
 345   1        WriteRawRC(TReloadRegH,0);
 346   1        
 347   1        WriteRawRC(TModeReg,0x8D);
 348   1        WriteRawRC(TPrescalerReg,0x3E);  
 349   1          
 350   1      //  WriteRawRC(TxASKReg,0x40)            ; // FOR DEBUG AND TEST
 351   1        return MI_OK; 
 352   1      }
 353          
 354          //******************************************************************/
 355          //开启天线发射  
 356          //每次启动或关闭天险发射之间应至少有1ms的间隔
 357          //******************************************************************/
 358          void PcdAntennaOn(void)
 359          {
 360   1        //uint8_t i;
 361   1        /*
 362   1        WriteRawRC(TxASKReg,0x40)       ;
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/25/2023 17:24:16 PAGE 7   

 363   1        Hardware_DelayMs(3)            ;
 364   1        i = ReadRawRC(TxControlReg)     ;
 365   1        if(!(i&0x03))
 366   1          SetBitMask(TxControlReg, 0x03);
 367   1        i=ReadRawRC(TxASKReg)       ;
 368   1        */
 369   1        WriteRawRC(TxASKReg,0x40)       ;
 370   1        SetBitMask(TxControlReg, 0x03);
 371   1      }
 372          
 373          //******************************************************************/
 374          //开启天线发射  
 375          //每次启动或关闭天险发射之间应至少有1ms的间隔
 376          //******************************************************************/
 377          void PcdAntennaTestOn(void)
 378          {
 379   1      //*
 380   1        SET_MFC_RST_H                         ;
 381   1        Hardware_DelayMs(15); // 2010.10.09 ???? FOR DEBUG
 382   1        
 383   1        WriteRawRC(TxControlReg,0x02)    ;
 384   1      }
 385          
 386          
 387          //******************************************************************/
 388          //关闭天线发射
 389          //******************************************************************/
 390          void PcdAntennaOff(void)
 391          {
 392   1        //return;
 393   1          ClearBitMask(TxControlReg, 0x03);
 394   1      }
 395          
 396          //******************************************************************/
 397          //功    能：通过RC522和ISO14443卡通讯
 398          //参数说明：Command[IN]:RC522命令字
 399          //          pInData[IN]:通过RC522发送到卡片的数据
 400          //          InLenByte[IN]:发送数据的字节长度
 401          //          pOutData[OUT]:接收到的卡片返回数据
 402          //          *pOutLenBit[OUT]:返回数据的位长度
 403          //******************************************************************/
 404          sint8_t PcdComMF522(uint8_t Command  ,uint8_t *pInData , 
 405                           uint8_t InLenByte,uint8_t *pOutData, 
 406                           uint16_t  *pOutLenBit                       )
 407          {
 408   1        sint8_t status = MI_ERR                          ;
 409   1        uint8_t irqEn   = 0x00                  ;
 410   1        uint8_t waitFor = 0x00                  ;
 411   1        uint8_t lastBits                        ;
 412   1        uint8_t n                               ;
 413   1        uint16_t  i                               ;
 414   1        switch (Command)
 415   1        {
 416   2          case PCD_AUTHENT:
 417   2            irqEn   = 0x12                            ;
 418   2            waitFor = 0x10                            ;
 419   2            break                                     ;
 420   2          case PCD_TRANSCEIVE:
 421   2            irqEn   = 0x20;//0x77                            ;
 422   2            waitFor = 0x30                            ;
 423   2            break                                     ;
 424   2          default:
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/25/2023 17:24:16 PAGE 8   

 425   2            break                                     ;
 426   2        }
 427   1        WriteRawRC(ComIEnReg,irqEn|0x80)              ; //
 428   1        ClearBitMask(ComIrqReg,0x80)                  ;
 429   1        WriteRawRC(CommandReg,PCD_IDLE)               ;
 430   1        SetBitMask(FIFOLevelReg,0x80)                 ; // 清空FIFO 
 431   1        for(i=0; i<InLenByte; i++)
 432   1          WriteRawRC(FIFODataReg,pInData[i])          ; // 数据写入FIFO 
 433   1        WriteRawRC(CommandReg, Command)               ; // 命令写入命令寄存器
 434   1        if(Command == PCD_TRANSCEIVE)
 435   1          SetBitMask(BitFramingReg,0x80)              ; // 开始发送     
 436   1        
 437   1        PcdAntennaOn()                                ;//开启天线发射
 438   1        
 439   1        i = 100                                       ; //根据时钟频率调整，操作M1等待时间15ms
 440   1        do 
 441   1        {
 442   2          n = ReadRawRC(ComIrqReg)                    ;
 443   2          i--                                         ;
 444   2        }
 445   1        while((i!=0)&&!(n&0x01)&&!(n&waitFor))        ;
 446   1        ClearBitMask(BitFramingReg,0x80)              ;
 447   1        if(i!=0)
 448   1        {
 449   2          if(!(ReadRawRC(ErrorReg)&0x1B))
 450   2          {
 451   3            status = MI_OK                            ;
 452   3            if (n&irqEn&0x01)
 453   3              status = MI_NOTAGERR                    ;
 454   3            if(Command==PCD_TRANSCEIVE)
 455   3            {
 456   4              n = ReadRawRC(FIFOLevelReg)             ;
 457   4              lastBits = ReadRawRC(ControlReg)&0x07   ;
 458   4              if(lastBits)
 459   4                *pOutLenBit = (n-1)*8 + lastBits      ;
 460   4              else
 461   4                *pOutLenBit = n*8                     ;
 462   4              if(n==0)
 463   4                n = 1                                 ;
 464   4              if(n>MAXRLEN)
 465   4                n = MAXRLEN                           ;
 466   4              
 467   4             for (i=0; i<n; i++)
 468   4              { 
 469   5                pOutData[i]= ReadRawRC(FIFODataReg)  ; 
 470   5              }
 471   4              
 472   4              DEBUG_MARK;
 473   4            }
 474   3          }
 475   2          else
 476   2            status = MI_ERR;        
 477   2        }
 478   1        else{
 479   2          PcdAntennaOff();
 480   2        }
 481   1        SetBitMask(ControlReg,0x80);// stop timer now
 482   1        WriteRawRC(CommandReg,PCD_IDLE); 
 483   1        return status;
 484   1      }
 485          
 486          //******************************************************************/
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/25/2023 17:24:16 PAGE 9   

 487          //功    能：寻卡                                                    /
 488          //参数说明: req_code[IN]:寻卡方式                                   /
 489          //                0x52 = 寻感应区内所有符合14443A标准的卡           /
 490          //                0x26 = 寻未进入休眠状态的卡                       /
 491          //          pTagType[OUT]：卡片类型代码                             /
 492          //                0x4400 = Mifare_UltraLight                        /
 493          //                0x0400 = Mifare_One(S50)                          /
 494          //                0x0200 = Mifare_One(S70)                          /
 495          //                0x0800 = Mifare_Pro(X)                            /
 496          //                0x4403 = Mifare_DESFire                           /
 497          //返    回: 成功返回MI_OK                                           /
 498          //******************************************************************/
 499          sint8_t PcdRequest(uint8_t req_code,uint8_t *pTagType)
 500          {
 501   1        sint8_t status;  
 502   1        uint16_t  unLen;
 503   1        uint8_t ucComMF522Buf[MAXRLEN]; 
 504   1      
 505   1        ClearBitMask(Status2Reg,0x08);
 506   1        WriteRawRC(BitFramingReg,0x07);
 507   1        SetBitMask(TxControlReg,0x03);
 508   1       
 509   1        ucComMF522Buf[0] = req_code;
 510   1      
 511   1        status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,
 512   1                             1,ucComMF522Buf,&unLen);
 513   1        if ((status == MI_OK) && (unLen == 0x10))
 514   1        {    
 515   2          *pTagType     = ucComMF522Buf[0];
 516   2          *(pTagType+1) = ucComMF522Buf[1];
 517   2        }
 518   1        else
 519   1          status = MI_ERR;
 520   1        return status;
 521   1      }
 522          
 523          //******************************************************************/
 524          //功    能：防冲撞                                                  /
 525          //参数说明: pSnr[OUT]:卡片序列号，4字节                             /
 526          //返    回: 成功返回MI_OK                                           /
 527          //******************************************************************/
 528          sint8_t PcdAnticoll(uint8_t *pSnr)
 529          {
 530   1          sint8_t status;
 531   1          uint8_t i,snr_check=0;
 532   1          uint16_t  unLen;
 533   1          uint8_t ucComMF522Buf[MAXRLEN]; 
 534   1          
 535   1        //return MI_OK;
 536   1        
 537   1          ClearBitMask(Status2Reg,0x08);
 538   1          WriteRawRC(BitFramingReg,0x00);
 539   1          ClearBitMask(CollReg,0x80);
 540   1       
 541   1          ucComMF522Buf[0] = PICC_ANTICOLL1;
 542   1          ucComMF522Buf[1] = 0x20;
 543   1      
 544   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
 545   1      
 546   1          if (status == MI_OK)
 547   1          {
 548   2             for (i=0; i<4; i++)
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/25/2023 17:24:16 PAGE 10  

 549   2               {   
 550   3                   *(pSnr+i)  = ucComMF522Buf[i];
 551   3                   snr_check ^= ucComMF522Buf[i];
 552   3                 TestVal = snr_check;
 553   3               }
 554   2               if (snr_check != ucComMF522Buf[i])
 555   2               {   status = MI_ERR;    }
 556   2          }
 557   1          
 558   1          SetBitMask(CollReg,0x80);
 559   1          return status;
 560   1      }
 561          
 562          /////////////////////////////////////////////////////////////////////
 563          //功    能：选定卡片
 564          //参数说明: pSnr[IN]:卡片序列号，4字节
 565          //返    回: 成功返回MI_OK
 566          /////////////////////////////////////////////////////////////////////
 567          sint8_t PcdSelect(uint8_t *pSnr)
 568          {
 569   1          sint8_t status;
 570   1          uint8_t i;
 571   1          uint16_t  unLen;
 572   1          uint8_t ucComMF522Buf[MAXRLEN]; 
 573   1          
 574   1          ucComMF522Buf[0] = PICC_ANTICOLL1;
 575   1          ucComMF522Buf[1] = 0x70;
 576   1          ucComMF522Buf[6] = 0;
 577   1          for (i=0; i<4; i++)
 578   1          {
 579   2            ucComMF522Buf[i+2] = *(pSnr+i);
 580   2            ucComMF522Buf[6]  ^= *(pSnr+i);
 581   2          }
 582   1          CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
 583   1        
 584   1          ClearBitMask(Status2Reg,0x08);
 585   1      
 586   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
 587   1          
 588   1          if ((status == MI_OK) && (unLen == 0x18))
 589   1          {   status = MI_OK;  }
 590   1          else
 591   1          {   status = MI_ERR;    }
 592   1      
 593   1          return status;
 594   1      }
 595          
 596          //******************************************************************/
 597          //功    能：验证卡片密码
 598          //参数说明: auth_mode[IN]: 密码验证模式
 599          //                 0x60 = 验证A密钥
 600          //                 0x61 = 验证B密钥 
 601          //          addr[IN]：块地址
 602          //          pKey[IN]：密码
 603          //          pSnr[IN]：卡片序列号，4字节
 604          //返    回: 成功返回MI_OK
 605          //******************************************************************/
 606          sint8_t PcdAuthState(uint8_t auth_mode,uint8_t addr,
 607                            uint8_t *pKey,uint8_t *pSnr    )
 608          {
 609   1          sint8_t status;
 610   1          uint16_t  unLen;
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/25/2023 17:24:16 PAGE 11  

 611   1          uint8_t i,ucComMF522Buf[MAXRLEN]; 
 612   1      
 613   1          ucComMF522Buf[0] = auth_mode;
 614   1          ucComMF522Buf[1] = addr;
 615   1          for (i=0; i<6; i++)
 616   1          {    ucComMF522Buf[i+2] = *(pKey+i);   }
 617   1          for (i=0; i<6; i++)
 618   1          {    ucComMF522Buf[i+8] = *(pSnr+i);   }
 619   1          
 620   1          status = PcdComMF522(PCD_AUTHENT,ucComMF522Buf,12,ucComMF522Buf,&unLen);
 621   1          if ((status != MI_OK) || (!(ReadRawRC(Status2Reg) & 0x08)))
 622   1          {   status = MI_ERR;   }
 623   1          
 624   1          return status;
 625   1      }
 626          
 627          //******************************************************************/
 628          //功    能：读取M1卡一块数据
 629          //参数说明: addr[IN]：块地址
 630          //          pData[OUT]：读出的数据，16字节
 631          //返    回: 成功返回MI_OK
 632          //******************************************************************/
 633          sint8_t PcdRead(uint8_t addr,uint8_t *pData)
 634          {
 635   1          sint8_t status                                          ;
 636   1          uint16_t  unLen                                  ;
 637   1          uint8_t i;uint8_t ucComMF522Buf[MAXRLEN]               ; 
 638   1      
 639   1          ucComMF522Buf[0] = PICC_READ                         ;
 640   1          ucComMF522Buf[1] = addr                              ;
 641   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2])       ;   
 642   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,
 643   1                               ucComMF522Buf,&unLen           );
 644   1          if ((status == MI_OK) && (unLen == 0x90))
 645   1          {
 646   2              for (i=0; i<16; i++)
 647   2                  *(pData+i) = ucComMF522Buf[i];   
 648   2          }
 649   1          else
 650   1            status = MI_ERR;       
 651   1          return status;
 652   1      }
 653          
 654          //******************************************************************/
 655          //功    能：读取M1卡一块数据
 656          //参数说明: addr[IN]：块地址
 657          //          pData[OUT]：读出的数据，16字节
 658          //返    回: 成功返回MI_OK
 659          //******************************************************************/
 660          sint8_t Read_Block(uint8_t Block,uint8_t *Buf)
 661          {
 662   1        sint8_t result                                          ;
 663   1      
 664   1        result = PcdAuthState(0x60,Block,Password_Buffer,UID)   ;
 665   1        if(result!=MI_OK)
 666   1          return result                                         ;
 667   1        result = PcdRead(Block,Buf)                             ;
 668   1      //  return result; // 2011.01.03
 669   1        
 670   1        if(result!=MI_OK)     return   result                   ;
 671   1        if(Block!=0x00&&des_on)
 672   1        {
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/25/2023 17:24:16 PAGE 12  

 673   2          /*
 674   2          Des_Decrypt((sint8_t *)Buf,KK,(sint8_t *)Buf);
 675   2          Des_Decrypt((sint8_t *)&Buf[8],KK,(sint8_t *)&Buf[8]);  
 676   2          */
 677   2        }
 678   1        return MI_OK                                            ; 
 679   1      }
 680          
 681          //******************************************************************/
 682          //功    能：写数据到M1卡一块
 683          //参数说明: addr[IN]：块地址
 684          //          pData[IN]：写入的数据，16字节
 685          //返    回: 成功返回MI_OK
 686          //******************************************************************/
 687          sint8_t PcdWrite(uint8_t addr,uint8_t *pData)
 688          {
 689   1        sint8_t status                                          ;
 690   1        uint16_t  unLen                                     ;
 691   1        uint8_t i;uint8_t ucComMF522Buf[MAXRLEN]                ; 
 692   1          
 693   1        ucComMF522Buf[0] = PICC_WRITE                           ;
 694   1        ucComMF522Buf[1] = addr                                 ;
 695   1        CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2])          ;
 696   1        status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,
 697   1                             ucComMF522Buf,&unLen          )    ;
 698   1        if(  ( status != MI_OK)||(unLen != 4)
 699   1           ||((ucComMF522Buf[0]&0x0F)!= 0x0A))
 700   1          status = MI_ERR                                       ;           
 701   1        if (status == MI_OK)
 702   1        {
 703   2          for (i=0; i<16; i++)
 704   2            ucComMF522Buf[i] = *(pData+i)                       ;  
 705   2          CalulateCRC(ucComMF522Buf,16,&ucComMF522Buf[16])      ;
 706   2          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,
 707   2                               18,ucComMF522Buf,&unLen     )    ;
 708   2          if(  (status != MI_OK)||(unLen != 4 )
 709   2             ||((ucComMF522Buf[0]&0x0F)!= 0x0A))
 710   2            status = MI_ERR                                     ;   
 711   2        }    
 712   1        return status                                           ;
 713   1      }
 714          //******************************************************************/
 715          //功    能：写数据到M1卡一块
 716          //参数说明: addr[IN]：块地址
 717          //          pData[IN]：写入的数据，16字节
 718          //返    回: 成功返回MI_OK
 719          //******************************************************************/
 720          
 721          sint8_t Write_Block(uint8_t Block)
 722          {
 723   1        sint8_t result                                          ;
 724   1        if(des_on)
 725   1        {
 726   2      /*    Des_Encrypt((sint8_t *)RF_Buffer    ,KK,
 727   2                      (sint8_t *)RF_Buffer        )                ;// for debug
 728   2          Des_Encrypt((sint8_t *)&RF_Buffer[8],KK,
 729   2                      (sint8_t *)&RF_Buffer[8]    )                ;// for debug  
 730   2      */                
 731   2        }
 732   1        result = PcdAuthState(0x60,Block,Password_Buffer,UID)   ;
 733   1        if(result!=MI_OK)
 734   1          return result                                         ;  
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/25/2023 17:24:16 PAGE 13  

 735   1        result = PcdWrite(Block,RF_Buffer)                      ;
 736   1        return result                                           ;  
 737   1      }
 738          
 739          //******************************************************************/
 740          //功    能：扣款和充值
 741          //参数说明: dd_mode[IN]：命令字
 742          //               0xC0 = 扣款
 743          //               0xC1 = 充值
 744          //          addr[IN]：钱包地址
 745          //          pValue[IN]：4字节增(减)值，低位在前
 746          //返    回: 成功返回MI_OK
 747          //******************************************************************/
 748          sint8_t PcdValue(uint8_t dd_mode,uint8_t addr,uint8_t *pValue)
 749          {
 750   1          sint8_t status;
 751   1          uint16_t  unLen;
 752   1          uint8_t i,ucComMF522Buf[MAXRLEN]; 
 753   1          
 754   1          ucComMF522Buf[0] = dd_mode;
 755   1          ucComMF522Buf[1] = addr;
 756   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 757   1       
 758   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 759   1      
 760   1          if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
 761   1          {   status = MI_ERR;   }
 762   1              
 763   1          if (status == MI_OK)
 764   1          {
 765   2              for (i=0; i<16; i++)
 766   2              {    ucComMF522Buf[i] = *(pValue+i);   }
 767   2              CalulateCRC(ucComMF522Buf,4,&ucComMF522Buf[4]);
 768   2              unLen = 0;
 769   2              status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,6,ucComMF522Buf,&unLen);
 770   2              if (status != MI_ERR)
 771   2              {    status = MI_OK;    }
 772   2          }
 773   1          
 774   1          if (status == MI_OK)
 775   1          {
 776   2              ucComMF522Buf[0] = PICC_TRANSFER;
 777   2              ucComMF522Buf[1] = addr;
 778   2              CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]); 
 779   2         
 780   2              status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 781   2      
 782   2              if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
 783   2              {   status = MI_ERR;   }
 784   2          }
 785   1          return status;
 786   1      }
 787          
 788          //******************************************************************/
 789          //功    能：备份钱包
 790          //参数说明: sourceaddr[IN]：源地址
 791          //          goaladdr[IN]：目标地址
 792          //返    回: 成功返回MI_OK
 793          //******************************************************************/
 794          sint8_t PcdBakValue(uint8_t sourceaddr, uint8_t goaladdr)
 795          {
 796   1          sint8_t status;
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/25/2023 17:24:16 PAGE 14  

 797   1          uint16_t  unLen;
 798   1          uint8_t ucComMF522Buf[MAXRLEN]; 
 799   1      
 800   1          ucComMF522Buf[0] = PICC_RESTORE;
 801   1          ucComMF522Buf[1] = sourceaddr;
 802   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 803   1       
 804   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 805   1      
 806   1          if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
 807   1          {   status = MI_ERR;   }
 808   1          
 809   1          if (status == MI_OK)
 810   1          {
 811   2              ucComMF522Buf[0] = 0;
 812   2              ucComMF522Buf[1] = 0;
 813   2              ucComMF522Buf[2] = 0;
 814   2              ucComMF522Buf[3] = 0;
 815   2              CalulateCRC(ucComMF522Buf,4,&ucComMF522Buf[4]);
 816   2       
 817   2              status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,6,ucComMF522Buf,&unLen);
 818   2              if (status != MI_ERR)
 819   2              {    status = MI_OK;    }
 820   2          }
 821   1          
 822   1          if (status != MI_OK)
 823   1          {    return MI_ERR;   }
 824   1          
 825   1          ucComMF522Buf[0] = PICC_TRANSFER;
 826   1          ucComMF522Buf[1] = goaladdr;
 827   1      
 828   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 829   1       
 830   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 831   1      
 832   1          if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
 833   1          {   status = MI_ERR;   }
 834   1      
 835   1          return status;
 836   1      }
 837          
 838          
 839          //******************************************************************/
 840          //功    能：命令卡片进入休眠状态
 841          //返    回: 成功返回MI_OK
 842          //******************************************************************/
 843          sint8_t PcdHalt(void)
 844          {
 845   1          sint8_t status;
 846   1          uint16_t  unLen;
 847   1          uint8_t ucComMF522Buf[MAXRLEN]; 
 848   1      
 849   1          ucComMF522Buf[0] = PICC_HALT;
 850   1          ucComMF522Buf[1] = 0;
 851   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 852   1       
 853   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 854   1          return status;
 855   1      //    return MI_OK;
 856   1      }
 857          
 858          //******************************************************************/
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/25/2023 17:24:16 PAGE 15  

 859          //功    能：命令卡片进入休眠状态
 860          //返    回: 成功返回MI_OK
 861          //******************************************************************/
 862          sint8_t MIF_Halt(void)
 863          {
 864   1          sint8_t status;
 865   1          uint16_t  unLen;
 866   1          uint8_t ucComMF522Buf[MAXRLEN]; 
 867   1      
 868   1          ucComMF522Buf[0] = PICC_HALT;
 869   1          ucComMF522Buf[1] = 0;
 870   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 871   1       
 872   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 873   1          return status ;  
 874   1      //    return MI_OK;
 875   1      }
 876          
 877          
 878          
 879          //******************************************************************/
 880          //用MF522计算CRC16函数
 881          //******************************************************************/
 882          void CalulateCRC(uint8_t *pIndata,uint8_t len,uint8_t *pOutData)
 883          {
 884   1          uint8_t i,n;
 885   1          ClearBitMask(DivIrqReg,0x04);
 886   1          WriteRawRC(CommandReg,PCD_IDLE);
 887   1          SetBitMask(FIFOLevelReg,0x80);
 888   1          for (i=0; i<len; i++)
 889   1          {   WriteRawRC(FIFODataReg, *(pIndata+i));   }
 890   1          WriteRawRC(CommandReg, PCD_CALCCRC);
 891   1          i = 0xFF;
 892   1          do 
 893   1          {
 894   2              n = ReadRawRC(DivIrqReg);
 895   2              i--;
 896   2          }
 897   1          while ((i!=0) && !(n&0x04));
 898   1          pOutData[0] = ReadRawRC(CRCResultRegL);
 899   1          pOutData[1] = ReadRawRC(CRCResultRegM);
 900   1      }
 901          
 902          
 903          status_t Find_Card(void)
 904          {
 905   1      
 906   1        //sint8_t status = MI_ERR ;
 907   1        uint8_t irqEn  = 0x00    ;
 908   1        uint8_t waitFor = 0x00   ;
 909   1        //uint8_t lastBits         ;
 910   1        uint8_t n                ;
 911   1        uint16_t  i              ;
 912   1       
 913   1        //ENTKS = 0;
 914   1       //ClearBitMask(ComIrqReg,0x80);    //release IRQ PIN
 915   1        ClearBitMask(Status2Reg,0x08);
 916   1        WriteRawRC(BitFramingReg,0x07);
 917   1        SetBitMask(TxControlReg,0x03);
 918   1        Hardware_DelayMs(2);
 919   1        irqEn  = 0x20;//0x77;
 920   1        waitFor = 0x30;
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/25/2023 17:24:16 PAGE 16  

 921   1      
 922   1        WriteRawRC(ComIEnReg,irqEn|0x80); //
 923   1        ClearBitMask(ComIrqReg,0x80);
 924   1        WriteRawRC(CommandReg,PCD_IDLE);
 925   1        SetBitMask(FIFOLevelReg,0x80); // 清空FIFO 
 926   1        WriteRawRC(FIFODataReg,0x52); // 数据写入FIFO 
 927   1        WriteRawRC(CommandReg, PCD_TRANSCEIVE); // 命令写入命令寄存器
 928   1      
 929   1        SetBitMask(BitFramingReg,0x80); // 开始发送  
 930   1         
 931   1        PcdAntennaOn();//开启天线发射
 932   1         
 933   1        i = 15; //根据时钟频率调整，操作M1等待时间15ms
 934   1        do 
 935   1        {
 936   2          n = ReadRawRC(ComIrqReg);
 937   2          i--;
 938   2          if (PINMACRO_NFC_IRQ_STATUS == 0 )
 939   2          {
 940   3            //PcdAntennaOff();
 941   3            return S_SUCCESS;
 942   3          }
 943   2        }
 944   1        while((i!=0)&&!(n&0x01)&&!(n&waitFor));
 945   1      
 946   1        //PcdAntennaOff();
 947   1      
 948   1        return S_FAIL;
 949   1       
 950   1      }
 951          
 952          status_t MFC_Auto_Reader(uint8_t *Point)
 953          {
 954   1        uint8_t i;
 955   1         
 956   1      //  return S_FAIL;
 957   1          
 958   1        //PcdAntennaOn();//开启天线发射 
 959   1      //  Hardware_DelayMs(1);
 960   1      
 961   1        //PA_ODR |=SETBIT2;
 962   1        
 963   1        if ( Find_Card() == S_SUCCESS )
 964   1        {
 965   2          if(PcdAnticoll(UID)==MI_OK)
 966   2          {   
 967   3            DEBUG_MARK;
 968   3            if ( PcdSelect(UID) == MI_OK )
 969   3            {
 970   4              PcdAntennaOff();
 971   4              SetBitMask(ControlReg,0x80);// stop timer now
 972   4                WriteRawRC(CommandReg,PCD_IDLE); 
 973   4              
 974   4              for (i=0;i<4;i++)
 975   4              {
 976   5                *Point = UID[i];
 977   5                Point++;
 978   5              }
 979   4              DEBUG_MARK;
 980   4              return S_SUCCESS;
 981   4            }
 982   3          }
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/25/2023 17:24:16 PAGE 17  

 983   2        }
 984   1        PcdAntennaOff();
 985   1        SetBitMask(ControlReg,0x80);// stop timer now
 986   1          WriteRawRC(CommandReg,PCD_IDLE); 
 987   1        //WriteRawRC(CommandReg,PCD_SLEEP);
 988   1      
 989   1        //PA_ODR &=CLRBIT2; 
 990   1        return S_FAIL;
 991   1      }
 992          
 993          status_t MFC_ReadLockBrandData(uint8_t *buff)
 994          {
 995   1        uint8_t i;
 996   1        uint8_t tempBuff[224];
 997   1        status_t TempResult;
 998   1        
 999   1        TempResult = S_FAIL;
1000   1        if ( Find_Card() == S_SUCCESS )
1001   1        {
1002   2          if(PcdAnticoll(UID)==MI_OK)
1003   2          {
1004   3            if( PcdSelect(UID)==MI_OK )
1005   3            {
1006   4              if ( Read_Block(0x04,tempBuff) == MI_OK ) //for save identify byte
1007   4              { 
1008   5                if (  (tempBuff[0] == 0x11)
1009   5                    &&(tempBuff[1] == 0x55)
1010   5                    &&(tempBuff[2] == 0xAA)
1011   5                    &&(tempBuff[3] == 0xDD)
1012   5                    &&(tempBuff[4] == 0xBB)
1013   5                    &&(tempBuff[5] == 0x11)
1014   5                    &&(tempBuff[6] == 0x55)
1015   5                    &&(tempBuff[7] == 0xAA)
1016   5                    &&(tempBuff[8] == 0xDD)
1017   5                    &&(tempBuff[9] == 0xBB) )
1018   5                {
1019   6                  for ( i=0;i<7;i++)
1020   6                  {
1021   7                    if ( Read_Block(4*i+8,&tempBuff[(2*i)*16]) != MI_OK ){
1022   8                      break;
1023   8                    }
1024   7                    if ( Read_Block(4*i+9,&tempBuff[((2*i)+1)*16]) != MI_OK ){
1025   8                      break;
1026   8                    }
1027   7                    CLRWDT();
1028   7                  }
1029   6                  if ( i==7 )
1030   6                  {
1031   7                    for (i=0;i<224;i++)
1032   7                    {
1033   8                      *(buff+i)=tempBuff[i];
1034   8                    }
1035   7                    TempResult = S_SUCCESS;
1036   7                  }
1037   6                }
1038   5              }
1039   4            }
1040   3          }
1041   2        }
1042   1        PcdAntennaOff();
1043   1        SetBitMask(ControlReg,0x80);// stop timer now
1044   1          WriteRawRC(CommandReg,PCD_IDLE); 
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/25/2023 17:24:16 PAGE 18  

1045   1        
1046   1        return TempResult;
1047   1      }
1048          
1049          
1050          void MFC_POWERDOWN(void)
1051          {
1052   1        
1053   1        SET_MFC_RST_L;
1054   1        Hardware_DelayMs(1);
1055   1      
1056   1        //WriteRawRC(CommandReg,PCD_RESETPHASE);
1057   1        //Hardware_DelayMs(1)          ;
1058   1        
1059   1        //WriteRawRC(CommandReg,PCD_SLEEP);
1060   1      }
1061          
1062          void MFC_WAKEUP(void)
1063          { 
1064   1        SET_MFC_RST_H;
1065   1        Hardware_DelayMs(1);
1066   1      /*  
1067   1        WriteRawRC(RFCfgReg,0x78)     ; 
1068   1        WriteRawRC(GsNReg,0xFF)     ; 
1069   1        WriteRawRC(CWGsCfgReg,0x3F)   ; 
1070   1        WriteRawRC(ModGsCfgReg,0x3F)     ; 
1071   1          
1072   1          
1073   1        WriteRawRC(ModeReg,0x3D)       ;
1074   1        WriteRawRC(TReloadRegL,30)       ;
1075   1        WriteRawRC(TReloadRegH,0)      ;
1076   1      
1077   1        WriteRawRC(TModeReg,0x8D)      ;
1078   1        WriteRawRC(TPrescalerReg,0x3E)     ;  
1079   1      */
1080   1        
1081   1        DEBUG_MARK;
1082   1      }
1083          
1084          
1085          void MFC_Init(void)
1086          {
1087   1        PcdReset();//复位RC522
1088   1        //PcdAntennaOn();//开启天线发射 
1089   1        PcdAntennaOff();
1090   1        
1091   1        DEBUG_MARK;
1092   1      }
1093          
1094          
1095          void MFC_Test(void)
1096          {
1097   1             uint8_t i;
1098   1              TestVal = 0x00;
1099   1             DEBUG_MARK;
1100   1        TestVal = ReadRawRC(RFCfgReg);//,0x78)       ; 
1101   1        DEBUG_MARK;
1102   1        TestVal = ReadRawRC(GsNReg);//,0xFF)        ; 
1103   1        DEBUG_MARK;
1104   1        TestVal = ReadRawRC(CWGsCfgReg);//,0x3F)     ; 
1105   1        DEBUG_MARK;
1106   1        TestVal = ReadRawRC(ModGsCfgReg);//,0x3F)     ; 
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/25/2023 17:24:16 PAGE 19  

1107   1        DEBUG_MARK;
1108   1        
1109   1        TestVal = ReadRawRC(ModeReg);//,0x3D)             ;
1110   1        DEBUG_MARK;
1111   1        TestVal = ReadRawRC(TReloadRegL);//,30)           ;
1112   1        DEBUG_MARK;
1113   1        TestVal = ReadRawRC(TReloadRegH);//,0)            ;
1114   1        DEBUG_MARK;
1115   1        
1116   1        TestVal = ReadRawRC(TModeReg);//,0x8D)            ;
1117   1        DEBUG_MARK;
1118   1        TestVal = ReadRawRC(TPrescalerReg);//,0x3E)       ;
1119   1        DEBUG_MARK;
1120   1          TestVal = ReadRawRC(TPrescalerReg);//,0x3E)       ;
1121   1        DEBUG_MARK;
1122   1          TestVal = ReadRawRC(TPrescalerReg);//,0x3E)       ;
1123   1        DEBUG_MARK;
1124   1        //PcdAntennaOn();//开启天线发射 
1125   1        //Hardware_DelayMs(1);
1126   1        //Find_Card();
1127   1        //PcdAntennaOff();
1128   1         for(i=0; i<10; i++)
1129   1          TestBuff[i]=i;
1130   1          
1131   1         for(i=0; i<10; i++)
1132   1            WriteRawRC(FIFODataReg,TestBuff[i])          ; // 数据写入FIFO 
1133   1        DEBUG_MARK;     
1134   1        for(i=0; i<10; i++)
1135   1          TestBuff[i]=0xFF;   
1136   1        DEBUG_MARK; 
1137   1        
1138   1        //i=0;  
1139   1        
1140   1        TestVal = (FIFODataReg<<1)|0x80;
1141   1        for(i=0; i<10; i++)
1142   1        {
1143   2          
1144   2          TestBuff[i] = ReadRawRC(FIFODataReg)          ; //
1145   2          /*
1146   2          SET_MFC_CS_L;
1147   2          Hardware_DelayX1us(100);
1148   2        
1149   2          HAL_SPI_Transmit(&hspi2,&TestVal,1,10);
1150   2          Hardware_DelayMs(10);
1151   2          HAL_SPI_Receive(&hspi2,&TestBuff[i],1,10);
1152   2        //  HAL_STATUS = HAL_SPI_TransmitReceive(&hspi2,&ucResult,&ReadData,1,500);
1153   2          Hardware_DelayMs(10);
1154   2          SET_MFC_CS_H;
1155   2      
1156   2        //  Hardware_DelayMs(10);
1157   2          Hardware_DelayX1us(100);
1158   2          */
1159   2          DEBUG_MARK;   
1160   2        }   
1161   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3539    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     52     503
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        04/25/2023 17:24:16 PAGE 20  

   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

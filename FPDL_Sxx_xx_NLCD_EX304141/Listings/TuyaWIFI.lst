C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/19/2023 13:57:33 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE TUYAWIFI
OBJECT MODULE PLACED IN .\Objects\TuyaWIFI.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Drivers\Protocol\WIFI_Tuya\TuyaWIFI.c LARGE OMF2 OPTIMIZE(9,SPEED) BROWS
                    -E INCDIR(.\Drivers\Lib\c;.\Drivers\Lib\H;.\Drivers\Lib\IAP_Lib;.\Drivers\Lib\TouchKey_lib;.\Drivers\Physical;.\Drivers\P
                    -rotocol;.\Softwares\Application;.\Softwares\Basic;.\Softwares\ModuleLogic;.\Drivers\Protocol\YC_NFC;.\Drivers\Protocol\W
                    -IFI_Tuya) DEBUG PRINT(.\Listings\TuyaWIFI.lst) TABS(2) OBJECT(.\Objects\TuyaWIFI.obj)

line level    source

   1          #include "TuyaWIFI.h"
   2          
   3          #include "usart.h"
   4          #include "IO.h"
   5          #include "Basic_Function.h"
   6          #include "global_variable.h"
   7          
   8          #include "FP.h"
   9          #include "MFC.h"
  10          #include "GUI_Function.h"
  11          
  12          #include "stdlib.h"
  13          #include <string.h>
  14          
  15          
  16          #ifdef Function_TuyaWifi
  17          
  18          #define Def_WifiSendTime Def_GuiTimeDelayCnt025s
  19          
  20          extern PasscodeInputMgr_t PasscodeInputMgr;
  21          
  22          /**
  23           * @brief  计算校验和
  24           * @param[in] {pack} 数据源指针
  25           * @param[in] {pack_len} 计算校验和长度
  26           * @return 校验和
  27           */
  28          uint8_t GetCheckSum(uint8_t *pack, uint8_t pack_len)
  29          {
  30   1          uint8_t i;
  31   1          uint8_t check_sum = 0;
  32   1          
  33   1          for(i = 0; i < pack_len; i ++) {
  34   2              check_sum += *pack ++;
  35   2          }
  36   1          
  37   1          return check_sum;
  38   1      }
  39          
  40          /**
  41           * @brief  串口发送一段数据
  42           * @param[in] {in} 发送缓存指针
  43           * @param[in] {len} 数据发送长度
  44           * @return Null
  45           */
  46          static void TuyaWIFISendDatas(uint8_t *in, uint16_t SendLen)
  47          {
  48   1        Uart1SendStr(in,SendLen);
  49   1      }
  50          
  51          /**
  52           * @brief  向wifi串口发送一帧数据
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/19/2023 13:57:33 PAGE 2   

  53           * @param[in] {fr_type} 帧类型
  54           * @param[in] {*DataBuff} 数据
  55           * @param[in] {DataLen} 数据长度
  56           * @return Null
  57           */
  58          void TuyaWIFISendFrame(uint8_t fr_type, uint8_t *DataBuff,uint16_t DataLen)
  59          {
  60   1        uint8_t check_sum = 0;
  61   1        uint16_t i = 0;
  62   1        uint8_t TuyaWIFI_tx_buf[UART_MAX_LEN];
  63   1        
  64   1        TuyaWIFI_tx_buf[HEAD_FIRST] = FRAME_FIRST;
  65   1        TuyaWIFI_tx_buf[HEAD_SECOND] = FRAME_SECOND;
  66   1        TuyaWIFI_tx_buf[PROTOCOL_VERSION] = MCU_TX_VER;
  67   1        TuyaWIFI_tx_buf[FRAME_TYPE] = fr_type;
  68   1        TuyaWIFI_tx_buf[LENGTH_HIGH] = DataLen >> 8;
  69   1        TuyaWIFI_tx_buf[LENGTH_LOW] = DataLen & 0xff;
  70   1      
  71   1        for( i=0; i<DataLen; i++ )
  72   1        {
  73   2          TuyaWIFI_tx_buf[i+DATA_START] = *DataBuff;
  74   2          DataBuff++;
  75   2        }
  76   1        
  77   1        DataLen += PROTOCOL_HEAD;
  78   1        check_sum = GetCheckSum((uint8_t *)TuyaWIFI_tx_buf, DataLen - 1);
  79   1        TuyaWIFI_tx_buf[DataLen - 1] = check_sum;
  80   1      
  81   1        TuyaWIFISendDatas((uint8_t *)TuyaWIFI_tx_buf, DataLen);
  82   1      }
  83          
  84          /**
  85           * @brief  判断WIFI是否已连接
  86           * @param[in] void
  87           * @return status_t
  88           */
  89          status_t IfWifiIsLinked(void)
  90          {
  91   1        if( (WifiMgr.WifiConnection.Status == Connected) || (WifiMgr.WifiConnection.Status == JustConnected) )
  92   1        {
  93   2          return S_SUCCESS;
  94   2        }
  95   1        return S_FAIL;
  96   1      }
  97          
  98          /*  ASCII
  99          { 0x7b    } 0x7d    " 0x22    : 0x3a    , 0x2c    . 0x2e
 100          */
 101          // 产品信息：{"p":"ffxpgjqdnqalmkdk","v":"1.0.0","cap":11}
 102          uint8_t infoData[] = "{\"p\":\"sh0xpcipym5yiyck\",\"v\":\"1.0.0\",\"cap\":0}";
 103          
 104          // 发送产品信息
 105          void Wifi_SendProjectInfo(void)
 106          {
 107   1        uint16_t DataLen = sizeof(infoData)-1;
 108   1        uint8_t DataBuff[55] = {0};
 109   1        uint8_t i = 0;
 110   1        
 111   1        memset(DataBuff, 0, DataLen);
 112   1        
 113   1        for(i = 0; i < DataLen; i++) {
 114   2          DataBuff[i] = infoData[i];
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/19/2023 13:57:33 PAGE 3   

 115   2        }
 116   1      
 117   1      //  if(DataBuff != NULL) {
 118   1          TuyaWIFISendFrame(PRODUCT_INFO_CMD,DataBuff,DataLen);
 119   1      //    free(DataBuff);
 120   1      //    DataBuff = NULL;
 121   1      //  }
 122   1      }
 123          
 124          // 回复模块发送的联网状态信息
 125          void Wifi_SendLinkNetworkAck(void)
 126          {
 127   1      //  uint8_t buff[7]={0x55,0xAA,0x00,0x02,0x00,0x00,0x01};
 128   1        uint16_t DataLen = 0;
 129   1        uint8_t DataBuff[] = {0x00};
 130   1        TuyaWIFISendFrame(WIFI_STATE_CMD,DataBuff,DataLen);
 131   1      }
 132          
 133          // 重置WiFi
 134          void Wifi_SendResetNetworkConfig(void)
 135          {
 136   1        uint16_t DataLen = 0;
 137   1        uint8_t DataBuff[] = {0x00};
 138   1        TuyaWIFISendFrame(WIFI_RESET_CMD,DataBuff,DataLen);
 139   1      }
 140          
 141          // Smart配网
 142          void Wifi_SendSmartNetworkConfig(void)
 143          {
 144   1        uint16_t DataLen = 1;
 145   1        uint8_t DataBuff[] = {0x00};  // Smart: 0x00    AP: 0x01
 146   1        TuyaWIFISendFrame(WIFI_MODE_CMD,DataBuff,DataLen);
 147   1        WifiMgr.Ack.TimeOutCnt++;
 148   1      }
 149          
 150          // 实时状态上报
 151          // lenth 为buf长度
 152          // buf 是需要发送的几个pid的数据组合
 153          // 如 PID1 LEN1_H LEN1_L DATA1_1 DATA1_2 ... PID2 LEN2_H LEN2_L DATA2_1 DATA2_2 ...
 154          void Wifi_SendCurrentState(uint8_t lenth, uint8_t* buf)
 155          { 
 156   1        uint16_t DataLen = lenth;
 157   1        uint8_t* DataBuff = buf;
 158   1      
 159   1        TuyaWIFISendFrame(STATE_UPLOAD_CMD,DataBuff,DataLen);
 160   1      }
 161          
 162          // 记录型状态上报
 163          // lenth 为buf长度
 164          // buf 是需要发送的几个pid的数据组合
 165          // 如 PID1 LEN1_H LEN1_L DATA1_1 DATA1_2 ... PID2 LEN2_H LEN2_L DATA2_1 DATA2_2 ...
 166          void Wifi_SendRecordState(uint8_t lenth, uint8_t* buf)
 167          { 
 168   1        buf[0] = 0x02;  // 0 时间无效； 1 有效 当地时间； 2 有效 格林时间
 169   1        memcpy(buf+1, WifiMgr.OfflineTempPassword.GreenTime, 6);
 170   1        TuyaWIFISendFrame(STATE_RC_UPLOAD_CMD,buf,lenth);
 171   1      }
 172          
 173          // 回复模块的命令
 174          void Wifi_SendGotCMDAck(void)
 175          {
 176   1        uint16_t DataLen = 0;
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/19/2023 13:57:33 PAGE 4   

 177   1        uint8_t DataBuff[] = {0x00};
 178   1        TuyaWIFISendFrame(DATA_QUERT_CMD,DataBuff,DataLen);
 179   1      }
 180          
 181          // 查询网络时间
 182          void Wifi_SendLocalTimeRequest(void)
 183          {
 184   1        uint16_t DataLen = 0;
 185   1        uint8_t DataBuff[] = {0x00};
 186   1        TuyaWIFISendFrame(GET_LOCAL_TIME_CMD,DataBuff,DataLen);
 187   1      }
 188          
 189          // 查询格林时间
 190          void Wifi_SendGreenTimeRequest(void)
 191          {
 192   1        uint16_t DataLen = 0;
 193   1        uint8_t DataBuff[] = {0x00};
 194   1        TuyaWIFISendFrame(GET_GL_TIME_CMD,DataBuff,DataLen);
 195   1      }
 196          
 197          // 查询当前连接的路由器的信号强度
 198          void Wifi_SendNetworkRequest(void)
 199          {
 200   1        uint16_t DataLen = 0;
 201   1        uint8_t DataBuff[] = {0x00};
 202   1        TuyaWIFISendFrame(ROUTE_RSSI_CMD,DataBuff,DataLen);
 203   1      }
 204          
 205          // 获取云端临时密码
 206          void Wifi_SendTmpPwdRequest(void)
 207          {
 208   1        uint16_t DataLen = 0;
 209   1        uint8_t DataBuff[] = {0x00};
 210   1        TuyaWIFISendFrame(GET_TMP_PWD_CMD,DataBuff,DataLen);
 211   1      }
 212          
 213          // 获取DP缓存
 214          //void Wifi_SendDPCacheRequest(uint16_t num, uint8_t* id)
 215          //{
 216          //  uint16_t DataLen = num + 1;
 217          //  uint8_t* DataBuff = (uint8_t *) malloc(DataLen);
 218          //  uint8_t i = 0;
 219          //  
 220          //  memset(DataBuff, 0, DataLen);
 221          //  
 222          //  DataBuff[0] = num;  // DP 个数
 223          //  for(i = 1; i <= num; i++) {
 224          //    DataBuff[i] = id[i-1];
 225          //  }
 226          
 227          //  if(DataBuff != NULL) {
 228          //    TuyaWIFISendFrame(GET_DP_CACHE_CMD,DataBuff,DataLen);
 229          //    free(DataBuff);
 230          //    DataBuff = NULL;
 231          //  }
 232          //}
 233          
 234          // 离线动态密码
 235          // lenth 为pwd长度
 236          // pwd 离线密码
 237          void Wifi_SendOfflineTmpPWD(uint8_t* pwd, uint8_t lenth)
 238          { 
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/19/2023 13:57:33 PAGE 5   

 239   1        uint16_t DataLen = lenth + 7;
 240   1        uint8_t* DataBuff = (uint8_t *) malloc(DataLen);
 241   1        uint8_t i = 0;
 242   1        
 243   1        memset(DataBuff, 0, DataLen);
 244   1        memcpy(DataBuff, WifiMgr.OfflineTempPassword.GreenTime, 6);
 245   1        DataBuff[6] = lenth;  // 密码长度
 246   1        
 247   1        for(i = 0; i < lenth; i++) {
 248   2          DataBuff[7+i] = pwd[i];
 249   2        }
 250   1        if(DataBuff != NULL) {
 251   2          TuyaWIFISendFrame(GET_TMP_PWD_OFFLINE_CMD,DataBuff,DataLen);
 252   2          free(DataBuff);
 253   2          DataBuff = NULL;
 254   2        }
 255   1      }
 256          
 257          //离线临时密码上报
 258          void Wifi_ReportTempPasscode(uint8_t DpID)
 259          {
 260   1        //TuyaWIFISendFrame(STATE_UPLOAD_CMD,DataBuff,DataLen);
 261   1        uint16_t DataLen = 7 + 20;
 262   1        uint8_t DataBuff[7 + 20] = {0x00};
 263   1        DataBuff[7] = DpID;     // DP ID
 264   1        DataBuff[8] = 0x00;     // 数据类型
 265   1        DataBuff[9] = 0x00;     // 数据长度H
 266   1        DataBuff[10] = 0x10;    // 数据长度L
 267   1        memcpy(DataBuff+11, WifiMgr.OfflineTempPassword.DecryptingData, 16);
 268   1        //Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 269   1        Wifi_SendRecordState(DataLen, DataBuff);      // 记录型
 270   1      }
 271          
 272          // 上报SN
 273          // lenth 为SN长度
 274          // sn SN
 275          //void Wifi_Send_MCU_SN(uint8_t lenth, uint8_t* sn)
 276          //{
 277          //  uint16_t DataLen = lenth + 1;
 278          //  uint8_t* DataBuff = (uint8_t *) malloc(DataLen);
 279          //  uint8_t i = 0;
 280          //  memset(DataBuff, 0, DataLen);
 281          //  DataBuff[0] = lenth;  // SN 长度
 282          //  for(i = 1; i <= lenth; i++) {
 283          //    DataBuff[i] = sn[i-1];
 284          //  }
 285          //  if(DataBuff != NULL) {
 286          //    TuyaWIFISendFrame(REPORTED_MCU_SN_CMD,DataBuff,DataLen);
 287          //    free(DataBuff);
 288          //    DataBuff = NULL;
 289          //  }
 290          //}
 291          
 292          // 回复模块重置命令
 293          void Wifi_SendResetNoticeAck(void)
 294          {
 295   1        uint16_t DataLen = 0;
 296   1        uint8_t DataBuff[] = {0x00};
 297   1        TuyaWIFISendFrame(WIFI_RESET_NOTICE_CMD,DataBuff,DataLen);
 298   1      }
 299          
 300          // 获取WiFi状态
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/19/2023 13:57:33 PAGE 6   

 301          //#ifdef LOCK_KEEP_ALIVE
 302          //void Wifi_SendGetWIFIState(void)
 303          //{
 304          //  uint16_t DataLen = 0;
 305          //  uint8_t DataBuff[] = {0x00};
 306          //  TuyaWIFISendFrame(GET_WIFI_STATE_CMD,DataBuff,DataLen);
 307          //}
 308          //#endif
 309          
 310          //上报 解锁
 311          void Wifi_ReportUnlockInfo(uint8_t DpId, uint16_t id)
 312          {
 313   1        uint16_t DataLen = 7 + 8;
 314   1        uint8_t DataBuff[7 + 8] = {0x00};
 315   1        
 316   1        DataBuff[7] = DpId;           // DP ID
 317   1        DataBuff[8] = VALUE;          // 数据类型
 318   1        DataBuff[9] = 0x00;           // 数据长度H
 319   1        DataBuff[10] = 0x04;          // 数据长度L
 320   1        DataBuff[11] = 0x00;          // 数据
 321   1        DataBuff[12] = 0x00;          // 数据
 322   1        DataBuff[13] = id>>8;         // 数据
 323   1        DataBuff[14] = id;            // 数据
 324   1        Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 325   1      //  Wifi_SendRecordState(DataLen, DataBuff);      // 记录型
 326   1      }
 327          
 328          //上报 新免密远程开门-带秘钥
 329          void Wifi_ReportRemoteUnlockInfo(uint8_t DpId, uint16_t id)
 330          {
 331   1        uint16_t DataLen = 7 + 7;
 332   1        uint8_t DataBuff[7 + 7] = {0x00};
 333   1        
 334   1        DataBuff[7] = DpId;           // DP ID
 335   1        DataBuff[8] = RAW;          // 数据类型
 336   1        DataBuff[9] = 0x00;           // 数据长度H
 337   1        DataBuff[10] = 0x03;          // 数据长度L
 338   1        DataBuff[11] = 0x00;          // 成功
 339   1        DataBuff[12] = id>>8;         // 密匙编号
 340   1        DataBuff[13] = id;            // 密匙编号
 341   1        Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 342   1      //  Wifi_SendRecordState(DataLen, DataBuff);      // 记录型
 343   1      }
 344          
 345          //上报 组合开锁
 346          void Wifi_ReportCombinedUnlockInfo(uint8_t *DpId, uint16_t *id)
 347          {
 348   1        uint16_t DataLen = 7 + 16;
 349   1        uint8_t DataBuff[7 + 16] = {0x00};
 350   1        uint8_t i;
 351   1        uint8_t InfoNum = 2;
 352   1        
 353   1        for( i=0; i<InfoNum; i++ )
 354   1        {
 355   2          DataBuff[8*i+7] = *DpId;          // DP ID
 356   2          DataBuff[8*i+8] = VALUE;          // 数据类型
 357   2          DataBuff[8*i+9] = 0x00;           // 数据长度H
 358   2          DataBuff[8*i+10] = 0x04;          // 数据长度L
 359   2          DataBuff[8*i+11] = 0x00;          // 数据
 360   2          DataBuff[8*i+12] = 0x00;          // 数据
 361   2          DataBuff[8*i+13] = *id>>8;        // 数据
 362   2          DataBuff[8*i+14] = *id;           // 数据
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/19/2023 13:57:33 PAGE 7   

 363   2          if( i < (InfoNum-1) )
 364   2          {
 365   3            DpId++;
 366   3            id++;
 367   3          }
 368   2        }
 369   1        Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 370   1      //  Wifi_SendRecordState(DataLen, DataBuff);      // 记录型
 371   1      }
 372          
 373          //上报 告警
 374          void Wifi_ReportAlarmInfo(WifiAlarmType_t AlarmType)
 375          {
 376   1        uint16_t DataLen = 7 + 5;
 377   1        uint8_t DataBuff[7 + 5] = {0x00};
 378   1        
 379   1        DataBuff[7] = DpIdAlarm;      // DP ID
 380   1        DataBuff[8] = ENUM;           // 数据类型
 381   1        DataBuff[9] = 0x00;           // 数据长度H
 382   1        DataBuff[10] = 0x01;            // 数据长度L
 383   1        DataBuff[11] = AlarmType;       // 数据
 384   1      
 385   1        Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 386   1      //  Wifi_SendRecordState(DataLen, DataBuff);  // 记录型
 387   1      }
 388          
 389          //上报 远程开锁请求倒计时
 390          void Wifi_ReportRemoteUnlockRequestCountdown(uint16_t time)
 391          {
 392   1        uint16_t DataLen = 7 + 8;
 393   1        uint8_t DataBuff[7 + 8] = {0x00};
 394   1        
 395   1        DataBuff[7] = DpIdAPPUnlock;  // DP ID
 396   1        DataBuff[8] = VALUE;          // 数据类型
 397   1        DataBuff[9] = 0x00;           // 数据长度H
 398   1        DataBuff[10] = 0x04;            // 数据长度L
 399   1        DataBuff[11] = 0x00;            // 数据
 400   1        DataBuff[12] = 0x00;            // 数据
 401   1        DataBuff[13] = time>>8;         // 数据
 402   1        DataBuff[14] = time;            // 数据
 403   1      
 404   1        Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 405   1      //    Wifi_SendRecordState(DataLen, DataBuff);  // 记录型
 406   1      }
 407          
 408          //上报 电池电量状态
 409          void Wifi_ReportBatteryLevel(uint8_t BatteryLevel)
 410          {
 411   1        uint16_t DataLen = 7 + 5;
 412   1        uint8_t DataBuff[7 + 5] = {0x00};
 413   1        
 414   1        DataBuff[7] = DpIdBatteryLevel; // DP ID
 415   1        DataBuff[8] = ENUM;             // 数据类型
 416   1        DataBuff[9] = 0x00;             // 数据长度H
 417   1        DataBuff[10] = 0x01;            // 数据长度L
 418   1        DataBuff[11] = BatteryLevel;        // 数据
 419   1      
 420   1        Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 421   1      //  Wifi_SendRecordState(DataLen, DataBuff);  // 记录型
 422   1      }
 423          
 424          //上报 APP远程解锁
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/19/2023 13:57:33 PAGE 8   

 425          void Wifi_ReportAPPRemoteUnlock(uint16_t value)
 426          {
 427   1        uint16_t DataLen = 7 + 8;
 428   1        uint8_t DataBuff[7 + 8] = {0x00};
 429   1        
 430   1        DataBuff[7] = 0x0f;           // DP ID
 431   1        DataBuff[8] = VALUE;          // 数据类型
 432   1        DataBuff[9] = 0x00;           // 数据长度H
 433   1        DataBuff[10] = 0x04;            // 数据长度L
 434   1        DataBuff[11] = 0x00;            // 数据
 435   1        DataBuff[12] = 0x00;            // 数据
 436   1        DataBuff[13] = value>>8;          // 数据
 437   1        DataBuff[14] = value;         // 数据
 438   1        
 439   1        Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 440   1      //  Wifi_SendRecordState(DataLen, DataBuff);  // 记录型
 441   1      }
 442          
 443          //上报 被胁迫
 444          //void Wifi_ReportStress(uint8_t stress)
 445          //{
 446          //  uint16_t DataLen = 7 + 5;
 447          //  uint8_t DataBuff[7 + 5] = {0x00};
 448          //  
 449          //  DataBuff[7] = 0x10;           // DP ID
 450          //  DataBuff[8] = BOOL;           // 数据类型
 451          //  DataBuff[9] = 0x00;           // 数据长度H
 452          //  DataBuff[10] = 0x01;            // 数据长度L
 453          //  DataBuff[11] = stress;        // 数据
 454          
 455          //  Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 456          ////  Wifi_SendRecordState(DataLen, DataBuff);  // 记录型
 457          //}
 458          
 459          //上报 门铃呼叫
 460          //void Wifi_ReportDoorBellAwake(uint8_t on)
 461          //{
 462          //  uint16_t DataLen = 7 + 5;
 463          //  uint8_t DataBuff[7 + 5] = {0x00};
 464          //  
 465          //  DataBuff[7] = 0x13;           // DP ID
 466          //  DataBuff[8] = BOOL;           // 数据类型
 467          //  DataBuff[9] = 0x00;           // 数据长度H
 468          //  DataBuff[10] = 0x01;            // 数据长度L
 469          //  DataBuff[11] = on;            // 数据
 470          
 471          //  Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 472          ////  Wifi_SendRecordState(DataLen, DataBuff);  // 记录型
 473          //}
 474          
 475          //上报 请求远程开门密匙
 476          void Wifi_ReportRequestRemoteUnlockPassword()
 477          {
 478   1        uint16_t DataLen = 7 + 5;
 479   1        uint8_t DataBuff[7 + 5] = {0x00};
 480   1        
 481   1        DataBuff[7] = 0x31;           // DP ID
 482   1        DataBuff[8] = RAW;            // 数据类型
 483   1        DataBuff[9] = 0x00;           // 数据长度H
 484   1        DataBuff[10] = 0x01;            // 数据长度L
 485   1        DataBuff[11] = 0x01;            // 数据
 486   1      
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/19/2023 13:57:33 PAGE 9   

 487   1        Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 488   1      //  Wifi_SendRecordState(DataLen, DataBuff);  // 记录型
 489   1      }
 490          
 491          //上报 保存密匙成功
 492          void Wifi_ReportSaveKeySuccess()
 493          {
 494   1        uint16_t DataLen = 7 + 7;
 495   1        uint8_t DataBuff[7 + 7] = {0x00};
 496   1        
 497   1        DataBuff[7] = 0x31;           // DP ID
 498   1        DataBuff[8] = RAW;            // 数据类型
 499   1        DataBuff[9] = 0x00;           // 数据长度H
 500   1        DataBuff[10] = 0x03;            // 数据长度L
 501   1        DataBuff[11] = 0x00;            // 成功
 502   1        DataBuff[12] = 0x00;            // 密匙编号
 503   1        DataBuff[13] = 0x01;            // 密匙编号
 504   1      
 505   1        Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 506   1      //  Wifi_SendRecordState(DataLen, DataBuff);  // 记录型
 507   1      }
 508          
 509          //上报 同步所有 指纹0x19 密码0x1a 卡号0x1b ID
 510          void Wifi_ReportAllUserDeviceId(uint8_t DpId, uint8_t* id, uint16_t lenth)
 511          {
 512   1        uint16_t DataLen = 7 + 4 + lenth;
 513   1        uint8_t* DataBuff = (uint8_t *) malloc(DataLen);
 514   1        uint8_t i = 0;
 515   1        memset(DataBuff, 0, DataLen);
 516   1      
 517   1        DataBuff[7] = DpId;           // DP ID
 518   1        DataBuff[8] = RAW;            // 数据类型
 519   1        DataBuff[9] = lenth>>8;         // 数据长度H
 520   1        DataBuff[10] = lenth;         // 数据长度L
 521   1      
 522   1      //  for(i = 4; i < DataLen; i++) {
 523   1      //    DataBuff[i] = id[i-4];        // 数据
 524   1      //  }
 525   1        memcpy(DataBuff+4+7, id, lenth);    // 数据
 526   1        
 527   1        if(DataBuff != NULL) {
 528   2          Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 529   2      //    Wifi_SendRecordState(DataLen, DataBuff);  // 记录型
 530   2          free(DataBuff);
 531   2          DataBuff = NULL;
 532   2        }
 533   1      }
 534          
 535          //上报 设置新免密远程开锁密钥
 536          //void Wifi_ReportNewRemoteUnlockPwd(uint8_t* newPwd, uint16_t lenth)
 537          //{
 538          //  uint16_t DataLen = 7 + 4 + lenth;
 539          //  uint8_t* DataBuff = (uint8_t *) malloc(DataLen);
 540          //  uint8_t i = 0;
 541          //  memset(DataBuff, 0, DataLen);
 542          //  
 543          //  DataBuff[7] = 0x31;           // DP ID
 544          //  DataBuff[8] = RAW;            // 数据类型
 545          //  DataBuff[9] = lenth>>8;         // 数据长度H
 546          //  DataBuff[10] = lenth;         // 数据长度L
 547          
 548          //  memcpy(DataBuff+4+7, newPwd, lenth);    // 数据
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/19/2023 13:57:33 PAGE 10  

 549          
 550          //  if(DataBuff != NULL) {
 551          //    Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 552          ////    Wifi_SendRecordState(DataLen, DataBuff);  // 记录型
 553          //    free(DataBuff);
 554          //    DataBuff = NULL;
 555          //  }
 556          //}
 557          
 558          //上报 免密远程开锁
 559          //void Wifi_ReportRemoteUnlock(uint8_t* Pwd, uint16_t lenth)
 560          //{
 561          //  uint16_t DataLen = 7 + 4 + lenth;
 562          //  uint8_t* DataBuff = (uint8_t *) malloc(DataLen);
 563          //  uint8_t i = 0;
 564          //  memset(DataBuff, 0, DataLen);
 565          //  
 566          //  DataBuff[7] = 0x32;           // DP ID
 567          //  DataBuff[8] = RAW;            // 数据类型
 568          //  DataBuff[9] = lenth>>8;         // 数据长度H
 569          //  DataBuff[10] = lenth;         // 数据长度L
 570          
 571          //  memcpy(DataBuff+4+7, Pwd, lenth);   // 数据
 572          
 573          //  if(DataBuff != NULL) {
 574          //    Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 575          ////    Wifi_SendRecordState(DataLen, DataBuff);  // 记录型
 576          //    free(DataBuff);
 577          //    DataBuff = NULL;
 578          //  }
 579          //}
 580          
 581          //上报 主动消息推送
 582          //void Wifi_ReportMessage(uint8_t* Msg, uint16_t lenth)
 583          //{
 584          //  uint16_t DataLen = 7 + 4 + lenth;
 585          //  uint8_t* DataBuff = (uint8_t *) malloc(DataLen);
 586          //  uint8_t i = 0;
 587          //  memset(DataBuff, 0, DataLen);
 588          //  
 589          //  DataBuff[7] = 0xd4;           // DP ID
 590          //  DataBuff[8] = RAW;            // 数据类型
 591          //  DataBuff[9] = lenth>>8;         // 数据长度H
 592          //  DataBuff[10] = lenth;         // 数据长度L
 593          
 594          //  memcpy(DataBuff+4+7, Msg, lenth);   // 数据
 595          
 596          //  if(DataBuff != NULL) {
 597          //    Wifi_SendCurrentState(DataLen- 7, DataBuff + 7);  // 实时
 598          ////    Wifi_SendRecordState(DataLen, DataBuff);  // 记录型
 599          //    free(DataBuff);
 600          //    DataBuff = NULL;
 601          //  }
 602          //}
 603          
 604          /**
 605           * @brief  数据帧处理
 606           * @param[in] {offset} 数据起始位
 607           * @return Null
 608           */
 609          //uint8_t rssi = 0; // WiFi信号强度
 610          //uint8_t tmppwd[12] = 0; // WiFi信号强度
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/19/2023 13:57:33 PAGE 11  

 611          
 612          void WifiDataHandle(uint8_t *offset)
 613          {
 614   1        uint8_t cmd_type,i = 0;
 615   1        uint8_t TempPswd[8] = {0};
 616   1        uint16_t cmd_lenth = 0;
 617   1        uint32_t Temp_sendingflag = 0;
 618   1      
 619   1        if(offset == NULL){return;}
 620   1        cmd_type = offset[3];
 621   1        cmd_lenth &= offset[4] << 8;
 622   1        cmd_lenth += offset[5];
 623   1      
 624   1        switch(cmd_type) 
 625   1        {
 626   2          case PRODUCT_INFO_CMD:  // 模块查询MCU信息
 627   2            WifiMgr.Ack.Status = GotProjectInfoCmdACK;
 628   2            break;
 629   2          
 630   2          case WIFI_STATE_CMD:  // 模块上报设备状态
 631   2            if(cmd_lenth > 0) 
 632   2            {
 633   3              if(offset[6] == 0x04) 
 634   3              {
 635   4                WifiMgr.WifiConnection.Status = JustConnected;
 636   4                WifiMgr.PostMgr.Flag.Bits.PowerLevel = 1;
 637   4                WifiMgr.RemoteUnlockMgr.RequestPasswordTimeCnt = Def_GuiTimeDelayCnt1s;
 638   4              }
 639   3            }
 640   2            WifiMgr.Ack.Status = WaitWifiStateCmdACK;
 641   2            break;
 642   2          
 643   2          case WIFI_RESET_CMD:  // 模块回复重置WiFi指令
 644   2            WifiMgr.WifiConnection.Status = NotConnected;
 645   2            break;
 646   2          case WIFI_MODE_CMD: // 重置WiFi 选择配置模式
 647   2            if(offset[5] == 0x00) 
 648   2            {
 649   3              WifiMgr.PostMgr.Flag.Bits.StartNetwork = 0;
 650   3              WifiMgr.Ack.TimeOutCnt = 0;
 651   3            }
 652   2            break;
 653   2          case ROUTE_RSSI_CMD:  // 模块回复WiFi信号强度
 654   2            if(cmd_lenth > 0) {
 655   3              if(offset[6] == 0x01) { // 成功
 656   4                //rssi = offset[7]; // WiFi信号强度 0 ~ 100
 657   4              }
 658   3              else
 659   3              {
 660   4                // 模块未连接路由器
 661   4              }
 662   3            }
 663   2            break;
 664   2      
 665   2          case STATE_UPLOAD_CMD:  // 模块回复实时状态指令
 666   2            if(cmd_lenth > 0) {
 667   3              if(offset[6] == 0x00) {
 668   4                // 执行成功
 669   4                Temp_sendingflag = WifiMgr.PostMgr.SendingFlag.TotalFlagBits;
 670   4                WifiMgr.PostMgr.Flag.TotalFlagBits  &= ~Temp_sendingflag;
 671   4                WifiMgr.Ack.TimeOutCnt = 0;
 672   4              } else if(offset[6] == 0x01) {
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/19/2023 13:57:33 PAGE 12  

 673   4                // 执行失败
 674   4      
 675   4              }
 676   3            }   
 677   2            break;
 678   2            
 679   2          case STATE_RC_UPLOAD_CMD: // 模块回复记录型状态指令
 680   2            if(cmd_lenth > 0) {
 681   3              Temp_sendingflag = WifiMgr.PostMgr.SendingFlag.TotalFlagBits;
 682   3              WifiMgr.PostMgr.Flag.TotalFlagBits  &= ~Temp_sendingflag;
 683   3              WifiMgr.Ack.TimeOutCnt = 0;
 684   3      //        if(offset[6] == 0x00) {
 685   3      //          // 记录成功
 686   3      //        } else if(offset[6] == 0x01) {
 687   3      //          // 当前记录上报成功，且还有滞留记录需要上报
 688   3      //        } else if(offset[6] == 0x02) {
 689   3      //          // 记录失败
 690   3      //        }
 691   3            }   
 692   2            break;
 693   2            
 694   2          case GET_GL_TIME_CMD:
 695   2            if(cmd_lenth > 0) 
 696   2            {
 697   3              if(offset[6] == 0x01)
 698   3              {
 699   4                memcpy(WifiMgr.OfflineTempPassword.GreenTime, offset+7, 6);
 700   4                WifiMgr.PostMgr.Flag.Bits.RequestGreenTime = 0;
 701   4                WifiMgr.Ack.TimeOutCnt = 0;
 702   4                WifiMgr.PostMgr.Flag.Bits.TempPasswordCheck = 1;
 703   4              }
 704   3            }
 705   2            break;
 706   2      
 707   2          case DATA_QUERT_CMD:  // 模块命令下发
 708   2            if(cmd_lenth > 0) 
 709   2            {
 710   3              if( (offset[5] == 0x19) &&  (offset[6] == 0x31) && (offset[9] == 0x15) ) 
 711   3              {
 712   4                if( WifiMgr.RemoteUnlockMgr.Status == RemoteUnlockRequestPassword )
 713   4                {
 714   5                  memcpy(WifiMgr.RemoteUnlockMgr.Passward, offset+23, 8);
 715   5                  WifiMgr.RemoteUnlockMgr.Status = RemoteUnlockStandby;
 716   5                  WifiMgr.PostMgr.Flag.Bits.SaveKeySuccess = 1;
 717   5                }
 718   4              }
 719   3              else if( offset[6] == 0x32 ) 
 720   3              {
 721   4                if( WifiMgr.RemoteUnlockMgr.Status == RemoteUnlockRequestWait )
 722   4                {
 723   5                  if( offset[5] != 0x11 )
 724   5                  {
 725   6                    WifiMgr.RemoteUnlockMgr.Result = IsFail;
 726   6                  }
 727   5                  else
 728   5                  {
 729   6                    memcpy(TempPswd, offset+13, 8);
 730   6                    for(i=0;i<8;i++)
 731   6                    {
 732   7                      if( TempPswd[i] != WifiMgr.RemoteUnlockMgr.Passward[i] )
 733   7                      {
 734   8                        WifiMgr.RemoteUnlockMgr.Result = IsFail;
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/19/2023 13:57:33 PAGE 13  

 735   8                        break;
 736   8                      }
 737   7                      if( i == 7 )
 738   7                      {
 739   8                        WifiMgr.RemoteUnlockMgr.Result = IsSuccess;
 740   8                      }
 741   7                    }
 742   6                  }
 743   5                }
 744   4              }
 745   3              WifiMgr.Ack.Status = WifiAnswerCmdACK;
 746   3            }
 747   2            break;
 748   2            
 749   2        //  case GET_TMP_PWD_CMD: // 模组回复一组临时密码
 750   2        //    if(cmd_lenth > 0) {
 751   2        //      if(offset[6] == 0x01) { // 成功
 752   2        //        tmppwd[0] = offset[7];  // 年
 753   2        //        tmppwd[1] = offset[8];  // 月
 754   2        //        tmppwd[2] = offset[9];  // 日
 755   2        //        tmppwd[3] = offset[10]; // 时
 756   2        //        tmppwd[4] = offset[11]; // 分
 757   2        //        tmppwd[5] = offset[12]; // 秒
 758   2        //        // 模拟发送该指令，没有收到测试工具返回密码，后续添加
 759   2        //      }
 760   2        //      else
 761   2        //      {
 762   2        //        // 获取失败
 763   2        //      }
 764   2        //    }
 765   2        //    
 766   2        //    dataTest[0] = cmd_lenth;
 767   2        //    Wifi_SendTestAck(1);
 768   2        //    break;
 769   2        
 770   2          case GET_TMP_PWD_OFFLINE_CMD:
 771   2            if(cmd_lenth > 0) 
 772   2            {
 773   3              if( offset[6] == 0x00 )
 774   3              {
 775   4                if( offset[7] == 0x00 || offset[7] == 0x01 )
 776   4                {
 777   5                  //开锁成功
 778   5                  if( WifiMgr.OfflineTempPassword.Status == TempPswdChecking )
 779   5                  {
 780   6                    memcpy(WifiMgr.OfflineTempPassword.DecryptingData, offset+9, 16);
 781   6                    WifiMgr.OfflineTempPassword.Status = TempPswdCorrect;
 782   6                  }
 783   5                }
 784   4                else if( offset[7] == 0x02 )
 785   4                {
 786   5                  //操作成功
 787   5                  if( WifiMgr.OfflineTempPassword.Status == TempPswdChecking )
 788   5                  {
 789   6                    if( offset[8] == 0x10 )
 790   6                    {
 791   7                      memcpy(WifiMgr.OfflineTempPassword.DecryptingData, offset+9, 16);
 792   7                    }
 793   6                    WifiMgr.OfflineTempPassword.Status = ClearCodeCorrect;
 794   6                  }
 795   5                }
 796   4              }
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/19/2023 13:57:33 PAGE 14  

 797   3              else
 798   3              {
 799   4                //验证失败
 800   4                if( WifiMgr.OfflineTempPassword.Status == TempPswdChecking )
 801   4                {
 802   5                  WifiMgr.OfflineTempPassword.Status = TempPswdWrong;
 803   5                }
 804   4              }
 805   3              
 806   3            }
 807   2            break;
 808   2          
 809   2          default:
 810   2            break;  
 811   2        }
 812   1      }
 813          
 814          //获取开锁类型和用户编号
 815          void GotIdentifyResult(uint8_t *Type, uint16_t *ID)
 816          {
 817   1        switch(UserIdentifyResultMgr.IdentifyType)
 818   1        {
 819   2          case CARD:
 820   2            *Type ++ = DpIdCardUnlock;
 821   2            *Type = 0;
 822   2            *ID ++ = (uint16_t)UserIdentifyResultMgr.CardUserID;
 823   2            *ID = 0;
 824   2            break;
 825   2          case PASSCODE:
 826   2            *Type ++ = DpIdPasswordUnlock;
 827   2            *Type = 0;
 828   2            *ID ++ = (uint16_t)UserIdentifyResultMgr.PasscodeUserID;
 829   2            *ID = 0;
 830   2            break;
 831   2          case FINGERPRINT:
 832   2            *Type ++ = DpIdFingerUnlock;
 833   2            *Type = 0;
 834   2            *ID ++ = (uint16_t)UserIdentifyResultMgr.FPUserID;
 835   2            *ID = 0;
 836   2            break;
 837   2          case FINGERPRINTandCARD:
 838   2            *Type ++ = DpIdFingerUnlock;
 839   2            *Type = DpIdCardUnlock;
 840   2            *ID ++ = (uint16_t)UserIdentifyResultMgr.FPUserID;
 841   2            *ID = (uint16_t)UserIdentifyResultMgr.CardUserID;
 842   2            break;
 843   2          case FINGERPRINTandPASSCODE:
 844   2            *Type ++ = DpIdFingerUnlock;
 845   2            *Type = DpIdPasswordUnlock;
 846   2            *ID ++ = (uint16_t)UserIdentifyResultMgr.FPUserID;
 847   2            *ID = (uint16_t)UserIdentifyResultMgr.PasscodeUserID;
 848   2            break;
 849   2          case CARDandPASSCODE:
 850   2            *Type ++ = DpIdPasswordUnlock;
 851   2            *Type = DpIdCardUnlock;
 852   2            *ID ++ = (uint16_t)UserIdentifyResultMgr.PasscodeUserID;
 853   2            *ID = (uint16_t)UserIdentifyResultMgr.CardUserID;
 854   2            break;
 855   2          //case WIFITEMPPASSCODE:
 856   2            
 857   2          default:
 858   2            break;
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/19/2023 13:57:33 PAGE 15  

 859   2        }
 860   1      }
 861          
 862          //开锁信息上报
 863          void WifiUnlockInfoExecute(void)
 864          {
 865   1        uint8_t UnlockType[2]={0};
 866   1        uint16_t UnlockID[2]={0};
 867   1        if( IfWifiIsLinked() == S_SUCCESS )
 868   1        {
 869   2          GotIdentifyResult(UnlockType,UnlockID);
 870   2          if( UnlockType[1] != 0 )
 871   2          {
 872   3            Wifi_ReportCombinedUnlockInfo(UnlockType,UnlockID);
 873   3          }
 874   2          else if( UnlockType[0] != 0 )
 875   2          {
 876   3            Wifi_ReportUnlockInfo(UnlockType[0],UnlockID[0]);
 877   3          }
 878   2          else
 879   2          {
 880   3            WifiMgr.PostMgr.Flag.Bits.Unlock = 0;
 881   3          }
 882   2          WifiMgr.Ack.TimeOutCnt++;
 883   2        }
 884   1      }
 885          
 886          //请求远程开锁密匙
 887          void WifiRequestRemoteUnlockKeyExecute()
 888          {
 889   1        if( IfWifiIsLinked() == S_SUCCESS )
 890   1        {
 891   2          Wifi_ReportRequestRemoteUnlockPassword();
 892   2          WifiMgr.Ack.TimeOutCnt++;
 893   2        }
 894   1      }
 895          
 896          //远程开锁密匙保存成功上报
 897          void WifiSaveKeySuccessExecute()
 898          {
 899   1        if( IfWifiIsLinked() == S_SUCCESS )
 900   1        {
 901   2          Wifi_ReportSaveKeySuccess();
 902   2          WifiMgr.Ack.TimeOutCnt++;
 903   2        }
 904   1      }
 905          
 906          //远程开锁信息上报
 907          void WifiRemoteUnlockSuccessExecute()
 908          {
 909   1        if( IfWifiIsLinked() == S_SUCCESS )
 910   1        {
 911   2          Wifi_ReportRemoteUnlockInfo(DpIdRemoteUnlock,1);
 912   2          WifiMgr.Ack.TimeOutCnt++;
 913   2        }
 914   1      }
 915          
 916          //发送请求远程开锁倒计时
 917          void WifiRemoteUnlockTimeSendExecute(uint16_t time)
 918          {
 919   1        if( IfWifiIsLinked() == S_SUCCESS )
 920   1        {
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/19/2023 13:57:33 PAGE 16  

 921   2          Wifi_ReportRemoteUnlockRequestCountdown(time);
 922   2          WifiMgr.Ack.TimeOutCnt++;
 923   2        }
 924   1      }
 925          
 926          //上报电量等级
 927          void WifiPowerLevelExecute(void)
 928          {
 929   1        if( IfWifiIsLinked() == S_SUCCESS )
 930   1        {
 931   2          switch(BatteryMgr.BatteryLevel)
 932   2          {
 933   3            case LEVEL_4:
 934   3              Wifi_ReportBatteryLevel(PowerLevelHigh);
 935   3              break;
 936   3            case LEVEL_3:
 937   3            case LEVEL_2:
 938   3              Wifi_ReportBatteryLevel(PowerLevelMedium);
 939   3              break;
 940   3            case LEVEL_1:
 941   3              Wifi_ReportBatteryLevel(PowerLevelLow);
 942   3              break;
 943   3            case LEVEL_0:
 944   3              Wifi_ReportBatteryLevel(PowerLevelEmpty);
 945   3              break;
 946   3            default:
 947   3              break;
 948   3          }
 949   2          WifiMgr.Ack.TimeOutCnt++;
 950   2        }
 951   1      }
 952          
 953          //系统锁定报警
 954          void WifiSysLockExecute(WifiAlarmType_t AlarmLock)
 955          {
 956   1        if( IfWifiIsLinked() == S_SUCCESS )
 957   1        {
 958   2          Wifi_ReportAlarmInfo(AlarmLock);
 959   2          WifiMgr.Ack.TimeOutCnt++;
 960   2        }
 961   1      }
 962          
 963          //wifi请求格林时间
 964          void WifiRequestGreenTimeExecute()
 965          {
 966   1        if( IfWifiIsLinked() == S_SUCCESS )
 967   1        {
 968   2          Wifi_SendGreenTimeRequest();
 969   2          WifiMgr.Ack.TimeOutCnt++;
 970   2        }
 971   1      }
 972          
 973          //wifi临时密码认证
 974          void WifiTempPasscodeIdentify(uint8_t BUFF[],uint8_t LEN)
 975          {
 976   1        if( IfWifiIsLinked() == S_SUCCESS )
 977   1        {
 978   2          Wifi_SendOfflineTmpPWD(BUFF,LEN);
 979   2        }
 980   1      }
 981          
 982          //wifi离线临时密码上报
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/19/2023 13:57:33 PAGE 17  

 983          void WifiTempPasscodeExecute(uint8_t DpID)
 984          {
 985   1        if( IfWifiIsLinked() == S_SUCCESS )
 986   1        {
 987   2          Wifi_ReportTempPasscode(DpID);
 988   2          WifiMgr.Ack.TimeOutCnt++;
 989   2        }
 990   1      }
 991          
 992          //和云端同步管理员和用户
 993          void WifiSyncExecute(uint8_t SyncType)
 994          {
 995   1        uint8_t MasterNum, UserNum, TotalNum;
 996   1        uint8_t AvailabeID[100]={0};
 997   1        uint8_t i;
 998   1        
 999   1        if( IfWifiIsLinked() == S_SUCCESS )
1000   1        {
1001   2          if( SyncType == DpIdFingerSync )
1002   2          {
1003   3            MasterNum = Get_Availabe_FPmasterID()-1;
1004   3            UserNum = Get_Availabe_FPuserID()-11;
1005   3            TotalNum = MasterNum + UserNum;
1006   3            for( i = 0; i < MasterNum; i++ )
1007   3            {
1008   4              AvailabeID[i] = i+1;
1009   4            }
1010   3            for( i = 0; i < UserNum; i++ )
1011   3            {
1012   4              AvailabeID[ MasterNum + i ] = i+11;
1013   4            }
1014   3            Wifi_ReportAllUserDeviceId(DpIdFingerSync,AvailabeID,(uint16_t)TotalNum);
1015   3          }
1016   2          else if( SyncType == DpIdPasswordSync )
1017   2          {
1018   3            MasterNum = CheckHowManyRegisteredPasscodeMaster();
1019   3            UserNum = CheckHowManyRegisteredPasscodeUser();
1020   3            TotalNum = MasterNum + UserNum;
1021   3            for( i = 0; i < MasterNum; i++ )
1022   3            {
1023   4              AvailabeID[i] = i+1;
1024   4            }
1025   3            for( i = 0; i < UserNum; i++ )
1026   3            {
1027   4              AvailabeID[ MasterNum + i ] = i+3;
1028   4            }
1029   3            Wifi_ReportAllUserDeviceId(DpIdPasswordSync,AvailabeID,(uint16_t)TotalNum);
1030   3          }
1031   2          else if( SyncType == DpIdCardSync )
1032   2          {
1033   3            TotalNum = CheckHowManyRegisteredCardUser();
1034   3            for( i = 0; i < TotalNum; i++ )
1035   3            {
1036   4              AvailabeID[i] = i+1;
1037   4            }
1038   3            Wifi_ReportAllUserDeviceId(DpIdCardSync,AvailabeID,(uint16_t)TotalNum);
1039   3          }
1040   2          WifiMgr.Ack.TimeOutCnt++;
1041   2        }
1042   1      }
1043          
1044          //远程开锁倒计时上报
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/19/2023 13:57:33 PAGE 18  

1045          void WifiRemoteUnlockCountdown(void)
1046          {
1047   1        if( IfWifiIsLinked() == S_SUCCESS )
1048   1        {
1049   2          if( WifiMgr.PostMgr.RemoteUnlockCountdown > 0 )
1050   2          {
1051   3            WifiMgr.PostMgr.RemoteUnlockCountdown--;
1052   3            WifiMgr.PostMgr.Flag.Bits.DoorBell = 1;
1053   3          }
1054   2        }
1055   1      }
1056            
1057          //WIFI指令发送
1058          void WifiCMD_Post(void)
1059          {
1060   1        //250ms发一次命令，不同命令通过标志位缓存，依照优先级发送
1061   1        if( WifiMgr.PostMgr.WifiPostIntervalCnt <= 0 )
1062   1        {
1063   2          WifiMgr.PostMgr.SendingFlag.TotalFlagBits = 0;
1064   2          if( WifiMgr.PostMgr.Flag.Bits.Info != 0 )
1065   2          {
1066   3            WifiMgr.PostMgr.Flag.Bits.Info = 0;//回复型指令只发一次，不做失败重发
1067   3            Wifi_SendProjectInfo();//发送设备信息
1068   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1069   3          }
1070   2          else if( WifiMgr.PostMgr.Flag.Bits.StartNetwork != 0 )
1071   2          {
1072   3            WifiMgr.PostMgr.SendingFlag.Bits.StartNetwork = 1;
1073   3            Wifi_SendSmartNetworkConfig();//发送开锁配网指令
1074   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1075   3          }
1076   2          else if( WifiMgr.PostMgr.Flag.Bits.WifiState != 0 )
1077   2          {
1078   3            WifiMgr.PostMgr.Flag.Bits.WifiState = 0;//回复型指令只发一次，不做失败重发
1079   3            Wifi_SendLinkNetworkAck();//联网成功应答
1080   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1081   3          }
1082   2          else if ( WifiMgr.PostMgr.Flag.Bits.AnswerCmd != 0 )
1083   2          {
1084   3            WifiMgr.PostMgr.Flag.Bits.AnswerCmd = 0;//回复型指令只发一次，不做失败重发
1085   3            Wifi_SendGotCMDAck();//获取指令应答
1086   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1087   3          }
1088   2          else if ( WifiMgr.PostMgr.Flag.Bits.RequestRemoteUnlockPassword != 0 )
1089   2          {
1090   3            WifiMgr.PostMgr.SendingFlag.Bits.RequestRemoteUnlockPassword = 1;
1091   3            WifiRequestRemoteUnlockKeyExecute();//请求远程开锁密匙
1092   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1093   3          }
1094   2          else if ( WifiMgr.PostMgr.Flag.Bits.Alarm != 0 )
1095   2          {
1096   3            //WifiMgr.PostMgr.Flag.Bits.Alarm = 0;
1097   3            WifiMgr.PostMgr.SendingFlag.Bits.Alarm = 1;
1098   3            WifiSysLockExecute(WifiMgr.PostMgr.AlarmType);//系统锁定记录上报
1099   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1100   3          }
1101   2          else if ( WifiMgr.PostMgr.Flag.Bits.DoorBell != 0 )
1102   2          {
1103   3            //WifiMgr.PostMgr.Flag.Bits.DoorBell = 0;
1104   3            WifiMgr.PostMgr.SendingFlag.Bits.DoorBell = 1;
1105   3            WifiRemoteUnlockTimeSendExecute(WifiMgr.PostMgr.RemoteUnlockCountdown);//发送请求远程开锁倒计时
1106   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/19/2023 13:57:33 PAGE 19  

1107   3          }
1108   2          else if ( WifiMgr.PostMgr.Flag.Bits.Unlock != 0 )
1109   2          {
1110   3            WifiMgr.PostMgr.SendingFlag.Bits.Unlock = 1;
1111   3            WifiUnlockInfoExecute();//开锁信息上报
1112   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1113   3          }
1114   2          else if ( WifiMgr.PostMgr.Flag.Bits.RemoteUnlock != 0 )
1115   2          {
1116   3            WifiMgr.PostMgr.SendingFlag.Bits.RemoteUnlock = 1;
1117   3            WifiRemoteUnlockSuccessExecute();//远程开锁信息上报
1118   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1119   3          }
1120   2          else if ( WifiMgr.PostMgr.Flag.Bits.RequestGreenTime != 0 )
1121   2          {
1122   3            WifiMgr.PostMgr.SendingFlag.Bits.RequestGreenTime = 1;
1123   3            WifiRequestGreenTimeExecute();//请求格林时间
1124   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1125   3          }
1126   2          else if ( WifiMgr.PostMgr.Flag.Bits.TempPasswordUnlock != 0 )
1127   2          {
1128   3            WifiMgr.PostMgr.SendingFlag.Bits.TempPasswordUnlock = 1;
1129   3            WifiTempPasscodeExecute(DpIdOfflineTmpPWDUnlock);//离线临时密码开锁上报
1130   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1131   3          }
1132   2          else if ( WifiMgr.PostMgr.Flag.Bits.DeleteTempPassword != 0 )
1133   2          {
1134   3            WifiMgr.PostMgr.SendingFlag.Bits.DeleteTempPassword = 1;
1135   3            WifiTempPasscodeExecute(DpIdOfflineDeleteCode);//离线临时密码清空码上报
1136   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1137   3          }
1138   2          else if ( WifiMgr.PostMgr.Flag.Bits.TempPasswordCheck != 0 )
1139   2          {
1140   3            //对于只可使用一次密码，重发可能会导致结果出错，此处不做重发判定
1141   3            WifiMgr.PostMgr.Flag.Bits.TempPasswordCheck = 0;
1142   3            WifiMgr.OfflineTempPassword.Status = TempPswdChecking;
1143   3            WifiMgr.OfflineTempPassword.TempPswdCnt = Def_GuiTimeDelayCnt1s5;//1.5s没收到回复视为超时
1144   3            WifiTempPasscodeIdentify(PasscodeInputMgr.InputBuff,10);//临时密码认证
1145   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1146   3          }
1147   2          else if ( WifiMgr.PostMgr.Flag.Bits.PowerLevel != 0 )
1148   2          {
1149   3            WifiMgr.PostMgr.SendingFlag.Bits.PowerLevel = 1;
1150   3            WifiPowerLevelExecute();//电池电量发送
1151   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1152   3          }
1153   2          else if ( WifiMgr.PostMgr.Flag.Bits.FingerSync != 0 )
1154   2          {
1155   3            WifiMgr.PostMgr.SendingFlag.Bits.FingerSync = 1;
1156   3            WifiSyncExecute(DpIdFingerSync);//同步指纹用户
1157   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1158   3          }
1159   2          else if ( WifiMgr.PostMgr.Flag.Bits.PasswordSync != 0 )
1160   2          {
1161   3            WifiMgr.PostMgr.SendingFlag.Bits.PasswordSync = 1;
1162   3            WifiSyncExecute(DpIdPasswordSync);//同步密码用户
1163   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1164   3          }
1165   2          else if ( WifiMgr.PostMgr.Flag.Bits.CardSync != 0 )
1166   2          {
1167   3            WifiMgr.PostMgr.SendingFlag.Bits.CardSync = 1;
1168   3            WifiSyncExecute(DpIdCardSync);//同步卡片用户
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/19/2023 13:57:33 PAGE 20  

1169   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1170   3          }
1171   2          else if ( WifiMgr.PostMgr.Flag.Bits.SaveKeySuccess != 0 )
1172   2          {
1173   3            WifiMgr.PostMgr.SendingFlag.Bits.SaveKeySuccess = 1;
1174   3            WifiSaveKeySuccessExecute();//远程开锁密匙保存成功上报
1175   3            WifiMgr.RemoteUnlockMgr.RequestRemoteUnlockisReady = bTRUE;
1176   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1177   3          }
1178   2      //    else
1179   2      //    {
1180   2      //      //无事件时回复
1181   2      //      Wifi_SendGotCMDAck();
1182   2      //      WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1183   2      //    }
1184   2        }
1185   1        
1186   1        if( WifiMgr.PostMgr.WifiPostIntervalCnt > 0 )
1187   1        {
1188   2          WifiMgr.PostMgr.WifiPostIntervalCnt--;
1189   2        }
1190   1      }
1191          
1192          //WIFI指令处理
1193          void WifiCMD_Excute(void)
1194          {
1195   1        uint8_t i;
1196   1        uint16_t CmdLenth,CKS,TempCKS;
1197   1        
1198   1        if ( UART1_Mgr.Status != GotNewCmd ){
1199   2          return;
1200   2        }
1201   1        
1202   1        CmdLenth = (UART1_Mgr.RX_Buffer[4]*256) + UART1_Mgr.RX_Buffer[5] + 7;   
1203   1        
1204   1        if ( CmdLenth >= 80 ) 
1205   1        {
1206   2          UART1_Mgr.RX_DataPoint = 0x00;
1207   2          UART1_Mgr.Status = Idle; //处理模式
1208   2          return;
1209   2        }
1210   1        
1211   1        for (i=0;i<CmdLenth;i++)
1212   1        {
1213   2          WifiMgr.Ack.Buff[i] = UART1_Mgr.RX_Buffer[i];   
1214   2        }
1215   1        
1216   1        UART1_Mgr.RX_DataPoint = 0x00;
1217   1        UART1_Mgr.Status = Idle;
1218   1        
1219   1        CKS = GetCheckSum(WifiMgr.Ack.Buff,CmdLenth-1);
1220   1      
1221   1        TempCKS = WifiMgr.Ack.Buff[CmdLenth-1];
1222   1        
1223   1        if ( CKS!=TempCKS )
1224   1        {
1225   2          WifiMgr.Ack.Status = WifiAckIdle; 
1226   2          return;   //if check sum is failed, ignore this data strin
1227   2        }
1228   1        WifiMgr.OFFPowerCnt = 0;
1229   1        WifiDataHandle(WifiMgr.Ack.Buff);
1230   1      }
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/19/2023 13:57:33 PAGE 21  

1231          
1232          //结束远程开锁流程
1233          void WifiRemoteUnlockStop(void)
1234          {
1235   1        WifiMgr.RemoteUnlockMgr.Result = IsUnknow;
1236   1        WifiMgr.RemoteUnlockMgr.Status = RemoteUnlockStandby;
1237   1        WifiMgr.PostMgr.Flag.Bits.DoorBell = 1;
1238   1        WifiMgr.PostMgr.RemoteUnlockCountdown = 0;
1239   1      }
1240            
1241          //wifi模块主循环
1242          void Wifi_Handle(void)
1243          {
1244   1        //处理ack标志位
1245   1        if( WifiMgr.Ack.Status != 0 )
1246   1        {
1247   2          switch(WifiMgr.Ack.Status)
1248   2          {
1249   3            case GotProjectInfoCmdACK:
1250   3              WifiMgr.PostMgr.Flag.Bits.Info = 1;
1251   3              break;
1252   3            case WaitWifiStateCmdACK:
1253   3              WifiMgr.PostMgr.Flag.Bits.WifiState = 1;
1254   3              break;
1255   3            case WifiAnswerCmdACK:
1256   3              WifiMgr.PostMgr.Flag.Bits.AnswerCmd = 1;
1257   3              break;
1258   3            /*
1259   3            case xxx:
1260   3              break;
1261   3            */
1262   3            default:
1263   3              break;
1264   3          }
1265   2          WifiMgr.Ack.Status = WifiAckIdle;
1266   2        }
1267   1        //模块超时未应答处理
1268   1        if( WifiMgr.Ack.TimeOutCnt > 20 )
1269   1        {
1270   2          SET_WIFIPOWER_OFF;
1271   2          Soft_Delay1ms(1);
1272   2          SET_WIFIPOWER_ON;
1273   2          Wifi_Rst();
1274   2        }
1275   1        //远程开锁密匙请求（联网后1.5s发送请求）
1276   1        if( WifiMgr.RemoteUnlockMgr.RequestPasswordTimeCnt > 0 )
1277   1        {
1278   2          WifiMgr.RemoteUnlockMgr.RequestPasswordTimeCnt--;
1279   2          if( WifiMgr.RemoteUnlockMgr.RequestPasswordTimeCnt == 0 )
1280   2          {
1281   3            WifiMgr.PostMgr.Flag.Bits.RequestRemoteUnlockPassword = 1;
1282   3            WifiMgr.RemoteUnlockMgr.Status = RemoteUnlockRequestPassword;
1283   3          }
1284   2        }
1285   1        //远程开锁开始请求开门
1286   1        if( ( WifiMgr.RemoteUnlockMgr.WaitRequestRemoteUnlock  == bTRUE )&& \
1287   1            ( WifiMgr.RemoteUnlockMgr.RequestRemoteUnlockisReady == bTRUE ) )
1288   1        {
1289   2          WifiMgr.RemoteUnlockMgr.WaitRequestRemoteUnlock = bFALSE;
1290   2          WifiMgr.PostMgr.Flag.Bits.DoorBell = 1;
1291   2          WifiMgr.RemoteUnlockMgr.Status = RemoteUnlockRequestWait;
1292   2          if( SystemPowerMgr.SleepDelayTimerCnt != 0 )
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/19/2023 13:57:33 PAGE 22  

1293   2          {
1294   3            WifiMgr.PostMgr.RemoteUnlockCountdown = Def_RemoteUnlockCountdown;
1295   3          }
1296   2          else
1297   2          {
1298   3            WifiMgr.PostMgr.RemoteUnlockCountdown = 0;
1299   3          }
1300   2          WifiMgr.RemoteUnlockMgr.Result = IsUnknow;
1301   2          SystemPowerMgr.SleepDelayTimerCnt = (Def_RemoteUnlockCountdown+1)*64;
1302   2        }
1303   1        //远程开锁时开锁判断
1304   1        if( WifiMgr.RemoteUnlockMgr.Status == RemoteUnlockRequestWait )
1305   1        {
1306   2          if( WifiMgr.PostMgr.RemoteUnlockCountdown > 0 )
1307   2          {
1308   3            if( WifiMgr.RemoteUnlockMgr.Result == IsSuccess )
1309   3            {
1310   4              //开锁
1311   4              UnlockSuccess(RemoteUnlock);
1312   4              //远程开锁上报
1313   4              WifiMgr.PostMgr.Flag.Bits.RemoteUnlock = 1;
1314   4              WifiRemoteUnlockStop();
1315   4            }
1316   3            else if( WifiMgr.RemoteUnlockMgr.Result == IsFail )
1317   3            {
1318   4              WifiRemoteUnlockStop();
1319   4            }
1320   3          }
1321   2          else{
1322   3            WifiRemoteUnlockStop();
1323   3          }
1324   2        }
1325   1        //离线临时密码开锁
1326   1        if( WifiMgr.OfflineTempPassword.Status == TempPswdChecking )
1327   1        {
1328   2          //超时返回错误
1329   2          if( WifiMgr.OfflineTempPassword.TempPswdCnt > 0 )
1330   2          {
1331   3            WifiMgr.OfflineTempPassword.TempPswdCnt--;
1332   3          }
1333   2          else{
1334   3            WifiMgr.OfflineTempPassword.Status = TempPswdWrong;
1335   3          }
1336   2        }
1337   1        else if( WifiMgr.OfflineTempPassword.Status == TempPswdCorrect )
1338   1        {
1339   2          WifiMgr.OfflineTempPassword.Status = TempPswdIdle;
1340   2          PasscodeUserIdentifyMgr.Status = PasscodeIdentifySuccess;
1341   2          PasscodeUserIdentifyMgr.UserID = 1;
1342   2          //PasscodeUserIdentifyMgr.TimeCnt =Def_IdendtifySuccessScreenTimeDelay;
1343   2          UserIdentifyResultMgr.PasscodeType = WifiTempPasscode;
1344   2        }
1345   1        else if( WifiMgr.OfflineTempPassword.Status == ClearCodeCorrect )
1346   1        {
1347   2          WifiMgr.OfflineTempPassword.Status = TempPswdIdle;
1348   2          PasscodeUserIdentifyMgr.Status = DeleteWifiTempPasscodeSuccess;
1349   2          WifiMgr.PostMgr.Flag.Bits.DeleteTempPassword = 1;
1350   2        }
1351   1        else if( WifiMgr.OfflineTempPassword.Status == TempPswdWrong )
1352   1        {
1353   2          WifiMgr.OfflineTempPassword.Status = TempPswdIdle;
1354   2          PasscodeUserIdentifyMgr.Status = PasscodeIdentifyFail;
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/19/2023 13:57:33 PAGE 23  

1355   2          //PasscodeUserIdentifyMgr.TimeCnt =Def_IdendtifyFailScreenTimeDelay;
1356   2        }
1357   1        //超时关闭wifi
1358   1        if( IfWifiIsLinked() == S_SUCCESS )
1359   1        {
1360   2          WifiMgr.OFFPowerCnt++;
1361   2          if( WifiMgr.OFFPowerCnt >= Def_GuiTimeDelayCnt5s )
1362   2          {
1363   3            Wifi_DeInit();
1364   3          }
1365   2        }
1366   1      }
1367          
1368          void Wifi_Mgr_Task(void)//16ms
1369          {
1370   1        if( WifiMgr.PowerState == WIFIPowerClosed )
1371   1        {
1372   2          if(( WifiMgr.PostMgr.Flag.TotalFlagBits != 0 )||( WifiMgr.RemoteUnlockMgr.WaitRequestRemoteUnlock == bTR
             -UE ))
1373   2          {
1374   3            Wifi_Init();
1375   3          }
1376   2        }
1377   1        else
1378   1        {
1379   2          WifiCMD_Post();
1380   2          WifiCMD_Excute();
1381   2          Wifi_Handle();
1382   2        }
1383   1      }
1384          
1385          //重置wifi相关数据
1386          void Wifi_Rst(void)
1387          {
1388   1        UART1_Mgr.RX_DataPoint = 0x00;
1389   1        UART1_Mgr.Status = Idle;
1390   1        WifiMgr.OFFPowerCnt = 0;
1391   1        WifiMgr.PostMgr.Flag.TotalFlagBits = 0;
1392   1        WifiMgr.PostMgr.SendingFlag.TotalFlagBits = 0;
1393   1        WifiMgr.PostMgr.WifiPostIntervalCnt = 0;
1394   1        WifiMgr.PostMgr.RemoteUnlockCountdown = 0;
1395   1        WifiMgr.Ack.Status = WifiAckIdle;
1396   1        WifiMgr.Ack.TimeOutCnt = 0;
1397   1        WifiMgr.WifiConnection.Status = NotConnected;
1398   1        WifiMgr.RemoteUnlockMgr.RequestPasswordTimeCnt = 0;
1399   1        WifiMgr.RemoteUnlockMgr.WaitRequestRemoteUnlock = bFALSE;
1400   1        WifiMgr.RemoteUnlockMgr.RequestRemoteUnlockisReady = bFALSE;
1401   1        WifiMgr.OfflineTempPassword.Status = TempPswdIdle;
1402   1      }
1403          
1404          void Wifi_Init(void)
1405          {
1406   1        SET_WIFIPOWER_ON;
1407   1        MX_UART1_Init();
1408   1        WifiMgr.PowerState = WIFIPowerOpened;
1409   1      }
1410          
1411          void Wifi_DeInit(void)
1412          {
1413   1        SET_WIFIPOWER_OFF;
1414   1        MX_UART1_DeInit();
1415   1        Wifi_Rst();
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/19/2023 13:57:33 PAGE 24  

1416   1        WifiMgr.PowerState = WIFIPowerClosed;
1417   1      }
1418          
1419          /********************Text************************/
1420          //uint8_t UserID[12] = {0x01, 0x12, 0x03, 0x04, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12};
1421          //uint8_t NewRemotePwd[6] = {0x01, 0x2, 0x03, 0x04, 0x10, 0x12};
1422          //void test_fun(void)
1423          //{
1424          //  Wifi_SendResetNetworkConfig();
1425          ////  Wifi_ReportUnlockInfo(DpIdCardUnlock, 200);
1426          ////  Wifi_ReportAlarmInfo(StayAlarm);
1427          ////  Wifi_ReportRemoteUnlockRequestCountdown(120);
1428          ////  Wifi_ReportBatteryLevel(PowerLevelMedium);
1429          ////  Wifi_ReportAPPRemoteUnlock(4);
1430          ////  Wifi_ReportStress(1);
1431          ////  Wifi_ReportDoorBellAwake(1);
1432          ////  Wifi_ReportAllUserDeviceId(0x1b, UserID, 12); //指纹0x19 密码0x1a 卡号0x1b
1433          ////  Wifi_ReportNewRemoteUnlockPwd(NewRemotePwd, 6);
1434          ////  Wifi_ReportRemoteUnlock(NewRemotePwd, 6);
1435          ////  Wifi_ReportMessage(NewRemotePwd, 6);
1436          //}
1437          //uint8_t dataTest[100] = {0};
1438          //void Wifi_SendTestAck(uint8_t lenth)
1439          //{
1440          //  uint16_t DataLen = lenth + 1;
1441          //  uint8_t* DataBuff = (uint8_t *) malloc(DataLen);
1442          //  uint8_t i = 0;
1443          //  
1444          //  memset(DataBuff, 0, DataLen);
1445          //  
1446          //  DataBuff[0] = lenth;
1447          
1448          //  for(i = 1; i <= lenth; i++) {
1449          //    //DataBuff[i] = dataTest[i-1];
1450          //  }
1451          
1452          //  if(DataBuff != NULL) {
1453          //    TuyaWIFISendFrame(REPORTED_MCU_SN_CMD,DataBuff,DataLen);
1454          //    free(DataBuff);
1455          //    DataBuff = NULL;
1456          //  }
1457          //}
1458          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5003    ----
   CONSTANT SIZE    =    337    ----
   XDATA SIZE       =     45     583
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

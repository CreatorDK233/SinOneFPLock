C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/20/2023 10:18:59 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE TUYAWIFI
OBJECT MODULE PLACED IN .\Objects\TuyaWIFI.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Drivers\Protocol\WIFI_Tuya\TuyaWIFI.c LARGE OMF2 OPTIMIZE(9,SPEED) BROWS
                    -E INCDIR(.\Drivers\Lib\c;.\Drivers\Lib\H;.\Drivers\Lib\IAP_Lib;.\Drivers\Lib\TouchKey_lib;.\Drivers\Physical;.\Drivers\P
                    -rotocol;.\Softwares\Application;.\Softwares\Basic;.\Softwares\ModuleLogic;.\Drivers\Protocol\YC_NFC;.\Drivers\Protocol\W
                    -IFI_Tuya) DEBUG PRINT(.\Listings\TuyaWIFI.lst) TABS(2) OBJECT(.\Objects\TuyaWIFI.obj)

line level    source

   1          #include "TuyaWIFI.h"
   2          
   3          #include "usart.h"
   4          #include "IO.h"
   5          #include "Basic_Function.h"
   6          #include "global_variable.h"
   7          
   8          #include "FP.h"
   9          #include "MFC.h"
  10          #include "GUI_Function.h"
  11          
  12          #include "stdlib.h"
  13          #include <string.h>
  14          
  15          
  16          #ifdef Function_TuyaWifi
  17          
  18          #define Def_WifiSendTime Def_GuiTimeDelayCnt025s
  19          
  20          extern PasscodeInputMgr_t PasscodeInputMgr;
  21          
  22          /**
  23           * @brief  计算校验和
  24           * @param[in] {pack} 数据源指针
  25           * @param[in] {pack_len} 计算校验和长度
  26           * @return 校验和
  27           */
  28          uint8_t GetCheckSum(uint8_t *pack, uint8_t pack_len)
  29          {
  30   1          uint8_t i;
  31   1          uint8_t check_sum = 0;
  32   1          
  33   1          for(i = 0; i < pack_len; i ++) {
  34   2              check_sum += *pack ++;
  35   2          }
  36   1          
  37   1          return check_sum;
  38   1      }
  39          
  40          /**
  41           * @brief  串口发送一段数据
  42           * @param[in] {in} 发送缓存指针
  43           * @param[in] {len} 数据发送长度
  44           * @return Null
  45           */
  46          static void TuyaWIFISendDatas(uint8_t *in, uint16_t SendLen)
  47          {
  48   1        Uart1SendStr(in,SendLen);
  49   1      }
  50          
  51          /**
  52           * @brief  向wifi串口发送一帧数据
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/20/2023 10:18:59 PAGE 2   

  53           * @param[in] {fr_type} 帧类型
  54           * @param[in] {*DataBuff} 数据
  55           * @param[in] {DataLen} 数据长度
  56           * @return Null
  57           */
  58          void TuyaWIFISendFrame(uint8_t fr_type, uint8_t *DataBuff,uint16_t DataLen)
  59          {
  60   1        uint8_t check_sum = 0;
  61   1        uint16_t i = 0;
  62   1        uint8_t TuyaWIFI_tx_buf[UART_MAX_LEN];
  63   1        
  64   1        TuyaWIFI_tx_buf[HEAD_FIRST] = FRAME_FIRST;
  65   1        TuyaWIFI_tx_buf[HEAD_SECOND] = FRAME_SECOND;
  66   1        TuyaWIFI_tx_buf[PROTOCOL_VERSION] = MCU_TX_VER;
  67   1        TuyaWIFI_tx_buf[FRAME_TYPE] = fr_type;
  68   1        TuyaWIFI_tx_buf[LENGTH_HIGH] = DataLen >> 8;
  69   1        TuyaWIFI_tx_buf[LENGTH_LOW] = DataLen & 0xff;
  70   1      
  71   1        for( i=0; i<DataLen; i++ )
  72   1        {
  73   2          TuyaWIFI_tx_buf[i+DATA_START] = *DataBuff;
  74   2          DataBuff++;
  75   2        }
  76   1        
  77   1        DataLen += PROTOCOL_HEAD;
  78   1        check_sum = GetCheckSum((uint8_t *)TuyaWIFI_tx_buf, DataLen - 1);
  79   1        TuyaWIFI_tx_buf[DataLen - 1] = check_sum;
  80   1      
  81   1        TuyaWIFISendDatas((uint8_t *)TuyaWIFI_tx_buf, DataLen);
  82   1      }
  83          
  84          /**
  85           * @brief  判断WIFI是否已连接
  86           * @param[in] void
  87           * @return status_t
  88           */
  89          status_t IfWifiIsLinked(void)
  90          {
  91   1        if( (WifiMgr.WifiConnection.Status == Connected) || (WifiMgr.WifiConnection.Status == JustConnected) )
  92   1        {
  93   2          return S_SUCCESS;
  94   2        }
  95   1        return S_FAIL;
  96   1      }
  97          
  98          /*  ASCII
  99          { 0x7b    } 0x7d    " 0x22    : 0x3a    , 0x2c    . 0x2e
 100          */
 101          // 产品信息：{"p":"ffxpgjqdnqalmkdk","v":"1.0.0","cap":11}
 102          uint8_t infoData[] = "{\"p\":\"sh0xpcipym5yiyck\",\"v\":\"1.0.0\",\"cap\":0}";
 103          
 104          // 发送产品信息
 105          void Wifi_SendProjectInfo(void)
 106          {
 107   1        uint16_t DataLen = sizeof(infoData)-1;
 108   1        uint8_t DataBuff[55] = {0};
 109   1        uint8_t i = 0;
 110   1        
 111   1        memset(DataBuff, 0, DataLen);
 112   1        
 113   1        for(i = 0; i < DataLen; i++) {
 114   2          DataBuff[i] = infoData[i];
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/20/2023 10:18:59 PAGE 3   

 115   2        }
 116   1      
 117   1      //  if(DataBuff != NULL) {
 118   1          TuyaWIFISendFrame(PRODUCT_INFO_CMD,DataBuff,DataLen);
 119   1      //    free(DataBuff);
 120   1      //    DataBuff = NULL;
 121   1      //  }
 122   1      }
 123          
 124          // 回复模块发送的联网状态信息
 125          void Wifi_SendLinkNetworkAck(void)
 126          {
 127   1      //  uint8_t buff[7]={0x55,0xAA,0x00,0x02,0x00,0x00,0x01};
 128   1        uint16_t DataLen = 0;
 129   1        uint8_t DataBuff[] = {0x00};
 130   1        TuyaWIFISendFrame(WIFI_STATE_CMD,DataBuff,DataLen);
 131   1      }
 132          
 133          // 重置WiFi
 134          void Wifi_SendResetNetworkConfig(void)
 135          {
 136   1        uint16_t DataLen = 0;
 137   1        uint8_t DataBuff[] = {0x00};
 138   1        TuyaWIFISendFrame(WIFI_RESET_CMD,DataBuff,DataLen);
 139   1      }
 140          
 141          // Smart配网
 142          void Wifi_SendSmartNetworkConfig(void)
 143          {
 144   1        uint16_t DataLen = 1;
 145   1        uint8_t DataBuff[] = {0x00};  // Smart: 0x00    AP: 0x01
 146   1        TuyaWIFISendFrame(WIFI_MODE_CMD,DataBuff,DataLen);
 147   1        WifiMgr.Ack.TimeOutCnt++;
 148   1      }
 149          
 150          // 实时状态上报
 151          // lenth 为buf长度
 152          // buf 是需要发送的几个pid的数据组合
 153          // 如 PID1 LEN1_H LEN1_L DATA1_1 DATA1_2 ... PID2 LEN2_H LEN2_L DATA2_1 DATA2_2 ...
 154          void Wifi_SendCurrentState(uint8_t lenth, uint8_t* buf)
 155          { 
 156   1        uint16_t DataLen = lenth;
 157   1        uint8_t* DataBuff = buf;
 158   1      
 159   1        TuyaWIFISendFrame(STATE_UPLOAD_CMD,DataBuff,DataLen);
 160   1      }
 161          
 162          // 记录型状态上报
 163          // lenth 为buf长度
 164          // buf 是需要发送的几个pid的数据组合
 165          // 如 PID1 LEN1_H LEN1_L DATA1_1 DATA1_2 ... PID2 LEN2_H LEN2_L DATA2_1 DATA2_2 ...
 166          void Wifi_SendRecordState(uint8_t lenth, uint8_t* buf)
 167          { 
 168   1        buf[0] = 0x02;  // 0 时间无效； 1 有效 当地时间； 2 有效 格林时间
 169   1        memcpy(buf+1, WifiMgr.OfflineTempPassword.GreenTime, 6);
 170   1        TuyaWIFISendFrame(STATE_RC_UPLOAD_CMD,buf,lenth);
 171   1      }
 172          
 173          // 回复模块的命令
 174          void Wifi_SendGotCMDAck(void)
 175          {
 176   1        uint16_t DataLen = 0;
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/20/2023 10:18:59 PAGE 4   

 177   1        uint8_t DataBuff[] = {0x00};
 178   1        TuyaWIFISendFrame(DATA_QUERT_CMD,DataBuff,DataLen);
 179   1      }
 180          
 181          // 查询网络时间
 182          void Wifi_SendLocalTimeRequest(void)
 183          {
 184   1        uint16_t DataLen = 0;
 185   1        uint8_t DataBuff[] = {0x00};
 186   1        TuyaWIFISendFrame(GET_LOCAL_TIME_CMD,DataBuff,DataLen);
 187   1      }
 188          
 189          // 查询格林时间
 190          void Wifi_SendGreenTimeRequest(void)
 191          {
 192   1        uint16_t DataLen = 0;
 193   1        uint8_t DataBuff[] = {0x00};
 194   1        TuyaWIFISendFrame(GET_GL_TIME_CMD,DataBuff,DataLen);
 195   1      }
 196          
 197          // 查询当前连接的路由器的信号强度
 198          void Wifi_SendNetworkRequest(void)
 199          {
 200   1        uint16_t DataLen = 0;
 201   1        uint8_t DataBuff[] = {0x00};
 202   1        TuyaWIFISendFrame(ROUTE_RSSI_CMD,DataBuff,DataLen);
 203   1      }
 204          
 205          // 获取云端临时密码
 206          void Wifi_SendTmpPwdRequest(void)
 207          {
 208   1        uint16_t DataLen = 0;
 209   1        uint8_t DataBuff[] = {0x00};
 210   1        TuyaWIFISendFrame(GET_TMP_PWD_CMD,DataBuff,DataLen);
 211   1      }
 212          
 213          // 获取DP缓存
 214          //void Wifi_SendDPCacheRequest(uint16_t num, uint8_t* id)
 215          //{
 216          //  uint16_t DataLen = num + 1;
 217          //  uint8_t* DataBuff = (uint8_t *) malloc(DataLen);
 218          //  uint8_t i = 0;
 219          //  
 220          //  memset(DataBuff, 0, DataLen);
 221          //  
 222          //  DataBuff[0] = num;  // DP 个数
 223          //  for(i = 1; i <= num; i++) {
 224          //    DataBuff[i] = id[i-1];
 225          //  }
 226          
 227          //  if(DataBuff != NULL) {
 228          //    TuyaWIFISendFrame(GET_DP_CACHE_CMD,DataBuff,DataLen);
 229          //    free(DataBuff);
 230          //    DataBuff = NULL;
 231          //  }
 232          //}
 233          
 234          // 离线动态密码
 235          // lenth 为pwd长度
 236          // pwd 离线密码
 237          void Wifi_SendOfflineTmpPWD(uint8_t* pwd, uint8_t lenth)
 238          { 
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/20/2023 10:18:59 PAGE 5   

 239   1        uint16_t DataLen = lenth + 7;
 240   1        uint8_t* DataBuff = (uint8_t *) malloc(DataLen);
 241   1        uint8_t i = 0;
 242   1        
 243   1        memset(DataBuff, 0, DataLen);
 244   1        memcpy(DataBuff, WifiMgr.OfflineTempPassword.GreenTime, 6);
 245   1        DataBuff[6] = lenth;  // 密码长度
 246   1        
 247   1        for(i = 0; i < lenth; i++) {
 248   2          DataBuff[7+i] = pwd[i];
 249   2        }
 250   1        if(DataBuff != NULL) {
 251   2          TuyaWIFISendFrame(GET_TMP_PWD_OFFLINE_CMD,DataBuff,DataLen);
 252   2          free(DataBuff);
 253   2          DataBuff = NULL;
 254   2        }
 255   1      }
 256          
 257          //离线临时密码上报
 258          void Wifi_ReportTempPasscode(uint8_t DpID)
 259          {
 260   1        //TuyaWIFISendFrame(STATE_UPLOAD_CMD,DataBuff,DataLen);
 261   1        uint16_t DataLen = 7 + 20;
 262   1        uint8_t DataBuff[7 + 20] = {0x00};
 263   1        DataBuff[7] = DpID;     // DP ID
 264   1        DataBuff[8] = 0x00;     // 数据类型
 265   1        DataBuff[9] = 0x00;     // 数据长度H
 266   1        DataBuff[10] = 0x10;    // 数据长度L
 267   1        memcpy(DataBuff+11, WifiMgr.OfflineTempPassword.DecryptingData, 16);
 268   1        //Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 269   1        Wifi_SendRecordState(DataLen, DataBuff);      // 记录型
 270   1      }
 271          
 272          // 上报SN
 273          // lenth 为SN长度
 274          // sn SN
 275          //void Wifi_Send_MCU_SN(uint8_t lenth, uint8_t* sn)
 276          //{
 277          //  uint16_t DataLen = lenth + 1;
 278          //  uint8_t* DataBuff = (uint8_t *) malloc(DataLen);
 279          //  uint8_t i = 0;
 280          //  memset(DataBuff, 0, DataLen);
 281          //  DataBuff[0] = lenth;  // SN 长度
 282          //  for(i = 1; i <= lenth; i++) {
 283          //    DataBuff[i] = sn[i-1];
 284          //  }
 285          //  if(DataBuff != NULL) {
 286          //    TuyaWIFISendFrame(REPORTED_MCU_SN_CMD,DataBuff,DataLen);
 287          //    free(DataBuff);
 288          //    DataBuff = NULL;
 289          //  }
 290          //}
 291          
 292          // 回复模块重置命令
 293          void Wifi_SendResetNoticeAck(void)
 294          {
 295   1        uint16_t DataLen = 0;
 296   1        uint8_t DataBuff[] = {0x00};
 297   1        TuyaWIFISendFrame(WIFI_RESET_NOTICE_CMD,DataBuff,DataLen);
 298   1      }
 299          
 300          // 获取WiFi状态
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/20/2023 10:18:59 PAGE 6   

 301          //#ifdef LOCK_KEEP_ALIVE
 302          //void Wifi_SendGetWIFIState(void)
 303          //{
 304          //  uint16_t DataLen = 0;
 305          //  uint8_t DataBuff[] = {0x00};
 306          //  TuyaWIFISendFrame(GET_WIFI_STATE_CMD,DataBuff,DataLen);
 307          //}
 308          //#endif
 309          
 310          //上报 解锁
 311          void Wifi_ReportUnlockInfo(uint8_t DpId, uint16_t id)
 312          {
 313   1        uint16_t DataLen = 7 + 8;
 314   1        uint8_t DataBuff[7 + 8] = {0x00};
 315   1        
 316   1        DataBuff[7] = DpId;           // DP ID
 317   1        DataBuff[8] = VALUE;          // 数据类型
 318   1        DataBuff[9] = 0x00;           // 数据长度H
 319   1        DataBuff[10] = 0x04;          // 数据长度L
 320   1        DataBuff[11] = 0x00;          // 数据
 321   1        DataBuff[12] = 0x00;          // 数据
 322   1        DataBuff[13] = id>>8;         // 数据
 323   1        DataBuff[14] = id;            // 数据
 324   1        Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 325   1      //  Wifi_SendRecordState(DataLen, DataBuff);      // 记录型
 326   1      }
 327          
 328          //上报 新免密远程开门-带秘钥
 329          void Wifi_ReportRemoteUnlockInfo(uint8_t DpId, uint16_t id)
 330          {
 331   1        uint16_t DataLen = 7 + 7;
 332   1        uint8_t DataBuff[7 + 7] = {0x00};
 333   1        
 334   1        DataBuff[7] = DpId;           // DP ID
 335   1        DataBuff[8] = RAW;          // 数据类型
 336   1        DataBuff[9] = 0x00;           // 数据长度H
 337   1        DataBuff[10] = 0x03;          // 数据长度L
 338   1        DataBuff[11] = 0x00;          // 成功
 339   1        DataBuff[12] = id>>8;         // 密匙编号
 340   1        DataBuff[13] = id;            // 密匙编号
 341   1        Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 342   1      //  Wifi_SendRecordState(DataLen, DataBuff);      // 记录型
 343   1      }
 344          
 345          //上报 组合开锁
 346          void Wifi_ReportCombinedUnlockInfo(uint8_t *DpId, uint16_t *id)
 347          {
 348   1        uint16_t DataLen = 7 + 16;
 349   1        uint8_t DataBuff[7 + 16] = {0x00};
 350   1        uint8_t i;
 351   1        uint8_t InfoNum = 2;
 352   1        
 353   1        for( i=0; i<InfoNum; i++ )
 354   1        {
 355   2          DataBuff[8*i+7] = *DpId;          // DP ID
 356   2          DataBuff[8*i+8] = VALUE;          // 数据类型
 357   2          DataBuff[8*i+9] = 0x00;           // 数据长度H
 358   2          DataBuff[8*i+10] = 0x04;          // 数据长度L
 359   2          DataBuff[8*i+11] = 0x00;          // 数据
 360   2          DataBuff[8*i+12] = 0x00;          // 数据
 361   2          DataBuff[8*i+13] = *id>>8;        // 数据
 362   2          DataBuff[8*i+14] = *id;           // 数据
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/20/2023 10:18:59 PAGE 7   

 363   2          if( i < (InfoNum-1) )
 364   2          {
 365   3            DpId++;
 366   3            id++;
 367   3          }
 368   2        }
 369   1        Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 370   1      //  Wifi_SendRecordState(DataLen, DataBuff);      // 记录型
 371   1      }
 372          
 373          //上报 告警
 374          void Wifi_ReportAlarmInfo(WifiAlarmType_t AlarmType)
 375          {
 376   1        uint16_t DataLen = 7 + 5;
 377   1        uint8_t DataBuff[7 + 5] = {0x00};
 378   1        
 379   1        DataBuff[7] = DpIdAlarm;      // DP ID
 380   1        DataBuff[8] = ENUM;           // 数据类型
 381   1        DataBuff[9] = 0x00;           // 数据长度H
 382   1        DataBuff[10] = 0x01;            // 数据长度L
 383   1        DataBuff[11] = AlarmType;       // 数据
 384   1      
 385   1        Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 386   1      //  Wifi_SendRecordState(DataLen, DataBuff);  // 记录型
 387   1      }
 388          
 389          //上报 远程开锁请求倒计时
 390          void Wifi_ReportRemoteUnlockRequestCountdown(uint16_t time)
 391          {
 392   1        uint16_t DataLen = 7 + 8;
 393   1        uint8_t DataBuff[7 + 8] = {0x00};
 394   1        
 395   1        DataBuff[7] = DpIdAPPUnlock;  // DP ID
 396   1        DataBuff[8] = VALUE;          // 数据类型
 397   1        DataBuff[9] = 0x00;           // 数据长度H
 398   1        DataBuff[10] = 0x04;            // 数据长度L
 399   1        DataBuff[11] = 0x00;            // 数据
 400   1        DataBuff[12] = 0x00;            // 数据
 401   1        DataBuff[13] = time>>8;         // 数据
 402   1        DataBuff[14] = time;            // 数据
 403   1      
 404   1        Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 405   1      //    Wifi_SendRecordState(DataLen, DataBuff);  // 记录型
 406   1      }
 407          
 408          //上报 电池电量状态
 409          void Wifi_ReportBatteryLevel(uint8_t BatteryLevel)
 410          {
 411   1        uint16_t DataLen = 7 + 5;
 412   1        uint8_t DataBuff[7 + 5] = {0x00};
 413   1        
 414   1        DataBuff[7] = DpIdBatteryLevel; // DP ID
 415   1        DataBuff[8] = ENUM;             // 数据类型
 416   1        DataBuff[9] = 0x00;             // 数据长度H
 417   1        DataBuff[10] = 0x01;            // 数据长度L
 418   1        DataBuff[11] = BatteryLevel;        // 数据
 419   1      
 420   1        Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 421   1      //  Wifi_SendRecordState(DataLen, DataBuff);  // 记录型
 422   1      }
 423          
 424          //上报 APP远程解锁
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/20/2023 10:18:59 PAGE 8   

 425          void Wifi_ReportAPPRemoteUnlock(uint16_t value)
 426          {
 427   1        uint16_t DataLen = 7 + 8;
 428   1        uint8_t DataBuff[7 + 8] = {0x00};
 429   1        
 430   1        DataBuff[7] = 0x0f;           // DP ID
 431   1        DataBuff[8] = VALUE;          // 数据类型
 432   1        DataBuff[9] = 0x00;           // 数据长度H
 433   1        DataBuff[10] = 0x04;            // 数据长度L
 434   1        DataBuff[11] = 0x00;            // 数据
 435   1        DataBuff[12] = 0x00;            // 数据
 436   1        DataBuff[13] = value>>8;          // 数据
 437   1        DataBuff[14] = value;         // 数据
 438   1        
 439   1        Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 440   1      //  Wifi_SendRecordState(DataLen, DataBuff);  // 记录型
 441   1      }
 442          
 443          //上报 被胁迫
 444          //void Wifi_ReportStress(uint8_t stress)
 445          //{
 446          //  uint16_t DataLen = 7 + 5;
 447          //  uint8_t DataBuff[7 + 5] = {0x00};
 448          //  
 449          //  DataBuff[7] = 0x10;           // DP ID
 450          //  DataBuff[8] = BOOL;           // 数据类型
 451          //  DataBuff[9] = 0x00;           // 数据长度H
 452          //  DataBuff[10] = 0x01;            // 数据长度L
 453          //  DataBuff[11] = stress;        // 数据
 454          
 455          //  Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 456          ////  Wifi_SendRecordState(DataLen, DataBuff);  // 记录型
 457          //}
 458          
 459          //上报 门铃呼叫
 460          //void Wifi_ReportDoorBellAwake(uint8_t on)
 461          //{
 462          //  uint16_t DataLen = 7 + 5;
 463          //  uint8_t DataBuff[7 + 5] = {0x00};
 464          //  
 465          //  DataBuff[7] = 0x13;           // DP ID
 466          //  DataBuff[8] = BOOL;           // 数据类型
 467          //  DataBuff[9] = 0x00;           // 数据长度H
 468          //  DataBuff[10] = 0x01;            // 数据长度L
 469          //  DataBuff[11] = on;            // 数据
 470          
 471          //  Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 472          ////  Wifi_SendRecordState(DataLen, DataBuff);  // 记录型
 473          //}
 474          
 475          //上报 请求远程开门密匙
 476          void Wifi_ReportRequestRemoteUnlockPassword()
 477          {
 478   1        uint16_t DataLen = 7 + 5;
 479   1        uint8_t DataBuff[7 + 5] = {0x00};
 480   1        
 481   1        DataBuff[7] = 0x31;           // DP ID
 482   1        DataBuff[8] = RAW;            // 数据类型
 483   1        DataBuff[9] = 0x00;           // 数据长度H
 484   1        DataBuff[10] = 0x01;            // 数据长度L
 485   1        DataBuff[11] = 0x01;            // 数据
 486   1      
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/20/2023 10:18:59 PAGE 9   

 487   1        Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 488   1      //  Wifi_SendRecordState(DataLen, DataBuff);  // 记录型
 489   1      }
 490          
 491          //上报 保存密匙成功
 492          void Wifi_ReportSaveKeySuccess()
 493          {
 494   1        uint16_t DataLen = 7 + 7;
 495   1        uint8_t DataBuff[7 + 7] = {0x00};
 496   1        
 497   1        DataBuff[7] = 0x31;           // DP ID
 498   1        DataBuff[8] = RAW;            // 数据类型
 499   1        DataBuff[9] = 0x00;           // 数据长度H
 500   1        DataBuff[10] = 0x03;            // 数据长度L
 501   1        DataBuff[11] = 0x00;            // 成功
 502   1        DataBuff[12] = 0x00;            // 密匙编号
 503   1        DataBuff[13] = 0x01;            // 密匙编号
 504   1      
 505   1        Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 506   1      //  Wifi_SendRecordState(DataLen, DataBuff);  // 记录型
 507   1      }
 508          
 509          //上报 同步所有 指纹0x19 密码0x1a 卡号0x1b ID
 510          void Wifi_ReportAllUserDeviceId(uint8_t DpId, uint8_t* id, uint16_t lenth)
 511          {
 512   1        uint16_t DataLen = 7 + 4 + lenth;
 513   1        uint8_t* DataBuff = (uint8_t *) malloc(DataLen);
 514   1        uint8_t i = 0;
 515   1        memset(DataBuff, 0, DataLen);
 516   1      
 517   1        DataBuff[7] = DpId;           // DP ID
 518   1        DataBuff[8] = RAW;            // 数据类型
 519   1        DataBuff[9] = lenth>>8;         // 数据长度H
 520   1        DataBuff[10] = lenth;         // 数据长度L
 521   1      
 522   1      //  for(i = 4; i < DataLen; i++) {
 523   1      //    DataBuff[i] = id[i-4];        // 数据
 524   1      //  }
 525   1        memcpy(DataBuff+4+7, id, lenth);    // 数据
 526   1        
 527   1        if(DataBuff != NULL) {
 528   2          Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 529   2      //    Wifi_SendRecordState(DataLen, DataBuff);  // 记录型
 530   2          free(DataBuff);
 531   2          DataBuff = NULL;
 532   2        }
 533   1      }
 534          
 535          //上报 设置新免密远程开锁密钥
 536          //void Wifi_ReportNewRemoteUnlockPwd(uint8_t* newPwd, uint16_t lenth)
 537          //{
 538          //  uint16_t DataLen = 7 + 4 + lenth;
 539          //  uint8_t* DataBuff = (uint8_t *) malloc(DataLen);
 540          //  uint8_t i = 0;
 541          //  memset(DataBuff, 0, DataLen);
 542          //  
 543          //  DataBuff[7] = 0x31;           // DP ID
 544          //  DataBuff[8] = RAW;            // 数据类型
 545          //  DataBuff[9] = lenth>>8;         // 数据长度H
 546          //  DataBuff[10] = lenth;         // 数据长度L
 547          
 548          //  memcpy(DataBuff+4+7, newPwd, lenth);    // 数据
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/20/2023 10:18:59 PAGE 10  

 549          
 550          //  if(DataBuff != NULL) {
 551          //    Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 552          ////    Wifi_SendRecordState(DataLen, DataBuff);  // 记录型
 553          //    free(DataBuff);
 554          //    DataBuff = NULL;
 555          //  }
 556          //}
 557          
 558          //上报 免密远程开锁
 559          //void Wifi_ReportRemoteUnlock(uint8_t* Pwd, uint16_t lenth)
 560          //{
 561          //  uint16_t DataLen = 7 + 4 + lenth;
 562          //  uint8_t* DataBuff = (uint8_t *) malloc(DataLen);
 563          //  uint8_t i = 0;
 564          //  memset(DataBuff, 0, DataLen);
 565          //  
 566          //  DataBuff[7] = 0x32;           // DP ID
 567          //  DataBuff[8] = RAW;            // 数据类型
 568          //  DataBuff[9] = lenth>>8;         // 数据长度H
 569          //  DataBuff[10] = lenth;         // 数据长度L
 570          
 571          //  memcpy(DataBuff+4+7, Pwd, lenth);   // 数据
 572          
 573          //  if(DataBuff != NULL) {
 574          //    Wifi_SendCurrentState(DataLen - 7, DataBuff + 7); // 实时
 575          ////    Wifi_SendRecordState(DataLen, DataBuff);  // 记录型
 576          //    free(DataBuff);
 577          //    DataBuff = NULL;
 578          //  }
 579          //}
 580          
 581          //上报 主动消息推送
 582          //void Wifi_ReportMessage(uint8_t* Msg, uint16_t lenth)
 583          //{
 584          //  uint16_t DataLen = 7 + 4 + lenth;
 585          //  uint8_t* DataBuff = (uint8_t *) malloc(DataLen);
 586          //  uint8_t i = 0;
 587          //  memset(DataBuff, 0, DataLen);
 588          //  
 589          //  DataBuff[7] = 0xd4;           // DP ID
 590          //  DataBuff[8] = RAW;            // 数据类型
 591          //  DataBuff[9] = lenth>>8;         // 数据长度H
 592          //  DataBuff[10] = lenth;         // 数据长度L
 593          
 594          //  memcpy(DataBuff+4+7, Msg, lenth);   // 数据
 595          
 596          //  if(DataBuff != NULL) {
 597          //    Wifi_SendCurrentState(DataLen- 7, DataBuff + 7);  // 实时
 598          ////    Wifi_SendRecordState(DataLen, DataBuff);  // 记录型
 599          //    free(DataBuff);
 600          //    DataBuff = NULL;
 601          //  }
 602          //}
 603          
 604          /**
 605           * @brief  数据帧处理
 606           * @param[in] {offset} 数据起始位
 607           * @return Null
 608           */
 609          //uint8_t rssi = 0; // WiFi信号强度
 610          //uint8_t tmppwd[12] = 0; // WiFi信号强度
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/20/2023 10:18:59 PAGE 11  

 611          
 612          void WifiDataHandle(uint8_t *offset)
 613          {
 614   1        uint8_t cmd_type,i = 0;
 615   1        uint8_t TempPswd[8] = {0};
 616   1        uint16_t cmd_lenth = 0;
 617   1        uint32_t Temp_sendingflag = 0;
 618   1      
 619   1        if(offset == NULL){return;}
 620   1        cmd_type = offset[3];
 621   1        cmd_lenth &= offset[4] << 8;
 622   1        cmd_lenth += offset[5];
 623   1        WifiMgr.OFFPowerCnt = 0;
 624   1        
 625   1        switch(cmd_type) 
 626   1        {
 627   2          case PRODUCT_INFO_CMD:  // 模块查询MCU信息
 628   2            WifiMgr.Ack.Status = GotProjectInfoCmdACK;
 629   2            break;
 630   2          
 631   2          case WIFI_STATE_CMD:  // 模块上报设备状态
 632   2            if(cmd_lenth > 0) 
 633   2            {
 634   3              if(offset[6] == 0x04) 
 635   3              {
 636   4                WifiMgr.WifiConnection.Status = JustConnected;
 637   4                WifiMgr.PostMgr.Flag.Bits.PowerLevel = 1;
 638   4                WifiMgr.RemoteUnlockMgr.RequestPasswordTimeCnt = Def_GuiTimeDelayCnt1s;
 639   4              }
 640   3            }
 641   2            WifiMgr.Ack.Status = WaitWifiStateCmdACK;
 642   2            break;
 643   2          
 644   2          case WIFI_RESET_CMD:  // 模块回复重置WiFi指令
 645   2            WifiMgr.WifiConnection.Status = NotConnected;
 646   2            break;
 647   2          case WIFI_MODE_CMD: // 重置WiFi 选择配置模式
 648   2            if(offset[5] == 0x00) 
 649   2            {
 650   3              WifiMgr.PostMgr.Flag.Bits.StartNetwork = 0;
 651   3              WifiMgr.Ack.TimeOutCnt = 0;
 652   3            }
 653   2            break;
 654   2          case ROUTE_RSSI_CMD:  // 模块回复WiFi信号强度
 655   2            if(cmd_lenth > 0) {
 656   3              if(offset[6] == 0x01) { // 成功
 657   4                //rssi = offset[7]; // WiFi信号强度 0 ~ 100
 658   4              }
 659   3              else
 660   3              {
 661   4                // 模块未连接路由器
 662   4              }
 663   3            }
 664   2            break;
 665   2      
 666   2          case STATE_UPLOAD_CMD:  // 模块回复实时状态指令
 667   2            if(cmd_lenth > 0) {
 668   3              if(offset[6] == 0x00) {
 669   4                // 执行成功
 670   4                Temp_sendingflag = WifiMgr.PostMgr.SendingFlag.TotalFlagBits;
 671   4                WifiMgr.PostMgr.Flag.TotalFlagBits  &= ~Temp_sendingflag;
 672   4                WifiMgr.Ack.TimeOutCnt = 0;
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/20/2023 10:18:59 PAGE 12  

 673   4              } else if(offset[6] == 0x01) {
 674   4                // 执行失败
 675   4      
 676   4              }
 677   3            }   
 678   2            break;
 679   2            
 680   2          case STATE_RC_UPLOAD_CMD: // 模块回复记录型状态指令
 681   2            if(cmd_lenth > 0) {
 682   3              Temp_sendingflag = WifiMgr.PostMgr.SendingFlag.TotalFlagBits;
 683   3              WifiMgr.PostMgr.Flag.TotalFlagBits  &= ~Temp_sendingflag;
 684   3              WifiMgr.Ack.TimeOutCnt = 0;
 685   3      //        if(offset[6] == 0x00) {
 686   3      //          // 记录成功
 687   3      //        } else if(offset[6] == 0x01) {
 688   3      //          // 当前记录上报成功，且还有滞留记录需要上报
 689   3      //        } else if(offset[6] == 0x02) {
 690   3      //          // 记录失败
 691   3      //        }
 692   3            }   
 693   2            break;
 694   2            
 695   2          case GET_GL_TIME_CMD:
 696   2            if(cmd_lenth > 0) 
 697   2            {
 698   3              if(offset[6] == 0x01)
 699   3              {
 700   4                memcpy(WifiMgr.OfflineTempPassword.GreenTime, offset+7, 6);
 701   4                WifiMgr.PostMgr.Flag.Bits.RequestGreenTime = 0;
 702   4                WifiMgr.Ack.TimeOutCnt = 0;
 703   4                WifiMgr.PostMgr.Flag.Bits.TempPasswordCheck = 1;
 704   4              }
 705   3            }
 706   2            break;
 707   2      
 708   2          case DATA_QUERT_CMD:  // 模块命令下发
 709   2            if(cmd_lenth > 0) 
 710   2            {
 711   3              if( (offset[5] == 0x19) &&  (offset[6] == 0x31) && (offset[9] == 0x15) ) 
 712   3              {
 713   4                if( WifiMgr.RemoteUnlockMgr.Status == RemoteUnlockRequestPassword )
 714   4                {
 715   5                  memcpy(WifiMgr.RemoteUnlockMgr.Passward, offset+23, 8);
 716   5                  WifiMgr.RemoteUnlockMgr.Status = RemoteUnlockStandby;
 717   5                  WifiMgr.PostMgr.Flag.Bits.SaveKeySuccess = 1;
 718   5                }
 719   4              }
 720   3              else if( offset[6] == 0x32 ) 
 721   3              {
 722   4                if( WifiMgr.RemoteUnlockMgr.Status == RemoteUnlockRequestWait )
 723   4                {
 724   5                  if( offset[5] != 0x11 )
 725   5                  {
 726   6                    WifiMgr.RemoteUnlockMgr.Result = IsFail;
 727   6                  }
 728   5                  else
 729   5                  {
 730   6                    memcpy(TempPswd, offset+13, 8);
 731   6                    for(i=0;i<8;i++)
 732   6                    {
 733   7                      if( TempPswd[i] != WifiMgr.RemoteUnlockMgr.Passward[i] )
 734   7                      {
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/20/2023 10:18:59 PAGE 13  

 735   8                        WifiMgr.RemoteUnlockMgr.Result = IsFail;
 736   8                        break;
 737   8                      }
 738   7                      if( i == 7 )
 739   7                      {
 740   8                        WifiMgr.RemoteUnlockMgr.Result = IsSuccess;
 741   8                      }
 742   7                    }
 743   6                  }
 744   5                }
 745   4              }
 746   3              WifiMgr.Ack.Status = WifiAnswerCmdACK;
 747   3            }
 748   2            break;
 749   2            
 750   2        //  case GET_TMP_PWD_CMD: // 模组回复一组临时密码
 751   2        //    if(cmd_lenth > 0) {
 752   2        //      if(offset[6] == 0x01) { // 成功
 753   2        //        tmppwd[0] = offset[7];  // 年
 754   2        //        tmppwd[1] = offset[8];  // 月
 755   2        //        tmppwd[2] = offset[9];  // 日
 756   2        //        tmppwd[3] = offset[10]; // 时
 757   2        //        tmppwd[4] = offset[11]; // 分
 758   2        //        tmppwd[5] = offset[12]; // 秒
 759   2        //        // 模拟发送该指令，没有收到测试工具返回密码，后续添加
 760   2        //      }
 761   2        //      else
 762   2        //      {
 763   2        //        // 获取失败
 764   2        //      }
 765   2        //    }
 766   2        //    
 767   2        //    dataTest[0] = cmd_lenth;
 768   2        //    Wifi_SendTestAck(1);
 769   2        //    break;
 770   2        
 771   2          case GET_TMP_PWD_OFFLINE_CMD:
 772   2            if(cmd_lenth > 0) 
 773   2            {
 774   3              if( offset[6] == 0x00 )
 775   3              {
 776   4                if( offset[7] == 0x00 || offset[7] == 0x01 )
 777   4                {
 778   5                  //开锁成功
 779   5                  if( WifiMgr.OfflineTempPassword.Status == TempPswdChecking )
 780   5                  {
 781   6                    memcpy(WifiMgr.OfflineTempPassword.DecryptingData, offset+9, 16);
 782   6                    WifiMgr.OfflineTempPassword.Status = TempPswdCorrect;
 783   6                  }
 784   5                }
 785   4                else if( offset[7] == 0x02 )
 786   4                {
 787   5                  //操作成功
 788   5                  if( WifiMgr.OfflineTempPassword.Status == TempPswdChecking )
 789   5                  {
 790   6                    if( offset[8] == 0x10 )
 791   6                    {
 792   7                      memcpy(WifiMgr.OfflineTempPassword.DecryptingData, offset+9, 16);
 793   7                    }
 794   6                    WifiMgr.OfflineTempPassword.Status = ClearCodeCorrect;
 795   6                  }
 796   5                }
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/20/2023 10:18:59 PAGE 14  

 797   4              }
 798   3              else
 799   3              {
 800   4                //验证失败
 801   4                if( WifiMgr.OfflineTempPassword.Status == TempPswdChecking )
 802   4                {
 803   5                  WifiMgr.OfflineTempPassword.Status = TempPswdWrong;
 804   5                }
 805   4              }
 806   3              
 807   3            }
 808   2            break;
 809   2          
 810   2          default:
 811   2            break;  
 812   2        }
 813   1      }
 814          
 815          //获取开锁类型和用户编号
 816          void GotIdentifyResult(uint8_t *Type, uint16_t *ID)
 817          {
 818   1        switch(UserIdentifyResultMgr.IdentifyType)
 819   1        {
 820   2          case CARD:
 821   2            *Type ++ = DpIdCardUnlock;
 822   2            *Type = 0;
 823   2            *ID ++ = (uint16_t)UserIdentifyResultMgr.CardUserID;
 824   2            *ID = 0;
 825   2            break;
 826   2          case PASSCODE:
 827   2            *Type ++ = DpIdPasswordUnlock;
 828   2            *Type = 0;
 829   2            *ID ++ = (uint16_t)UserIdentifyResultMgr.PasscodeUserID;
 830   2            *ID = 0;
 831   2            break;
 832   2          case FINGERPRINT:
 833   2            *Type ++ = DpIdFingerUnlock;
 834   2            *Type = 0;
 835   2            *ID ++ = (uint16_t)UserIdentifyResultMgr.FPUserID;
 836   2            *ID = 0;
 837   2            break;
 838   2          case FINGERPRINTandCARD:
 839   2            *Type ++ = DpIdFingerUnlock;
 840   2            *Type = DpIdCardUnlock;
 841   2            *ID ++ = (uint16_t)UserIdentifyResultMgr.FPUserID;
 842   2            *ID = (uint16_t)UserIdentifyResultMgr.CardUserID;
 843   2            break;
 844   2          case FINGERPRINTandPASSCODE:
 845   2            *Type ++ = DpIdFingerUnlock;
 846   2            *Type = DpIdPasswordUnlock;
 847   2            *ID ++ = (uint16_t)UserIdentifyResultMgr.FPUserID;
 848   2            *ID = (uint16_t)UserIdentifyResultMgr.PasscodeUserID;
 849   2            break;
 850   2          case CARDandPASSCODE:
 851   2            *Type ++ = DpIdPasswordUnlock;
 852   2            *Type = DpIdCardUnlock;
 853   2            *ID ++ = (uint16_t)UserIdentifyResultMgr.PasscodeUserID;
 854   2            *ID = (uint16_t)UserIdentifyResultMgr.CardUserID;
 855   2            break;
 856   2          //case WIFITEMPPASSCODE:
 857   2            
 858   2          default:
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/20/2023 10:18:59 PAGE 15  

 859   2            break;
 860   2        }
 861   1      }
 862          
 863          //开锁信息上报
 864          void WifiUnlockInfoExecute(void)
 865          {
 866   1        uint8_t UnlockType[2]={0};
 867   1        uint16_t UnlockID[2]={0};
 868   1        if( IfWifiIsLinked() == S_SUCCESS )
 869   1        {
 870   2          GotIdentifyResult(UnlockType,UnlockID);
 871   2          if( UnlockType[1] != 0 )
 872   2          {
 873   3            Wifi_ReportCombinedUnlockInfo(UnlockType,UnlockID);
 874   3          }
 875   2          else if( UnlockType[0] != 0 )
 876   2          {
 877   3            Wifi_ReportUnlockInfo(UnlockType[0],UnlockID[0]);
 878   3          }
 879   2          else
 880   2          {
 881   3            WifiMgr.PostMgr.Flag.Bits.Unlock = 0;
 882   3          }
 883   2          WifiMgr.Ack.TimeOutCnt++;
 884   2        }
 885   1      }
 886          
 887          //请求远程开锁密匙
 888          void WifiRequestRemoteUnlockKeyExecute()
 889          {
 890   1        if( IfWifiIsLinked() == S_SUCCESS )
 891   1        {
 892   2          Wifi_ReportRequestRemoteUnlockPassword();
 893   2          WifiMgr.Ack.TimeOutCnt++;
 894   2        }
 895   1      }
 896          
 897          //远程开锁密匙保存成功上报
 898          void WifiSaveKeySuccessExecute()
 899          {
 900   1        if( IfWifiIsLinked() == S_SUCCESS )
 901   1        {
 902   2          Wifi_ReportSaveKeySuccess();
 903   2          WifiMgr.Ack.TimeOutCnt++;
 904   2        }
 905   1      }
 906          
 907          //远程开锁信息上报
 908          void WifiRemoteUnlockSuccessExecute()
 909          {
 910   1        if( IfWifiIsLinked() == S_SUCCESS )
 911   1        {
 912   2          Wifi_ReportRemoteUnlockInfo(DpIdRemoteUnlock,1);
 913   2          WifiMgr.Ack.TimeOutCnt++;
 914   2        }
 915   1      }
 916          
 917          //发送请求远程开锁倒计时
 918          void WifiRemoteUnlockTimeSendExecute(uint16_t time)
 919          {
 920   1        if( IfWifiIsLinked() == S_SUCCESS )
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/20/2023 10:18:59 PAGE 16  

 921   1        {
 922   2          Wifi_ReportRemoteUnlockRequestCountdown(time);
 923   2          WifiMgr.Ack.TimeOutCnt++;
 924   2        }
 925   1      }
 926          
 927          //上报电量等级
 928          void WifiPowerLevelExecute(void)
 929          {
 930   1        if( IfWifiIsLinked() == S_SUCCESS )
 931   1        {
 932   2          switch(BatteryMgr.BatteryLevel)
 933   2          {
 934   3            case LEVEL_4:
 935   3              Wifi_ReportBatteryLevel(PowerLevelHigh);
 936   3              break;
 937   3            case LEVEL_3:
 938   3            case LEVEL_2:
 939   3              Wifi_ReportBatteryLevel(PowerLevelMedium);
 940   3              break;
 941   3            case LEVEL_1:
 942   3              Wifi_ReportBatteryLevel(PowerLevelLow);
 943   3              break;
 944   3            case LEVEL_0:
 945   3              Wifi_ReportBatteryLevel(PowerLevelEmpty);
 946   3              break;
 947   3            default:
 948   3              break;
 949   3          }
 950   2          WifiMgr.Ack.TimeOutCnt++;
 951   2        }
 952   1      }
 953          
 954          //系统锁定报警
 955          void WifiSysLockExecute(WifiAlarmType_t AlarmLock)
 956          {
 957   1        if( IfWifiIsLinked() == S_SUCCESS )
 958   1        {
 959   2          Wifi_ReportAlarmInfo(AlarmLock);
 960   2          WifiMgr.Ack.TimeOutCnt++;
 961   2        }
 962   1      }
 963          
 964          //wifi请求格林时间
 965          void WifiRequestGreenTimeExecute()
 966          {
 967   1        if( IfWifiIsLinked() == S_SUCCESS )
 968   1        {
 969   2          Wifi_SendGreenTimeRequest();
 970   2          WifiMgr.Ack.TimeOutCnt++;
 971   2        }
 972   1      }
 973          
 974          //wifi临时密码认证
 975          void WifiTempPasscodeIdentify(uint8_t BUFF[],uint8_t LEN)
 976          {
 977   1        if( IfWifiIsLinked() == S_SUCCESS )
 978   1        {
 979   2          Wifi_SendOfflineTmpPWD(BUFF,LEN);
 980   2        }
 981   1      }
 982          
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/20/2023 10:18:59 PAGE 17  

 983          //wifi离线临时密码上报
 984          void WifiTempPasscodeExecute(uint8_t DpID)
 985          {
 986   1        if( IfWifiIsLinked() == S_SUCCESS )
 987   1        {
 988   2          Wifi_ReportTempPasscode(DpID);
 989   2          WifiMgr.Ack.TimeOutCnt++;
 990   2        }
 991   1      }
 992          
 993          //和云端同步管理员和用户
 994          void WifiSyncExecute(uint8_t SyncType)
 995          {
 996   1        uint8_t MasterNum, UserNum, TotalNum;
 997   1        uint8_t AvailabeID[100]={0};
 998   1        uint8_t i;
 999   1        
1000   1        if( IfWifiIsLinked() == S_SUCCESS )
1001   1        {
1002   2          if( SyncType == DpIdFingerSync )
1003   2          {
1004   3            MasterNum = Get_Availabe_FPmasterID()-1;
1005   3            UserNum = Get_Availabe_FPuserID()-11;
1006   3            TotalNum = MasterNum + UserNum;
1007   3            for( i = 0; i < MasterNum; i++ )
1008   3            {
1009   4              AvailabeID[i] = i+1;
1010   4            }
1011   3            for( i = 0; i < UserNum; i++ )
1012   3            {
1013   4              AvailabeID[ MasterNum + i ] = i+11;
1014   4            }
1015   3            Wifi_ReportAllUserDeviceId(DpIdFingerSync,AvailabeID,(uint16_t)TotalNum);
1016   3          }
1017   2          else if( SyncType == DpIdPasswordSync )
1018   2          {
1019   3            MasterNum = CheckHowManyRegisteredPasscodeMaster();
1020   3            UserNum = CheckHowManyRegisteredPasscodeUser();
1021   3            TotalNum = MasterNum + UserNum;
1022   3            for( i = 0; i < MasterNum; i++ )
1023   3            {
1024   4              AvailabeID[i] = i+1;
1025   4            }
1026   3            for( i = 0; i < UserNum; i++ )
1027   3            {
1028   4              AvailabeID[ MasterNum + i ] = i+3;
1029   4            }
1030   3            Wifi_ReportAllUserDeviceId(DpIdPasswordSync,AvailabeID,(uint16_t)TotalNum);
1031   3          }
1032   2          else if( SyncType == DpIdCardSync )
1033   2          {
1034   3            TotalNum = CheckHowManyRegisteredCardUser();
1035   3            for( i = 0; i < TotalNum; i++ )
1036   3            {
1037   4              AvailabeID[i] = i+1;
1038   4            }
1039   3            Wifi_ReportAllUserDeviceId(DpIdCardSync,AvailabeID,(uint16_t)TotalNum);
1040   3          }
1041   2          WifiMgr.Ack.TimeOutCnt++;
1042   2        }
1043   1      }
1044          
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/20/2023 10:18:59 PAGE 18  

1045          //远程开锁倒计时上报
1046          void WifiRemoteUnlockCountdown(void)
1047          {
1048   1        if( IfWifiIsLinked() == S_SUCCESS )
1049   1        {
1050   2          if( WifiMgr.PostMgr.RemoteUnlockCountdown > 0 )
1051   2          {
1052   3            WifiMgr.PostMgr.RemoteUnlockCountdown--;
1053   3            WifiMgr.PostMgr.Flag.Bits.DoorBell = 1;
1054   3          }
1055   2        }
1056   1      }
1057            
1058          //WIFI指令发送
1059          void WifiCMD_Post(void)
1060          {
1061   1        //250ms发一次命令，不同命令通过标志位缓存，依照优先级发送
1062   1        if( WifiMgr.PostMgr.WifiPostIntervalCnt <= 0 )
1063   1        {
1064   2          WifiMgr.PostMgr.SendingFlag.TotalFlagBits = 0;
1065   2          if( WifiMgr.PostMgr.Flag.Bits.Info != 0 )
1066   2          {
1067   3            WifiMgr.PostMgr.Flag.Bits.Info = 0;//回复型指令只发一次，不做失败重发
1068   3            Wifi_SendProjectInfo();//发送设备信息
1069   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1070   3          }
1071   2          else if( WifiMgr.PostMgr.Flag.Bits.StartNetwork != 0 )
1072   2          {
1073   3            WifiMgr.PostMgr.SendingFlag.Bits.StartNetwork = 1;
1074   3            Wifi_SendSmartNetworkConfig();//发送开锁配网指令
1075   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1076   3          }
1077   2          else if( WifiMgr.PostMgr.Flag.Bits.WifiState != 0 )
1078   2          {
1079   3            WifiMgr.PostMgr.Flag.Bits.WifiState = 0;//回复型指令只发一次，不做失败重发
1080   3            Wifi_SendLinkNetworkAck();//联网成功应答
1081   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1082   3          }
1083   2          else if ( WifiMgr.PostMgr.Flag.Bits.AnswerCmd != 0 )
1084   2          {
1085   3            WifiMgr.PostMgr.Flag.Bits.AnswerCmd = 0;//回复型指令只发一次，不做失败重发
1086   3            Wifi_SendGotCMDAck();//获取指令应答
1087   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1088   3          }
1089   2          else if ( WifiMgr.PostMgr.Flag.Bits.RequestRemoteUnlockPassword != 0 )
1090   2          {
1091   3            WifiMgr.PostMgr.SendingFlag.Bits.RequestRemoteUnlockPassword = 1;
1092   3            WifiRequestRemoteUnlockKeyExecute();//请求远程开锁密匙
1093   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1094   3          }
1095   2          else if ( WifiMgr.PostMgr.Flag.Bits.Alarm != 0 )
1096   2          {
1097   3            //WifiMgr.PostMgr.Flag.Bits.Alarm = 0;
1098   3            WifiMgr.PostMgr.SendingFlag.Bits.Alarm = 1;
1099   3            WifiSysLockExecute(WifiMgr.PostMgr.AlarmType);//系统锁定记录上报
1100   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1101   3          }
1102   2          else if ( WifiMgr.PostMgr.Flag.Bits.DoorBell != 0 )
1103   2          {
1104   3            //WifiMgr.PostMgr.Flag.Bits.DoorBell = 0;
1105   3            WifiMgr.PostMgr.SendingFlag.Bits.DoorBell = 1;
1106   3            WifiRemoteUnlockTimeSendExecute(WifiMgr.PostMgr.RemoteUnlockCountdown);//发送请求远程开锁倒计时
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/20/2023 10:18:59 PAGE 19  

1107   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1108   3          }
1109   2          else if ( WifiMgr.PostMgr.Flag.Bits.Unlock != 0 )
1110   2          {
1111   3            WifiMgr.PostMgr.SendingFlag.Bits.Unlock = 1;
1112   3            WifiUnlockInfoExecute();//开锁信息上报
1113   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1114   3          }
1115   2          else if ( WifiMgr.PostMgr.Flag.Bits.RemoteUnlock != 0 )
1116   2          {
1117   3            WifiMgr.PostMgr.SendingFlag.Bits.RemoteUnlock = 1;
1118   3            WifiRemoteUnlockSuccessExecute();//远程开锁信息上报
1119   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1120   3          }
1121   2          else if ( WifiMgr.PostMgr.Flag.Bits.RequestGreenTime != 0 )
1122   2          {
1123   3            WifiMgr.PostMgr.SendingFlag.Bits.RequestGreenTime = 1;
1124   3            WifiRequestGreenTimeExecute();//请求格林时间
1125   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1126   3          }
1127   2          else if ( WifiMgr.PostMgr.Flag.Bits.TempPasswordUnlock != 0 )
1128   2          {
1129   3            WifiMgr.PostMgr.SendingFlag.Bits.TempPasswordUnlock = 1;
1130   3            WifiTempPasscodeExecute(DpIdOfflineTmpPWDUnlock);//离线临时密码开锁上报
1131   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1132   3          }
1133   2          else if ( WifiMgr.PostMgr.Flag.Bits.DeleteTempPassword != 0 )
1134   2          {
1135   3            WifiMgr.PostMgr.SendingFlag.Bits.DeleteTempPassword = 1;
1136   3            WifiTempPasscodeExecute(DpIdOfflineDeleteCode);//离线临时密码清空码上报
1137   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1138   3          }
1139   2          else if ( WifiMgr.PostMgr.Flag.Bits.TempPasswordCheck != 0 )
1140   2          {
1141   3            //对于只可使用一次密码，重发可能会导致结果出错，此处不做重发判定
1142   3            WifiMgr.PostMgr.Flag.Bits.TempPasswordCheck = 0;
1143   3            WifiMgr.OfflineTempPassword.Status = TempPswdChecking;
1144   3            WifiMgr.OfflineTempPassword.TempPswdCnt = Def_GuiTimeDelayCnt1s5;//1.5s没收到回复视为超时
1145   3            WifiTempPasscodeIdentify(PasscodeInputMgr.InputBuff,10);//临时密码认证
1146   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1147   3          }
1148   2          else if ( WifiMgr.PostMgr.Flag.Bits.PowerLevel != 0 )
1149   2          {
1150   3            WifiMgr.PostMgr.SendingFlag.Bits.PowerLevel = 1;
1151   3            WifiPowerLevelExecute();//电池电量发送
1152   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1153   3          }
1154   2          else if ( WifiMgr.PostMgr.Flag.Bits.FingerSync != 0 )
1155   2          {
1156   3            WifiMgr.PostMgr.SendingFlag.Bits.FingerSync = 1;
1157   3            WifiSyncExecute(DpIdFingerSync);//同步指纹用户
1158   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1159   3          }
1160   2          else if ( WifiMgr.PostMgr.Flag.Bits.PasswordSync != 0 )
1161   2          {
1162   3            WifiMgr.PostMgr.SendingFlag.Bits.PasswordSync = 1;
1163   3            WifiSyncExecute(DpIdPasswordSync);//同步密码用户
1164   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1165   3          }
1166   2          else if ( WifiMgr.PostMgr.Flag.Bits.CardSync != 0 )
1167   2          {
1168   3            WifiMgr.PostMgr.SendingFlag.Bits.CardSync = 1;
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/20/2023 10:18:59 PAGE 20  

1169   3            WifiSyncExecute(DpIdCardSync);//同步卡片用户
1170   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1171   3          }
1172   2          else if ( WifiMgr.PostMgr.Flag.Bits.SaveKeySuccess != 0 )
1173   2          {
1174   3            WifiMgr.PostMgr.SendingFlag.Bits.SaveKeySuccess = 1;
1175   3            WifiSaveKeySuccessExecute();//远程开锁密匙保存成功上报
1176   3            WifiMgr.RemoteUnlockMgr.RequestRemoteUnlockisReady = bTRUE;
1177   3            WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1178   3          }
1179   2      //    else
1180   2      //    {
1181   2      //      //无事件时回复
1182   2      //      Wifi_SendGotCMDAck();
1183   2      //      WifiMgr.PostMgr.WifiPostIntervalCnt = Def_WifiSendTime;
1184   2      //    }
1185   2        }
1186   1        
1187   1        if( WifiMgr.PostMgr.WifiPostIntervalCnt > 0 )
1188   1        {
1189   2          WifiMgr.PostMgr.WifiPostIntervalCnt--;
1190   2        }
1191   1      }
1192          
1193          //WIFI指令处理
1194          void WifiCMD_Excute(void)
1195          {
1196   1        uint8_t i;
1197   1        uint16_t CmdLenth,CKS,TempCKS;
1198   1        
1199   1        if ( UART1_Mgr.Status != GotNewCmd ){
1200   2          return;
1201   2        }
1202   1        
1203   1        CmdLenth = (UART1_Mgr.RX_Buffer[4]*256) + UART1_Mgr.RX_Buffer[5] + 7;   
1204   1        
1205   1        if ( CmdLenth >= 80 ) 
1206   1        {
1207   2          UART1_Mgr.RX_DataPoint = 0x00;
1208   2          UART1_Mgr.Status = Idle; //处理模式
1209   2          return;
1210   2        }
1211   1        
1212   1        for (i=0;i<CmdLenth;i++)
1213   1        {
1214   2          WifiMgr.Ack.Buff[i] = UART1_Mgr.RX_Buffer[i];   
1215   2        }
1216   1        
1217   1        UART1_Mgr.RX_DataPoint = 0x00;
1218   1        UART1_Mgr.Status = Idle;
1219   1        
1220   1        CKS = GetCheckSum(WifiMgr.Ack.Buff,CmdLenth-1);
1221   1      
1222   1        TempCKS = WifiMgr.Ack.Buff[CmdLenth-1];
1223   1        
1224   1        if ( CKS!=TempCKS )
1225   1        {
1226   2          WifiMgr.Ack.Status = WifiAckIdle; 
1227   2          return;   //if check sum is failed, ignore this data strin
1228   2        }
1229   1        WifiDataHandle(WifiMgr.Ack.Buff);
1230   1      }
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/20/2023 10:18:59 PAGE 21  

1231          
1232          //结束远程开锁流程
1233          void WifiRemoteUnlockStop(void)
1234          {
1235   1        WifiMgr.RemoteUnlockMgr.Result = IsUnknow;
1236   1        WifiMgr.RemoteUnlockMgr.Status = RemoteUnlockStandby;
1237   1        WifiMgr.PostMgr.Flag.Bits.DoorBell = 1;
1238   1        WifiMgr.PostMgr.RemoteUnlockCountdown = 0;
1239   1      }
1240            
1241          //wifi模块主循环
1242          void Wifi_Handle(void)
1243          {
1244   1        //处理ack标志位
1245   1        if( WifiMgr.Ack.Status != 0 )
1246   1        {
1247   2          switch(WifiMgr.Ack.Status)
1248   2          {
1249   3            case GotProjectInfoCmdACK:
1250   3              WifiMgr.PostMgr.Flag.Bits.Info = 1;
1251   3              break;
1252   3            case WaitWifiStateCmdACK:
1253   3              WifiMgr.PostMgr.Flag.Bits.WifiState = 1;
1254   3              break;
1255   3            case WifiAnswerCmdACK:
1256   3              WifiMgr.PostMgr.Flag.Bits.AnswerCmd = 1;
1257   3              break;
1258   3            /*
1259   3            case xxx:
1260   3              break;
1261   3            */
1262   3            default:
1263   3              break;
1264   3          }
1265   2          WifiMgr.Ack.Status = WifiAckIdle;
1266   2        }
1267   1        //模块超时未应答处理
1268   1        if( WifiMgr.Ack.TimeOutCnt > 20 )
1269   1        {
1270   2          SET_WIFIPOWER_OFF;
1271   2          Soft_Delay1ms(1);
1272   2          SET_WIFIPOWER_ON;
1273   2          Wifi_Rst();
1274   2        }
1275   1        //远程开锁密匙请求（联网后1.5s发送请求）
1276   1        if( WifiMgr.RemoteUnlockMgr.RequestPasswordTimeCnt > 0 )
1277   1        {
1278   2          WifiMgr.RemoteUnlockMgr.RequestPasswordTimeCnt--;
1279   2          if( WifiMgr.RemoteUnlockMgr.RequestPasswordTimeCnt == 0 )
1280   2          {
1281   3            WifiMgr.PostMgr.Flag.Bits.RequestRemoteUnlockPassword = 1;
1282   3            WifiMgr.RemoteUnlockMgr.Status = RemoteUnlockRequestPassword;
1283   3          }
1284   2        }
1285   1        //远程开锁开始请求开门
1286   1        if( ( WifiMgr.RemoteUnlockMgr.WaitRequestRemoteUnlock  == bTRUE )&& \
1287   1            ( WifiMgr.RemoteUnlockMgr.RequestRemoteUnlockisReady == bTRUE ) )
1288   1        {
1289   2          WifiMgr.RemoteUnlockMgr.WaitRequestRemoteUnlock = bFALSE;
1290   2          WifiMgr.PostMgr.Flag.Bits.DoorBell = 1;
1291   2          WifiMgr.RemoteUnlockMgr.Status = RemoteUnlockRequestWait;
1292   2          if( SystemPowerMgr.SleepDelayTimerCnt != 0 )
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/20/2023 10:18:59 PAGE 22  

1293   2          {
1294   3            WifiMgr.PostMgr.RemoteUnlockCountdown = Def_RemoteUnlockCountdown;
1295   3          }
1296   2          else
1297   2          {
1298   3            WifiMgr.PostMgr.RemoteUnlockCountdown = 0;
1299   3          }
1300   2          WifiMgr.RemoteUnlockMgr.Result = IsUnknow;
1301   2          SystemPowerMgr.SleepDelayTimerCnt = (Def_RemoteUnlockCountdown+1)*64;
1302   2        }
1303   1        //远程开锁时开锁判断
1304   1        if( WifiMgr.RemoteUnlockMgr.Status == RemoteUnlockRequestWait )
1305   1        {
1306   2          if( WifiMgr.PostMgr.RemoteUnlockCountdown > 0 )
1307   2          {
1308   3            if( WifiMgr.RemoteUnlockMgr.Result == IsSuccess )
1309   3            {
1310   4              //开锁
1311   4              UnlockSuccess(RemoteUnlock);
1312   4              //远程开锁上报
1313   4              WifiMgr.PostMgr.Flag.Bits.RemoteUnlock = 1;
1314   4              WifiRemoteUnlockStop();
1315   4            }
1316   3            else if( WifiMgr.RemoteUnlockMgr.Result == IsFail )
1317   3            {
1318   4              WifiRemoteUnlockStop();
1319   4            }
1320   3          }
1321   2          else{
1322   3            WifiRemoteUnlockStop();
1323   3          }
1324   2        }
1325   1        //离线临时密码开锁
1326   1        if( WifiMgr.OfflineTempPassword.Status == TempPswdChecking )
1327   1        {
1328   2          //超时返回错误
1329   2          if( WifiMgr.OfflineTempPassword.TempPswdCnt > 0 )
1330   2          {
1331   3            WifiMgr.OfflineTempPassword.TempPswdCnt--;
1332   3          }
1333   2          else{
1334   3            WifiMgr.OfflineTempPassword.Status = TempPswdWrong;
1335   3          }
1336   2        }
1337   1        else if( WifiMgr.OfflineTempPassword.Status == TempPswdCorrect )
1338   1        {
1339   2          WifiMgr.OfflineTempPassword.Status = TempPswdIdle;
1340   2          PasscodeUserIdentifyMgr.Status = PasscodeIdentifySuccess;
1341   2          PasscodeUserIdentifyMgr.UserID = 1;
1342   2          //PasscodeUserIdentifyMgr.TimeCnt =Def_IdendtifySuccessScreenTimeDelay;
1343   2          UserIdentifyResultMgr.PasscodeType = WifiTempPasscode;
1344   2        }
1345   1        else if( WifiMgr.OfflineTempPassword.Status == ClearCodeCorrect )
1346   1        {
1347   2          WifiMgr.OfflineTempPassword.Status = TempPswdIdle;
1348   2          PasscodeUserIdentifyMgr.Status = DeleteWifiTempPasscodeSuccess;
1349   2          WifiMgr.PostMgr.Flag.Bits.DeleteTempPassword = 1;
1350   2        }
1351   1        else if( WifiMgr.OfflineTempPassword.Status == TempPswdWrong )
1352   1        {
1353   2          WifiMgr.OfflineTempPassword.Status = TempPswdIdle;
1354   2          PasscodeUserIdentifyMgr.Status = PasscodeIdentifyFail;
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/20/2023 10:18:59 PAGE 23  

1355   2          //PasscodeUserIdentifyMgr.TimeCnt =Def_IdendtifyFailScreenTimeDelay;
1356   2        }
1357   1        //超时关闭wifi
1358   1        WifiMgr.OFFPowerCnt++;
1359   1        if( WifiMgr.OFFPowerCnt >= Def_GuiTimeDelayCnt5s )
1360   1        {
1361   2          Wifi_DeInit();
1362   2        }
1363   1      }
1364          
1365          void Wifi_Mgr_Task(void)//16ms
1366          {
1367   1        if( WifiMgr.PowerState == WIFIPowerClosed )
1368   1        {
1369   2          if(( WifiMgr.PostMgr.Flag.TotalFlagBits != 0 )||( WifiMgr.RemoteUnlockMgr.WaitRequestRemoteUnlock == bTR
             -UE ))
1370   2          {
1371   3            Wifi_Init();
1372   3          }
1373   2        }
1374   1        else
1375   1        {
1376   2          WifiCMD_Post();
1377   2          WifiCMD_Excute();
1378   2          Wifi_Handle();
1379   2        }
1380   1      }
1381          
1382          //重置wifi相关数据
1383          void Wifi_Rst(void)
1384          {
1385   1        UART1_Mgr.RX_DataPoint = 0x00;
1386   1        UART1_Mgr.Status = Idle;
1387   1        WifiMgr.OFFPowerCnt = 0;
1388   1        WifiMgr.PostMgr.Flag.TotalFlagBits = 0;
1389   1        WifiMgr.PostMgr.SendingFlag.TotalFlagBits = 0;
1390   1        WifiMgr.PostMgr.WifiPostIntervalCnt = 0;
1391   1        WifiMgr.PostMgr.RemoteUnlockCountdown = 0;
1392   1        WifiMgr.Ack.Status = WifiAckIdle;
1393   1        WifiMgr.Ack.TimeOutCnt = 0;
1394   1        WifiMgr.WifiConnection.Status = NotConnected;
1395   1        WifiMgr.RemoteUnlockMgr.RequestPasswordTimeCnt = 0;
1396   1        WifiMgr.RemoteUnlockMgr.WaitRequestRemoteUnlock = bFALSE;
1397   1        WifiMgr.RemoteUnlockMgr.RequestRemoteUnlockisReady = bFALSE;
1398   1        WifiMgr.OfflineTempPassword.Status = TempPswdIdle;
1399   1      }
1400          
1401          void Wifi_Init(void)
1402          {
1403   1        SET_WIFIPOWER_ON;
1404   1        MX_UART1_Init();
1405   1        WifiMgr.PowerState = WIFIPowerOpened;
1406   1      }
1407          
1408          void Wifi_DeInit(void)
1409          {
1410   1        SET_WIFIPOWER_OFF;
1411   1        MX_UART1_DeInit();
1412   1        Wifi_Rst();
1413   1        WifiMgr.PowerState = WIFIPowerClosed;
1414   1      }
1415          
C51 COMPILER V9.60.0.0   TUYAWIFI                                                          04/20/2023 10:18:59 PAGE 24  

1416          /********************Text************************/
1417          //uint8_t UserID[12] = {0x01, 0x12, 0x03, 0x04, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12};
1418          //uint8_t NewRemotePwd[6] = {0x01, 0x2, 0x03, 0x04, 0x10, 0x12};
1419          //void test_fun(void)
1420          //{
1421          //  Wifi_SendResetNetworkConfig();
1422          ////  Wifi_ReportUnlockInfo(DpIdCardUnlock, 200);
1423          ////  Wifi_ReportAlarmInfo(StayAlarm);
1424          ////  Wifi_ReportRemoteUnlockRequestCountdown(120);
1425          ////  Wifi_ReportBatteryLevel(PowerLevelMedium);
1426          ////  Wifi_ReportAPPRemoteUnlock(4);
1427          ////  Wifi_ReportStress(1);
1428          ////  Wifi_ReportDoorBellAwake(1);
1429          ////  Wifi_ReportAllUserDeviceId(0x1b, UserID, 12); //指纹0x19 密码0x1a 卡号0x1b
1430          ////  Wifi_ReportNewRemoteUnlockPwd(NewRemotePwd, 6);
1431          ////  Wifi_ReportRemoteUnlock(NewRemotePwd, 6);
1432          ////  Wifi_ReportMessage(NewRemotePwd, 6);
1433          //}
1434          //uint8_t dataTest[100] = {0};
1435          //void Wifi_SendTestAck(uint8_t lenth)
1436          //{
1437          //  uint16_t DataLen = lenth + 1;
1438          //  uint8_t* DataBuff = (uint8_t *) malloc(DataLen);
1439          //  uint8_t i = 0;
1440          //  
1441          //  memset(DataBuff, 0, DataLen);
1442          //  
1443          //  DataBuff[0] = lenth;
1444          
1445          //  for(i = 1; i <= lenth; i++) {
1446          //    //DataBuff[i] = dataTest[i-1];
1447          //  }
1448          
1449          //  if(DataBuff != NULL) {
1450          //    TuyaWIFISendFrame(REPORTED_MCU_SN_CMD,DataBuff,DataLen);
1451          //    free(DataBuff);
1452          //    DataBuff = NULL;
1453          //  }
1454          //}
1455          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4994    ----
   CONSTANT SIZE    =    337    ----
   XDATA SIZE       =     45     583
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

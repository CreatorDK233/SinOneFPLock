C51 COMPILER V9.60.0.0   SYSTEM                                                            03/08/2023 18:02:10 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE SYSTEM
OBJECT MODULE PLACED IN .\Objects\system.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Drivers\Protocol\WIFI_Tuya\system.c LARGE OMF2 OPTIMIZE(9,SPEED) BROWSE 
                    -INCDIR(.\Drivers\Lib\c;.\Drivers\Lib\H;.\Drivers\Lib\IAP_Lib;.\Drivers\Lib\TouchKey_lib;.\Drivers\Physical;.\Drivers\Pro
                    -tocol;.\Softwares\Application;.\Softwares\Basic;.\Softwares\ModuleLogic;.\Drivers\Protocol\YC_NFC;.\Drivers\Protocol\WIF
                    -I_Tuya) DEBUG PRINT(.\Listings\system.lst) TABS(2) OBJECT(.\Objects\system.obj)

line level    source

   1          /**********************************Copyright (c)**********************************
   2          **                       ç‰ˆæƒæ‰€æœ‰ (C), 2015-2020, æ¶‚é¸¦ç§‘æŠ€
   3          **
   4          **                             http://www.tuya.com
   5          **
   6          *********************************************************************************/
   7          /**
   8           * @file    system.c
   9           * @author  æ¶‚é¸¦ç»¼åˆåè®®å¼€å‘ç»„
  10           * @version v1.0.7
  11           * @date    2020.11.9
  12           * @brief   ä¸²å£æ•°æ®å¤„ç†ï¼Œç”¨æˆ·æ— éœ€å…³å¿ƒè¯¥æ–‡ä»¶å®ç°å†…å®¹
  13           */
  14          
  15          
  16          #define SYSTEM_GLOBAL
  17          
  18          #include "system.h"
  19          //#include "wifi.h"
  20          //#include "protocol.h"
  21          #include <stdio.h>
  22          //
  23          //
  24          extern const DOWNLOAD_CMD_S download_cmd[];
  25          
  26          /*è®¾å¤‡èƒ½åŠ›é€‰æ‹©*/
  27          /*è¯·åœ¨æ­¤å¤„é€‰æ‹©éœ€è¦å¼€å¯çš„è®¾å¤‡çš„èƒ½åŠ›ï¼ŒONä¸ºå¼€å¯ï¼ŒOFFä¸ºå…³é—­*/
  28          tCAP_equip cap_equip = {
  29          #ifndef PICTURE_UPLOAD_ENABLE
  30              OFF,        //è®¾å¤‡ä¸æ”¯æŒ æ‹ç…§/å›¾ç‰‡ä¼ è¾“ åŠŸèƒ½
  31          #else
                  ON,         //è®¾å¤‡æ”¯æŒ æ‹ç…§/å›¾ç‰‡ä¼ è¾“ åŠŸèƒ½
              #endif
  34          #ifndef CAP_COMMU_MODE_ENABLE
  35              OFF,        //è®¾å¤‡é‡‡ç”¨ä¸²å£é€šä¿¡æ–¹å¼ä¸Šä¼ å›¾ç‰‡
  36          #else
                  ON,         //è®¾å¤‡é‡‡ç”¨SPIé€šä¿¡æ–¹å¼ä¸Šä¼ å›¾ç‰‡
              #endif
  39              OFF,        //è®¾å¤‡æ˜¯å¦ä¸ºè¿è¥å•†é—¨é”ï¼Ÿ OFF:è¡¨ç¤ºä¸æ”¯æŒ, ON:è¡¨ç¤ºæ”¯æŒ ï¼ˆæš‚ä¸æ”¯æŒæ­
             -¤åŠŸèƒ½ï¼‰
  40          #ifndef WIFI_RESET_NOTICE_ENABLE
  41              OFF,        //è®¾å¤‡ä¸æ”¯æŒæ¨¡å—é‡ç½®çŠ¶æ€é€šçŸ¥
  42          #else
                  ON,         //è®¾å¤‡æ”¯æŒæ¨¡å—é‡ç½®çŠ¶æ€é€šçŸ¥
              #endif
  45              OFF,        //é¢„ç•™
  46              OFF,        //é¢„ç•™
  47              OFF,        //é¢„ç•™
  48              OFF         //é¢„ç•™
  49          };
  50          
  51          /**
C51 COMPILER V9.60.0.0   SYSTEM                                                            03/08/2023 18:02:10 PAGE 2   

  52           * @brief  å†™wifi_uartå­—èŠ‚
  53           * @param[in] {dest} ç¼“å­˜åŒºå…¶å®åœ°å€
  54           * @param[in] {byte} å†™å…¥å­—èŠ‚å€¼
  55           * @return å†™å…¥å®Œæˆåçš„æ€»é•¿åº¦
  56           */
  57          unsigned short set_wifi_uart_byte(unsigned short dest, unsigned char byte)
  58          {
  59   1          unsigned char *obj = (unsigned char *)wifi_uart_tx_buf + DATA_START + dest;
  60   1          
  61   1          *obj = byte;
  62   1          dest += 1;
  63   1          
  64   1          return dest;
  65   1      }
  66          
  67          /**
  68           * @brief  å†™wifi_uart_buffer
  69           * @param[in] {dest} ç›®æ ‡åœ°å€
  70           * @param[in] {src} æºåœ°å€
  71           * @param[in] {len} æ•°æ®é•¿åº¦
  72           * @return å†™å…¥ç»“æŸçš„ç¼“å­˜åœ°å€
  73           */
  74          unsigned short set_wifi_uart_buffer(unsigned short dest, unsigned char *src, unsigned short len)
  75          {
  76   1          unsigned char *obj = (unsigned char *)wifi_uart_tx_buf + DATA_START + dest;
  77   1          
  78   1          my_memcpy(obj,src,len);
  79   1          
  80   1          dest += len;
  81   1          return dest;
  82   1      }
  83          
  84          /**
  85           * @brief  è®¡ç®—æ ¡éªŒå’Œ
  86           * @param[in] {pack} æ•°æ®æºæŒ‡é’ˆ
  87           * @param[in] {pack_len} è®¡ç®—æ ¡éªŒå’Œé•¿åº¦
  88           * @return æ ¡éªŒå’Œ
  89           */
  90          unsigned char get_check_sum(unsigned char *pack, unsigned short pack_len)
  91          {
  92   1          unsigned short i;
  93   1          unsigned char check_sum = 0;
  94   1          
  95   1          for(i = 0; i < pack_len; i ++) {
  96   2              check_sum += *pack ++;
  97   2          }
  98   1          
  99   1          return check_sum;
 100   1      }
 101          
 102          /**
 103           * @brief  ä¸²å£å‘é€ä¸€æ®µæ•°æ®
 104           * @param[in] {in} å‘é€ç¼“å­˜æŒ‡é’ˆ
 105           * @param[in] {len} æ•°æ®å‘é€é•¿åº¦
 106           * @return Null
 107           */
 108          static void wifi_uart_write_data(unsigned char *in, unsigned short len)
 109          {
 110   1          if((NULL == in) || (0 == len)) {
 111   2              return;
 112   2          }
 113   1          
C51 COMPILER V9.60.0.0   SYSTEM                                                            03/08/2023 18:02:10 PAGE 3   

 114   1          while(len --) {
 115   2              uart_transmit_output(*in);
 116   2              in ++;
 117   2          }
 118   1      }
 119          
 120          /**
 121           * @brief  å‘wifiä¸²å£å‘é€ä¸€å¸§æ•°æ®
 122           * @param[in] {fr_type} å¸§ç±»å‹
 123           * @param[in] {fr_ver} å¸§ç‰ˆæœ¬
 124           * @param[in] {len} æ•°æ®é•¿åº¦
 125           * @return Null
 126           */
 127          void wifi_uart_write_frame(unsigned char fr_type, unsigned short len)
 128          {
 129   1          unsigned char check_sum = 0;
 130   1          
 131   1          wifi_uart_tx_buf[HEAD_FIRST] = FRAME_FIRST;
 132   1          wifi_uart_tx_buf[HEAD_SECOND] = FRAME_SECOND;
 133   1          wifi_uart_tx_buf[PROTOCOL_VERSION] = MCU_TX_VER;
 134   1          wifi_uart_tx_buf[FRAME_TYPE] = fr_type;
 135   1          wifi_uart_tx_buf[LENGTH_HIGH] = len >> 8;
 136   1          wifi_uart_tx_buf[LENGTH_LOW] = len & 0xff;
 137   1          
 138   1          len += PROTOCOL_HEAD;
 139   1          check_sum = get_check_sum((unsigned char *)wifi_uart_tx_buf, len - 1);
 140   1          wifi_uart_tx_buf[len - 1] = check_sum;
 141   1          //
 142   1          wifi_uart_write_data((unsigned char *)wifi_uart_tx_buf, len);
 143   1      }
 144          
 145          /**
 146           * @brief  äº§å“ä¿¡æ¯ä¸Šä¼ 
 147           * @param  Null
 148           * @return Null
 149           */
 150          static void product_info_update(void)
 151          {
 152   1          unsigned char length = 0;
 153   1          unsigned char str[10] = {0};
 154   1        
 155   1          length = set_wifi_uart_buffer(length, "{\"p\":\"", my_strlen("{\"p\":\""));
 156   1          length = set_wifi_uart_buffer(length,(unsigned char *)PRODUCT_KEY,my_strlen((unsigned char *)PRODUCT_K
             -EY));
 157   1          length = set_wifi_uart_buffer(length, "\",\"v\":\"", my_strlen("\",\"v\":\""));
 158   1          length = set_wifi_uart_buffer(length,(unsigned char *)MCU_VER,my_strlen((unsigned char *)MCU_VER));
 159   1          length = set_wifi_uart_buffer(length, "\"", my_strlen("\""));
 160   1          
 161   1      #ifdef CONFIG_MODE_CHOOSE
 162   1          sprintf((char *)str,",\"n\":%d",CONFIG_MODE_CHOOSE);
 163   1          length = set_wifi_uart_buffer(length, str, my_strlen(str));
 164   1      #endif
 165   1          
 166   1          sprintf((char *)str, ",\"cap\":%d", cap_equip.whole);
 167   1          length = set_wifi_uart_buffer(length, str, my_strlen(str));
 168   1          
 169   1          length = set_wifi_uart_buffer(length, "}", my_strlen("}"));
 170   1          
 171   1          wifi_uart_write_frame(PRODUCT_INFO_CMD, length);
 172   1      }
 173          
 174          /**
C51 COMPILER V9.60.0.0   SYSTEM                                                            03/08/2023 18:02:10 PAGE 4   

 175           * @brief  è·å–åˆ¶å®šDPIDåœ¨æ•°ç»„ä¸­çš„åºå·
 176           * @param[in] {dpid} dpid
 177           * @return dpåºå·
 178           */
 179          static unsigned char get_dowmload_dpid_index(unsigned char dpid)
 180          {
 181   1          unsigned char index;
 182   1          unsigned char total = get_download_cmd_total();
 183   1          
 184   1          for(index = 0; index < total; index ++) {
 185   2              if(download_cmd[index].dp_id == dpid) {
 186   3                  break;
 187   3              }
 188   2          }
 189   1          
 190   1          return index;
 191   1      }
 192          
 193          /**
 194           * @brief  è·å–æŒ‡å®šDPIDåœ¨æ•°ç»„ä¸­çš„åºå·
 195           * @param[in] {dpid} dpid
 196           * @param[out] {p_dp_type} dp ç±»å‹
 197           * @return SUCCESS/ERROR
 198           */
 199          unsigned char get_dp_type(unsigned char dpid, unsigned char *p_dp_type)
 200          {
 201   1          unsigned char index;
 202   1          unsigned char total = get_download_cmd_total();
 203   1          
 204   1          for(index = 0; index < total; index ++) {
 205   2              if(download_cmd[index].dp_id == dpid) {
 206   3                  *p_dp_type = download_cmd[index].dp_type;
 207   3                  return SUCCESS;
 208   3              }
 209   2          }
 210   1          
 211   1          return ERROR;
 212   1      }
 213          
 214          /**
 215           * @brief  ä¸‹å‘æ•°æ®å¤„ç†
 216           * @param[in] {value} ä¸‹å‘æ•°æ®æºæŒ‡é’ˆ
 217           * @return è¿”å›æ•°æ®å¤„ç†ç»“æœ
 218           */
 219          static unsigned char data_point_handle(const unsigned char value[])
 220          {
 221   1          unsigned char dp_id,index;
 222   1          unsigned char dp_type;
 223   1          unsigned char ret;
 224   1          unsigned short dp_len;
 225   1          
 226   1          dp_id = value[0];
 227   1          dp_type = value[1];
 228   1          dp_len = value[2] * 0x100;
 229   1          dp_len += value[3];
 230   1          
 231   1          index = get_dowmload_dpid_index(dp_id);
 232   1      
 233   1          if(dp_type != download_cmd[index].dp_type) {
 234   2              //é”™è¯¯æç¤º
 235   2              return FALSE;
 236   2          }else {
C51 COMPILER V9.60.0.0   SYSTEM                                                            03/08/2023 18:02:10 PAGE 5   

 237   2              ret = dp_download_handle(dp_id,value + 4,dp_len);
 238   2          }
 239   1          
 240   1          return ret;
 241   1      }
 242          
 243          /**
 244           * @brief  æ•°æ®å¸§å¤„ç†
 245           * @param[in] {offset} æ•°æ®èµ·å§‹ä½
 246           * @return Null
 247           */
 248          void data_handle(unsigned short offset)
 249          {
 250   1      #ifdef SUPPORT_MCU_FIRM_UPDATE
 251   1          unsigned char *firmware_addr = NULL;
 252   1          static unsigned long firm_length = 0;                 //MCUå‡çº§æ–‡ä»¶é•¿åº¦
 253   1          static unsigned char firm_update_flag;                //MCUå‡çº§æ ‡å¿—
 254   1          unsigned long dp_len = 0;
 255   1      #else
                  unsigned short dp_len;
              #endif
 258   1          unsigned char result;
 259   1          unsigned char dp_num;
 260   1      
 261   1          unsigned char ret;
 262   1          unsigned short i,total_len;
 263   1          unsigned char cmd_type = wifi_data_process_buf[offset + FRAME_TYPE];
 264   1          
 265   1          switch(cmd_type)
 266   1          {
 267   2              case PRODUCT_INFO_CMD:                                  //äº§å“ä¿¡æ¯
 268   2                  product_info_update();
 269   2              break;
 270   2              
 271   2      #ifndef WIFI_CONTROL_SELF_MODE
 272   2              case WIFI_STATE_CMD:                                    //wifiå·¥ä½œçŠ¶æ€  
 273   2                  wifi_work_state = wifi_data_process_buf[offset + DATA_START];
 274   2                  wifi_uart_write_frame(WIFI_STATE_CMD,0);
 275   2              break;
 276   2      
 277   2              case WIFI_RESET_CMD:                                    //é‡ç½®wifi(wifiè¿”å›æˆåŠŸ)
 278   2                  reset_wifi_flag = RESET_WIFI_SUCCESS;
 279   2              break;
 280   2                
 281   2              case WIFI_MODE_CMD:                                     //é€‰æ‹©smartconfig/APæ¨¡å¼(wifiè¿”å›æˆ
             -åŠŸ)  
 282   2                  set_wifimode_flag = SET_WIFICONFIG_SUCCESS;
 283   2              break;
 284   2      #endif
 285   2            
 286   2              case DATA_QUERT_CMD:                                    //å‘½ä»¤ä¸‹å‘
 287   2                  total_len = wifi_data_process_buf[offset + LENGTH_HIGH] * 0x100;
 288   2                  total_len += wifi_data_process_buf[offset + LENGTH_LOW];
 289   2                  
 290   2                  for(i = 0;i < total_len; ) {
 291   3                      dp_len = wifi_data_process_buf[offset + DATA_START + i + 2] * 0x100;
 292   3                      dp_len += wifi_data_process_buf[offset + DATA_START + i + 3];
 293   3                      //
 294   3                      ret = data_point_handle((unsigned char *)wifi_data_process_buf + offset + DATA_START + i);
 295   3                      
 296   3                      if(SUCCESS == ret) {
 297   4                        //æˆåŠŸæç¤º
C51 COMPILER V9.60.0.0   SYSTEM                                                            03/08/2023 18:02:10 PAGE 6   

 298   4                      }else {
 299   4                        //é”™è¯¯æç¤º
 300   4                      }
 301   3                      
 302   3                      i += (dp_len + 4);
 303   3                  }
 304   2              break;
 305   2                
 306   2      #ifdef SUPPORT_MCU_FIRM_UPDATE
 307   2              case MCU_UG_REQ_CMD:                                    //è¯·æ±‚å‡çº§
 308   2                  mcu_update_handle(wifi_data_process_buf[offset + DATA_START]);
 309   2              break;
 310   2              
 311   2              case UPDATE_START_CMD:                                  //å‡çº§å¼€å§‹
 312   2                  firm_length = wifi_data_process_buf[offset + DATA_START];
 313   2                  firm_length <<= 8;
 314   2                  firm_length |= wifi_data_process_buf[offset + DATA_START + 1];
 315   2                  firm_length <<= 8;
 316   2                  firm_length |= wifi_data_process_buf[offset + DATA_START + 2];
 317   2                  firm_length <<= 8;
 318   2                  firm_length |= wifi_data_process_buf[offset + DATA_START + 3];
 319   2                  //
 320   2                  wifi_uart_write_frame(UPDATE_START_CMD,0);
 321   2                  firm_update_flag = UPDATE_START_CMD;
 322   2              break;
 323   2                
 324   2              case UPDATE_TRANS_CMD:                                  //å‡çº§ä¼ è¾“
 325   2                  if(firm_update_flag == UPDATE_START_CMD) {
 326   3                      //åœæ­¢ä¸€åˆ‡æ•°æ®ä¸ŠæŠ¥
 327   3                      stop_update_flag = ENABLE;                                                 
 328   3                      
 329   3                      total_len = wifi_data_process_buf[offset + LENGTH_HIGH] * 0x100;
 330   3                      total_len += wifi_data_process_buf[offset + LENGTH_LOW];
 331   3                      
 332   3                      dp_len = wifi_data_process_buf[offset + DATA_START];
 333   3                      dp_len <<= 8;
 334   3                      dp_len |= wifi_data_process_buf[offset + DATA_START + 1];
 335   3                      dp_len <<= 8;
 336   3                      dp_len |= wifi_data_process_buf[offset + DATA_START + 2];
 337   3                      dp_len <<= 8;
 338   3                      dp_len |= wifi_data_process_buf[offset + DATA_START + 3];
 339   3                      
 340   3                      firmware_addr = (unsigned char *)wifi_data_process_buf;
 341   3                      firmware_addr += (offset + DATA_START + 4);
 342   3                      if((total_len == 4) && (dp_len == firm_length)) {
 343   4                          //æœ€åä¸€åŒ…
 344   4                          ret = mcu_firm_update_handle(firmware_addr,dp_len,0);
 345   4                          
 346   4                          firm_update_flag = 0;
 347   4                      }else if((total_len - 4) <= FIRM_UPDATA_SIZE) {
 348   4                          ret = mcu_firm_update_handle(firmware_addr,dp_len,total_len - 4);
 349   4                      }else {
 350   4                          firm_update_flag = 0;
 351   4                          ret = ERROR;
 352   4                      }
 353   3                      
 354   3                      if(ret == SUCCESS) {
 355   4                          wifi_uart_write_frame(UPDATE_TRANS_CMD,0);
 356   4                      }
 357   3                      //æ¢å¤ä¸€åˆ‡æ•°æ®ä¸ŠæŠ¥
 358   3                      stop_update_flag = DISABLE;    
 359   3                  }
C51 COMPILER V9.60.0.0   SYSTEM                                                            03/08/2023 18:02:10 PAGE 7   

 360   2              break;
 361   2      #endif      
 362   2      
 363   2      #ifdef SUPPORT_MCU_RTC_CHECK
                      case GET_LOCAL_TIME_CMD:                          //è·å–æœ¬åœ°æ—¶é—´
                          mcu_write_rtctime(wifi_data_process_buf + offset + DATA_START);
                      break;
              #endif
 368   2         
 369   2      #ifdef WIFI_TEST_ENABLE
 370   2              case WIFI_TEST_CMD:                                     //wifiåŠŸèƒ½æµ‹è¯•
 371   2                  wifi_test_result(wifi_data_process_buf[offset + DATA_START],wifi_data_process_buf[offset + DAT
             -A_START + 1]);
 372   2              break;
 373   2      #endif
 374   2      
 375   2              case WIFI_UG_REQ_CMD:                                   //è¯·æ±‚WIFIæ¨¡å—å›ºä»¶å‡çº§
 376   2                  wifi_update_handle(wifi_data_process_buf[offset + DATA_START]);
 377   2              break;
 378   2      
 379   2      #ifdef LOCK_API_ENABLE
 380   2              case GET_GL_TIME_CMD:                                   //è·å–æ ¼æ—æ—¶é—´
 381   2                  mcu_write_gltime(wifi_data_process_buf + offset + DATA_START);
 382   2              break;
 383   2      
 384   2              case TEMP_PASS_CMD:                                     //è¯·æ±‚äº‘ç«¯ä¸´æ—¶å¯†ç ï¼ˆåªæ”¯æŒå•ç
             -»„ï¼‰
 385   2                  if (wifi_data_process_buf[offset + DATA_START] == 1) {
 386   3                      total_len = wifi_data_process_buf[offset + LENGTH_HIGH] * 0x100;
 387   3                      total_len += wifi_data_process_buf[offset + LENGTH_LOW];
 388   3      
 389   3                      temp_pass_handle(wifi_data_process_buf[offset + DATA_START], wifi_data_process_buf + offse
             -t + DATA_START + 1,
 390   3                                       wifi_data_process_buf + offset + DATA_START + 7, total_len - 7);
 391   3                  }else {
 392   3                      temp_pass_handle(wifi_data_process_buf[offset + DATA_START], 0, 0, 0);
 393   3                  }
 394   2              break;
 395   2      
 396   2              case PASS_CHECK_CMD:                                    //åŠ¨æ€å¯†ç æ ¡éªŒ
 397   2                  pass_check_handle(wifi_data_process_buf[offset + DATA_START]);
 398   2              break;
 399   2      
 400   2              case MUL_TEMP_PASS_CMD:                                 //è¯·æ±‚äº‘ç«¯ä¸´æ—¶å¯†ç ï¼ˆæ”¯æŒå¤šç»„ï
             -¼‰
 401   2                  mul_temp_pass_handle(wifi_data_process_buf + offset + DATA_START);
 402   2              break;
 403   2              
 404   2              case SCHEDULE_TEMP_PASS_CMD:                            //è¯·æ±‚äº‘ç«¯ä¸´æ—¶å¯†ç ï¼ˆå¸¦scheduleåˆ
             -—è¡¨ï¼‰
 405   2                  schedule_temp_pass_handle(wifi_data_process_buf + offset + DATA_START);
 406   2              break;
 407   2      #endif
 408   2      
 409   2      #ifdef DP_CACHE_SUPPORT
                      case GET_DP_CACHE_CMD:                                  //è·å–dpç¼“å­˜æŒ‡ä»¤
                          total_len = wifi_data_process_buf[offset + LENGTH_HIGH] * 0x100;//åé¢çš„æ€»å­—èŠ‚æ•°
                          total_len += wifi_data_process_buf[offset + LENGTH_LOW];
                          
                          result = wifi_data_process_buf[offset + DATA_START]; //è·å–æŒ‡ä»¤æˆåŠŸæ ‡å¿—
                          if(result == 0) {     //è·å–æŒ‡ä»¤å¤±è´¥
                              //ç”¨æˆ·è‡ªè¡Œå®ç°è·å–æŒ‡ä»¤å¤±è´¥åçš„æ“ä½œ
C51 COMPILER V9.60.0.0   SYSTEM                                                            03/08/2023 18:02:10 PAGE 8   

                            
                          }else {               //è·å–æŒ‡ä»¤æˆåŠŸ
                              dp_num = wifi_data_process_buf[offset + DATA_START + 1];//è·å–åˆ°çš„dpæ•°é‡
                              
                              for(i = 2;i < total_len;) {
                                  dp_len = wifi_data_process_buf[offset + DATA_START + i + 2] * 0x100; //valueçš„å­—èŠ‚æ
             -•°
                                  dp_len += wifi_data_process_buf[offset + DATA_START + i + 3];
              
                                  //å¤„ç†çŠ¶æ€æ•°æ®å•å…ƒ
                                  ret = data_point_handle((unsigned char *)wifi_data_process_buf + offset + DATA_START +
             - i);
                                  
                                  if(SUCCESS == ret) {
                                      //æˆåŠŸæç¤º
                                  }else {
                                      //é”™è¯¯æç¤º
                                  }
                                  
                                  i += (dp_len + 4);  //dp_len(value) + len(2) + type(1) + dpid(1)
                              }
                          }
                      break;
              #endif
 439   2      
 440   2      #ifdef OFFLINE_DYN_PW_ENABLE
                      case OFFLINE_DYN_PW_CMD:                                //ç¦»çº¿åŠ¨æ€å¯†ç 
                          offline_dynamic_password_result(wifi_data_process_buf+offset + DATA_START);
                      break;
              #endif
 445   2          
 446   2      #ifdef REPORTED_MCU_SN_ENABLE
                      case REPORTED_MCU_SN_CMD:                               //ä¸ŠæŠ¥MCUçš„SN
                          mcu_sn_updata_result(wifi_data_process_buf[offset + DATA_START]);
                      break;
              #endif
 451   2              
 452   2      #ifdef LOCK_KEEP_ALIVE
                      case GET_WIFI_STATE_CMD:                                //è·å–WiFiçŠ¶æ€
                          get_wifi_state_result((unsigned char *)wifi_data_process_buf + offset + DATA_START);
                      break;
              #endif
 457   2              
 458   2      #ifdef WIFI_RESET_NOTICE_ENABLE
                      case WIFI_RESET_NOTICE_CMD:                             //æ¨¡å—é‡ç½®çŠ¶æ€é€šçŸ¥
                          wifi_reset_notice(wifi_data_process_buf[offset + DATA_START]);
                      break;
              #endif
 463   2      
 464   2      #ifdef PICTURE_UPLOAD_ENABLE
                      case PICTURE_EVENT_STATE_CMD:                           //äº‹ä»¶çŠ¶æ€é€šçŸ¥
                          picture_event_state_notice_result(wifi_data_process_buf[offset + DATA_START]);
                      break;
                      
                      case PICTURE_UPLOAD_CMD:                                //å›¾ç‰‡ä¸Šä¼ 
                          picture_upload_result(wifi_data_process_buf[offset + DATA_START]);
                      break;
                      
                      case PICTURE_UPLOAD_RETURN_CMD:                         //å›¾ç‰‡ä¸Šä¼ ç»“æœåé¦ˆ
                          total_len = wifi_data_process_buf[offset + LENGTH_HIGH] * 0x100;
                          total_len += wifi_data_process_buf[offset + LENGTH_LOW];
                          picture_upload_return(wifi_data_process_buf + offset + DATA_START, total_len);
C51 COMPILER V9.60.0.0   SYSTEM                                                            03/08/2023 18:02:10 PAGE 9   

                      break;
                      
                      case PICTURE_UPLOAD_STATE_GET_CMD:                      //å›¾ç‰‡ä¸Šä¼ çŠ¶æ€è·å–
                          total_len = wifi_data_process_buf[offset + LENGTH_HIGH] * 0x100;
                          total_len += wifi_data_process_buf[offset + LENGTH_LOW];
                          picture_upload_state_get_result(wifi_data_process_buf + offset + DATA_START, total_len);
                      break;
              #endif
 485   2              
 486   2      #ifdef PHOTO_LOCK_PICTURE_UPLOAD_ENABLE
                      case PHOTO_LOCK_PICTURE_UPLOAD_CMD:                      //æ‹ç…§é—¨é”å›¾ç‰‡ä¸Šä¼ ç›¸å…³åŠŸèƒ½
                          photo_lock_picture_upload_func(wifi_data_process_buf + offset + DATA_START);
                      break;
              #endif
 491   2              
 492   2              
 493   2              
 494   2              default:
 495   2              break;
 496   2          }
 497   1      }
*** WARNING C280 IN LINE 258 OF Drivers\Protocol\WIFI_Tuya\system.c: 'result': unreferenced local variable
*** WARNING C280 IN LINE 259 OF Drivers\Protocol\WIFI_Tuya\system.c: 'dp_num': unreferenced local variable
 498          
 499          /**
 500           * @brief  åˆ¤æ–­ä¸²å£æ¥æ”¶ç¼“å­˜ä¸­æ˜¯å¦æœ‰æ•°æ®
 501           * @param  Null
 502           * @return æ˜¯å¦æœ‰æ•°æ®
 503           */
 504          unsigned char get_queue_total_data(void)
 505          {
 506   1          if(queue_in != queue_out)
 507   1              return 1;
 508   1          else
 509   1              return 0;
 510   1      }
 511          
 512          /**
 513           * @brief  è¯»å–é˜Ÿåˆ—1å­—èŠ‚æ•°æ®
 514           * @param  Null
 515           * @return Read the _data
 516           */
 517          unsigned char Queue_Read_Byte(void)
 518          {
 519   1          unsigned char value;
 520   1          
 521   1          if(queue_out != queue_in) {
 522   2              //æœ‰æ•°æ®
 523   2              if(queue_out >= (unsigned char *)(wifi_uart_rx_buf + sizeof(wifi_uart_rx_buf))) {
 524   3                  //æ•°æ®å·²ç»åˆ°æœ«å°¾
 525   3                  queue_out = (unsigned char *)(wifi_uart_rx_buf);
 526   3              }
 527   2              
 528   2              value = *queue_out++;
 529   2          }
 530   1          
 531   1          return value;
 532   1      }
 533          


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.60.0.0   SYSTEM                                                            03/08/2023 18:02:10 PAGE 10  

   CODE SIZE        =   2129    ----
   CONSTANT SIZE    =     70    ----
   XDATA SIZE       =    513      61
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)

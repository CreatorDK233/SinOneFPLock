C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE YC_NFC_CONTACTLESS_L1
OBJECT MODULE PLACED IN .\Objects\yc_nfc_contactless_l1.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Drivers\Protocol\YC_NFC\yc_nfc_contactless_l1.c LARGE OMF2 OPTIMIZE(9,SP
                    -EED) BROWSE INCDIR(.\Drivers\Lib\c;.\Drivers\Lib\H;.\Drivers\Lib\IAP_Lib;.\Drivers\Lib\TouchKey_lib;.\Drivers\Physical;.
                    -\Drivers\Protocol;.\Softwares\Application;.\Softwares\Basic;.\Softwares\ModuleLogic;.\Drivers\Protocol\YC_NFC;.\Drivers\
                    -Protocol\WIFI_Tuya) DEBUG PRINT(.\Listings\yc_nfc_contactless_l1.lst) TABS(2) OBJECT(.\Objects\yc_nfc_contactless_l1.obj
                    -)

line level    source

   1          #include "yc_nfc_contactless_l1.h"
   2          #include "mifare.h"
   3          #include <string.h> 
   4          #include "mifare_crypto1.h"
   5          #include "Basic_Function.h"
   6          #include "IO.h"
   7          #include "Project.h"
   8          /*
   9          //æ³¨æ„1ï¼šNFC_Transceiveå‡½æ•°ä¸­ç­‰å¾…å‘é€å®Œæˆwhileè¶…æ—¶é€€å‡ºæ—¶é—´ä¸º15msï¼Œä¸¤å¤„ç­‰å¾…æŽ¥æ”¶å®
             -Œæˆwhileè¶…æ—¶é€€å‡ºæ—¶é—´ä¸º1sï¼ŒRATSä¸­whileè¶…æ—¶é€€å‡ºæ—¶é—´ä¸º1s.
  10          //æ³¨æ„2ï¼štypeBçš„è°ƒåˆ¶æ·±åº¦å¯„å­˜å™¨REG_TX_PA_MOD_GAINçš„å€¼è®¾ç½®å¿…é¡»å¤§äºŽç­‰äºŽ8
  11          //æ³¨æ„3ï¼šå¤ä½å¼•è„šç”±ä½Žåˆ°é«˜åŽå¯ä»¥åˆ¤æ–­REG_PMU_STATEå¯„å­˜å™¨å¤§äºŽç­‰äºŽ3æ—¶è¿›è¡ŒåŽç»­å¯„å­
             -˜å™¨é…ç½®
  12          //æ³¨æ„4ï¼šå¢žåŠ ä¸Šç”µDCçŸ«æ­£åŠŸèƒ½ï¼Œç”¨äºŽé‡äº§æ—¶å¯¹æ¯ä¸ªèŠ¯ç‰‡çŸ«æ­£ã€‚
  13          */
  14          
  15          #ifdef Function_NFCUsed_YC5018
  16          
  17          NFC_Poll_Type_t Poll_Type;
  18          
  19          YC_NFC_Contactless_L1_PICC_A_pcb_t picc_a;
  20          YC_NFC_Contactless_L1_PICC_B_pcb_t picc_b;
  21          
  22          static unsigned char PCB;
  23          static signed char WTXM;
  24          static unsigned char FWI;
  25          static unsigned char FSCI;
  26          static unsigned char Block_Num;
  27          bit NFC_TIM_FLAG = 0;
  28          uint16_t NFC_TIM_COUNT = 0;
  29          static uint8_t NFC_UID[5];
  30          
  31          u32  Contactless_mscnt = 0;
  32          
  33          #define   TIM0_CNTNFC    TIM_CNT(0)
  34          code u16 FSC_Table[] = {16, 24, 32, 40, 48, 64, 96, 128, 256, 512, 1024, 2048, 4096};
  35          
  36          u8 gain_i_q_table[9][3] =
  37          {
  38              {RX_GAIN_6DB, 0, 0},
  39              {RX_GAIN_12DB, 0, 0},
  40              {RX_GAIN_18DB, 0, 0},
  41              {RX_GAIN_24DB, 0, 0},
  42              {RX_GAIN_30DB, 0, 0},
  43              {RX_GAIN_36DB, 0, 0},
  44              {RX_GAIN_42DB, 0, 0},
  45              {RX_GAIN_48DB, 0, 0},
  46              {RX_GAIN_54DB, 0, 0},
  47          }; /* gain,i,q */
  48          
  49          static unsigned char bit_rate = 0;
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 2   

  50          uint8_t cardtype=0;
  51          /*
  52          å‡½æ•°åŠŸèƒ½:  NFCæ—¶é’Ÿé…ç½®
  53          */
  54          void NFC_Systick_Init(void)
  55          {
  56   1      }
  57          /*
  58          å‡½æ•°åŠŸèƒ½:  NFCä¸Šç”µåˆå§‹åŒ–é…ç½®
  59          å½¢å‚ï¼šSoftware_reset ï¼šç½®1 NFC Reset æŽ¥ä¸»æŽ§IOæŽ§åˆ¶ï¼›ç½®0 NFC Reset æ‹‰é«˜
  60              External_irrigation_clock ï¼šç½®1 ï¼šNFCæ—¶é’Ÿä¸ç”±æ™¶ä½“ä¾›ç»™ï¼›ç½®0 NFCæ—¶é’Ÿç”±æ™¶ä½“ä¾›ç»™
  61          */
  62          //void YC_NFC_CoreReg_Init(u8 Software_reset, u8 External_irrigation_clock)
  63          //{
  64          //    u8 RegBuff[12];
  65          
  66          //    if (Software_reset)
  67          //    {
  68          //        if (External_irrigation_clock)
  69          //        {
  70          //            NFC_Systick_Init();
  71          //        }
  72          
  73          //        Soft_Delay1ms(10);
  74          
  75          //        YC_NFC_HwReset();
  76          //        if (External_irrigation_clock)
  77          //        {
  78          //            WRITEREG(REG_LDO_ADC_CLKGEN_LPO_CTRL, 0xB4);
  79          //            WRITEREG(REG_XTAL_CTRL4, 0x24);
  80          //            WRITEREG(REG_LDO_CORE_LPO_CLK_CTRL, 0x5b);
  81          //        }
  82          //        DC_cali_alg(3);
  83          //        YC_NFC_HwReset();
  84          //        if (External_irrigation_clock)
  85          //        {
  86          //            WRITEREG(REG_LDO_ADC_CLKGEN_LPO_CTRL, 0xB4);
  87          //            WRITEREG(REG_XTAL_CTRL4, 0x24);
  88          //            WRITEREG(REG_LDO_CORE_LPO_CLK_CTRL, 0x5b);
  89          //        }
  90          //    }
  91          //    else
  92          //    {
  93          //        if (External_irrigation_clock)
  94          //        {
  95          //            NFC_Systick_Init();
  96          //        }
  97          //        Soft_Delay1ms(100);
  98          //        CLRWDT();
  99          //        Soft_Delay1ms(200);
 100          //        CLRWDT();
 101          //        Soft_Delay1ms(200);
 102          //        CLRWDT();
 103          //        WRITEREG(171, 0x04);
 104          //        WRITEREG(174, 0x04);
 105          //        if (External_irrigation_clock)
 106          //        {
 107          //            WRITEREG(REG_LDO_ADC_CLKGEN_LPO_CTRL, 0xB4);
 108          //            WRITEREG(REG_XTAL_CTRL4, 0x24);
 109          //            WRITEREG(REG_LDO_CORE_LPO_CLK_CTRL, 0x5b);
 110          //        }
 111          
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 3   

 112          //        RegBuff[0] = READREG(1);
 113          //        RegBuff[1] = READREG(148);
 114          //        RegBuff[2] = READREG(83);
 115          //        RegBuff[3] = READREG(65);
 116          //        RegBuff[4] = READREG(66);
 117          //        RegBuff[5] = READREG(68);
 118          //        RegBuff[6] = READREG(69);
 119          //        RegBuff[7] = READREG(149);
 120          //        RegBuff[8] = READREG(150);
 121          //        RegBuff[9] = READREG(151);
 122          //        RegBuff[10] = READREG(171);
 123          //        RegBuff[11] = READREG(174);
 124          
 125          //        DC_cali_alg(3);
 126          
 127          //        WRITEREG(1, RegBuff[0]);
 128          //        WRITEREG(148, RegBuff[1]);
 129          //        WRITEREG(183, RegBuff[2]);
 130          //        WRITEREG(65, RegBuff[3]);
 131          //        WRITEREG(66, RegBuff[4]);
 132          //        WRITEREG(68, RegBuff[5]);
 133          //        WRITEREG(69, RegBuff[6]);
 134          //        WRITEREG(149, RegBuff[7]);
 135          //        WRITEREG(150, RegBuff[8]);
 136          //        WRITEREG(151, RegBuff[9]);
 137          //        WRITEREG(171, RegBuff[10]);
 138          //        WRITEREG(174, RegBuff[11]);
 139          //    }
 140          //}
 141          
 142          /*
 143          å‡½æ•°åŠŸèƒ½:  APDU ä¼ è¾“æµ‹è¯•
 144          */
 145          unsigned char YC_NFC_Apdu_Transmission_Test(void)
 146          {
 147   1          uint8_t err_no, ResBuff[256];
 148   1          uint16_t ResLen;
 149   1          code uint8_t ApduBuff[] = {0x00, 0xA4, 0x04, 0x00, 0x0E, 0x32, 0x50, 0x41, 0x59, 0x2E, 0x53, 0x59, 0x5
             -3, 0x2E, 0x44, 0x44, 0x46, 0x30, 0x31, 0x00};
 150   1          err_no = YC_NFC_Contactless_APDU_Transceive(ApduBuff, sizeof(ApduBuff), ResBuff, &ResLen);
 151   1          return err_no;
 152   1      }
 153          /*
 154          å‡½æ•°åŠŸèƒ½: è¿›è¡ŒTypeAï¼ŒTypeB è½®è¯¢å¯»å¡ï¼Œæœ‰å¡è¿›è¡Œå†²çªæ£€æµ‹ï¼Œå¹¶æ¿€æ´»
 155          */
 156          unsigned char YC_NFC_Active_card(void)
 157          {
 158   1        unsigned char err_no = NFC_ERR_NONE;
 159   1        Poll_Type.Type_A = 0;
 160   1        Poll_Type.Type_B = 0;
 161   1        if (!Poll_Type.Type_A)
 162   1        {
 163   2          err_no = YC_NFC_Contactless_WUPA();
 164   2          if(err_no == EOT_SHOUT )
 165   2            return EOT_SHOUT;
 166   2          if (err_no == NFC_ERR_NONE)
 167   2          {
 168   3              Poll_Type.Type_A = 1;
 169   3              YC_NFC_Contactless_HLTA();
 170   3          }
 171   2          if (!Poll_Type.Type_B)
 172   2          {
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 4   

 173   3            err_no = YC_NFC_Contactless_WUPB(NULL);
 174   3            if(err_no == EOT_SHOUT )
 175   3              return EOT_SHOUT;
 176   3            if (err_no == NFC_ERR_NONE)
 177   3            {
 178   4                Poll_Type.Type_B = 1;
 179   4            }
 180   3          }
 181   2        }
 182   1        if (!(Poll_Type.Type_A || Poll_Type.Type_B))
 183   1          return NFC_ERR_NO_CARD;
 184   1      
 185   1        if (Poll_Type.Type_A && Poll_Type.Type_B) 
 186   1          return NFC_ERR_COLLISION;
 187   1      
 188   1        else if (Poll_Type.Type_A)
 189   1        {
 190   2          err_no = YC_NFC_A_Collision_Detect();
 191   2          if(err_no == EOT_SHOUT )
 192   2              return EOT_SHOUT;
 193   2        }
 194   1        else if (Poll_Type.Type_B) 
 195   1        {
 196   2          err_no = YC_NFC_B_Collision_Detect();
 197   2          if(err_no == EOT_SHOUT )
 198   2              return EOT_SHOUT;
 199   2        }
 200   1        if (err_no == NFC_ERR_NONE)
 201   1        {
 202   2          if(cardtype != TYPEA_M1)
 203   2          {
 204   3            if (Poll_Type.Type_A) 
 205   3            {
 206   4              err_no = YC_NFC_Contactless_RATS();
 207   4              if(err_no == EOT_SHOUT )
 208   4                return EOT_SHOUT;
 209   4            }
 210   3      
 211   3            else if (Poll_Type.Type_B) 
 212   3            {
 213   4              err_no = YC_NFC_Contactless_ATTRIB();
 214   4              if(err_no == EOT_SHOUT )
 215   4                return EOT_SHOUT;
 216   4            }
 217   3          }
 218   2        }
 219   1        return err_no;
 220   1      }
 221          
 222          /**
 223            * @brief      Set REG bit
 224            * @param      addr: REG addr
 225            * @param      mask: val
 226            * @retval None
 227            */
 228          void SETBITMASK(unsigned char addr, unsigned char mask)
 229          {
 230   1          unsigned char reg=0;
 231   1          reg = READREG(addr);
 232   1          WRITEREG(addr, (reg | mask));
 233   1      }
 234          
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 5   

 235          /**
 236            * @brief      Clear REG bit
 237            * @param      addr: REG addr
 238            * @param      mask: val
 239            * @retval None
 240            */
 241          static void CLEARBITMASK(unsigned char addr, unsigned char mask)
 242          {
 243   1          unsigned char reg=0;
 244   1          reg = READREG(addr);
 245   1          WRITEREG(addr, (reg & (~mask)));
 246   1      }
 247          
 248          /**
 249            * @brief      Set time out timer.
 250            * @param      prescal: prescaler of time out timer.
 251            * @param      reload: reload of time out timer.
 252            * @retval None
 253            */
 254          static void NFC_Set_Timer(u16 prescal, u16 reload)
 255          {
 256   1          WRITEREG(REG_T_PRESCAL_HI, (prescal >> 8) & 0x1f);
 257   1          WRITEREG(REG_T_PRESCAL_LO, prescal & 0xff);
 258   1          WRITEREG(REG_T_RELOAD_HI, (reload >> 8) & 0xff);
 259   1          WRITEREG(REG_T_RELOAD_LO, reload & 0xff);
 260   1          WRITEREG(REG_T_CTRL, 0x38);
 261   1      }
 262          
 263          /**
 264            * @brief      N-th power of 2
 265            * @param      n: number of power
 266            * @retval     the result of N-th power of 2
 267            */
 268          static u32 NFC_Power(unsigned char n)
 269          {
 270   1          return (1 << n);
 271   1      }
 272          
 273          /**
 274            * @brief      Set FWT
 275            * @param      t: time
 276            * @retval None
 277            */
 278          static void NFC_Set_FWT(u32 t)
 279          {
 280   1          u16 prescal=0, reload=0;
 281   1      
 282   1          reload = 65535;
 283   1          prescal = t / 65535 - 1;
 284   1      
 285   1          NFC_Set_Timer(prescal, reload);
 286   1      }
 287          
 288          /* Hardware reset */
 289          unsigned char YC_NFC_HwReset(void)
 290          {
 291   1        unsigned char i = 0;
 292   1          SET_MFC_RST_L;
 293   1          Soft_Delay1ms(20);
 294   1          SET_MFC_RST_H;
 295   1        Soft_Delay1ms(20);
 296   1        while ((READREG(REG_PMU_STATE) < 3 )|| (READREG(REG_PMU_STATE) >14 ))    {
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 6   

 297   2              Soft_Delay1ms(2);
 298   2              i++;
 299   2              if (i > 100)
 300   2              {
 301   3                  i = 100;
 302   3                  return 1;
 303   3              }
 304   2          }
 305   1          return 0;
 306   1      }
 307          #define AntiColExceptionProcess() do{                   \
 308                              if(errno == NFC_ERR_PARA)     \
 309                              {                 \
 310                                return NFC_ERR_PARA;      \
 311                              }                 \
 312                              if(errno == NFC_ERR_TRANSMISSION) \
 313                              {                 \
 314                                return NFC_ERR_COLLISION;   \
 315                              }                 \
 316                              else if(errno == NFC_ERR_PROTOCOL)  \
 317                              {                 \
 318                                return NFC_ERR_PROTOCOL;    \
 319                              }                 \
 320                              else if(errno == NFC_ERR_TIME_OUT)  \
 321                              {                 \
 322                                ++retr;             \
 323                                if(retr > 2)          \
 324                                  return NFC_ERR_TIME_OUT;  \
 325                                Tretransmission();        \
 326                              }                 \
 327                            }while(0)
 328          
 329          #define GeneralExceptionProcess() do{                   \
 330                              if(errno == NFC_ERR_PARA)     \
 331                              {                 \
 332                                return NFC_ERR_PARA;      \
 333                              }                 \
 334                              if(errno == NFC_ERR_TRANSMISSION) \
 335                              {                 \
 336                                return NFC_ERR_TRANSMISSION;  \
 337                              }                 \
 338                              else if(errno == NFC_ERR_PROTOCOL)  \
 339                              {                 \
 340                                return NFC_ERR_PROTOCOL;    \
 341                              }                 \
 342                              else if(errno == NFC_ERR_TIME_OUT)  \
 343                              {                 \
 344                                ++retr;             \
 345                                if(retr > 2)          \
 346                                  return NFC_ERR_TIME_OUT;  \
 347                                Tretransmission();        \
 348                              }                 \
 349                            }while(0)
 350          
 351          /**
 352            * @brief  Common initialization
 353            * @param  reg_config: used for external register configuration
 354            * @note if not use this value, can input NULL
 355            * @retval None
 356            */
 357          void YC_NFC_Contactless_Init(void)
 358          {
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 7   

 359   1          SETBITMASK(REG_TOP_CTRL, 0x10);
 360   1      
 361   1          WRITEREG(REG_IRQ0_EN, 0x00);
 362   1          WRITEREG(REG_IRQ1_EN, 0x00);
 363   1      
 364   1          WRITEREG(REG_COLL_LEVEL, 0x06);
 365   1          WRITEREG(REG_DEMOD_CTRL, 0x88);
 366   1      
 367   1          WRITEREG(REG_ADC_CTRL, 0x00);
 368   1      
 369   1          WRITEREG(REG_TX_WAIT_CTRL, (((6780 >> 8) & 0x1f) << 2) | 0x02);
 370   1          WRITEREG(REG_TX_WAIT_FREQ, 0);
 371   1          WRITEREG(REG_TX_WAIT, 6780 & 0xff);
 372   1      
 373   1          WRITEREG(REG_RX_WAIT, 0x3b);
 374   1          WRITEREG(REG_RX_WAIT_FREQ, 0x04);
 375   1      
 376   1          WRITEREG(REG_WATER_LEVEL, WATER_LEVEL);
 377   1          WRITEREG(REG_MOD_WIDTH, 0x20);
 378   1      
 379   1          WRITEREG(REG_TEST_PA_CTRL, 0x14);
 380   1      
 381   1          SETBITMASK(REG_RSSI_CALC_CTRL, 0x02);
 382   1          SETBITMASK(REG_RSSI_CALC_CONFIG, 0x04);
 383   1        WRITEREG(REG_PIN_PE_CTRL, 0x23);
 384   1      
 385   1      
 386   1          WRITEREG(REG_RX_CTRL3, RX_CTRL3);
 387   1          WRITEREG(REG_RX_CTRL4, RX_CTRL4);
 388   1          WRITEREG(REG_RX_CTRL5, RX_CTRL5);
 389   1        
 390   1        SETBITMASK(REG_RX_TYPE_B_FRAMING, 0x02);
 391   1        SETBITMASK(REG_RX_TYPE_B_FRAMING, 0x01);
 392   1      
 393   1          Set_Min_Level(RX_MINLEVEL);     //è®¾ç½®æŽ¥æ”¶é—¨é™
 394   1          Set_Receive_Parameters(RX_GAIN_18DB, RX_I_R_500);       //è®¾ç½®æŽ¥æ”¶å¢žç›ŠåŠå†…éƒ¨ç”µé˜»
 395   1          Set_Carrier_Strength(PA_GAIN_VAL);  //è®¾ç½®å‘å°„åŠŸçŽ‡
 396   1      }
 397          
 398          /**
 399            * @brief  Set PCD read card type
 400            * @param  picc_type: type
 401            * @note   initialization Block_Num
 402            * @retval None
 403            */
 404          void YC_NFC_Contactless_Switch_Card_Type(unsigned char picc_type)
 405          {
 406   1          Block_Num = 0;
 407   1      
 408   1          if (picc_type == TYPE_A)
 409   1          {
 410   2              WRITEREG(REG_TX_PA_MOD_GAIN, 0x00);
 411   2              SETBITMASK(REG_TX_PA_GAIN_CTRL, 0x20);
 412   2      
 413   2              WRITEREG(REG_TX_CODER_CTRL, 0x00);
 414   2              WRITEREG(REG_RX_CODER_CTRL, 0x00);
 415   2      
 416   2              WRITEREG(REG_TX_CRC_CTRL, 0x04);
 417   2              WRITEREG(REG_RX_CRC_CTRL, 0x04);
 418   2          }
 419   1          else if (picc_type == TYPE_B)
 420   1          {
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 8   

 421   2              WRITEREG(REG_TX_PA_MOD_GAIN, MOD_INDEX);
 422   2              CLEARBITMASK(REG_TX_PA_GAIN_CTRL, 0x20);
 423   2      
 424   2              WRITEREG(REG_TX_CODER_CTRL, 0x04);
 425   2              WRITEREG(REG_RX_CODER_CTRL, 0x0c);
 426   2      
 427   2              WRITEREG(REG_TX_CRC_CTRL, 0x12);
 428   2              WRITEREG(REG_RX_CRC_CTRL, 0x12);
 429   2          }
 430   1      }
 431          
 432          /**
 433            * @brief  RF switch on or off
 434            * @param  on: specifies which switch on or switch off Operating Field
 435            *   This parameter can be one of the values:
 436            *     @arg ON:  switch on Operating Field
 437            *     @arg OFF: switch off Operating Field
 438            * @retval None
 439            */
 440          void YC_NFC_Contactless_Rf_Switch(unsigned char on)
 441          {
 442   1          if (on)
 443   1          {
 444   2              SETBITMASK(REG_TOP_CTRL, 0x01);
 445   2              SETBITMASK(REG_TX_PA_GAIN_CTRL, 0x10);
 446   2              SETBITMASK(REG_TX_PA_GAIN_CTRL, 0x20);
 447   2          }
 448   1          else
 449   1          {
 450   2              CLEARBITMASK(REG_TX_PA_GAIN_CTRL, 0x20);
 451   2              CLEARBITMASK(REG_TX_PA_GAIN_CTRL, 0x10);
 452   2          Soft_Delay1ms(2);
 453   2              CLEARBITMASK(REG_TOP_CTRL, 0x01);
 454   2          }
 455   1      }
 456          
 457          
 458          
 459          
 460          
 461          //void nfctimer0_enable(unsigned long num)
 462          //{
 463          //    TIM_InitTypeDef TIM_struct;
 464          //    enable_clock(CLKCLS_TIM);
 465          //    TIM_struct.period = num;
 466          //    TIM_struct.TIMx = (TIM_NumTypeDef)0;
 467          //    TIM_Init(&TIM_struct);
 468          //    TIM_Cmd((TIM_NumTypeDef)0, ENABLE);
 469          //}
 470          //void nfc_time_start(void)
 471          //{
 472          //    nfctimer0_enable(0xffffffff);
 473          //    //contactless_over_time_cnt = CONTACTLESS_OVER_TIME_VAL*CPU_MHZ;
 474          //  
 475          //  NFCMsCount();
 476          //}
 477          //u32  NFC_gettim_cnt(void)
 478          //{
 479          //  
 480          //  return TIM0_CNTNFC;
 481          //}
 482          //void NFCMsCount(void)
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 9   

 483          //{
 484          //  Contactless_mscnt  = (CPU_MHZ / 1000 );
 485          //  
 486          //}
 487          //unsigned char NFC_Shout_cnt(u32 last_cntnum ,u32 Num_Ms)
 488          //{
 489          //  if((last_cntnum - TIM0_CNTNFC) >= Num_Ms * Contactless_mscnt)
 490          //  {
 491          //    return EOT_SHOUT;
 492          //  
 493          //  }
 494          //    
 495          //  else 
 496          //  {
 497          //    return 0;
 498          //  
 499          //  }
 500          //}
 501          
 502          /**
 503            * @brief Interface of transceiving.
 504            * @param cmd: command
 505            * @param request: data sent to PICC
 506            * @param requestlen: length of data sent to PICC
 507            * @param txalign: number of bit of last byte sent to PICC
 508            * @param response: data received from PICC
 509            * @param responselen: length of data received from PICC
 510            * @param rxalign: the first bit received
 511            * @retval Error code
 512            */
 513          unsigned char NFC_Transceive(Cmd_t cmd,
 514                                              const unsigned char *request, u16 requestlen, unsigned char txalign,
 515                                              unsigned char *response, u16 *responselen, unsigned char rxalign)
 516          {
 517   1          u16 i = 0;
 518   1          unsigned char j = 0,errno = 0;
 519   1          unsigned char len = 0;
 520   1          u32 t = 0,cnt_num = 0;
 521   1          unsigned char err_flag = 0;
 522   1        unsigned char bn=0;
 523   1        static unsigned char b_len=0;
 524   1      
 525   1        
 526   1        
 527   1      
 528   1          if ((cmd != CMD_HLTA) && (!response || !responselen))
 529   1          {
 530   2              return NFC_ERR_PARA;
 531   2          }
 532   1          if (!request && (requestlen != 0))
 533   1          {
 534   2              return NFC_ERR_PARA;
 535   2          }
 536   1      
 537   1          WRITEREG(REG_COMMAND, IDLE);
 538   1      
 539   1          SETBITMASK(REG_FIFO_CTRL, 0x01);
 540   1          CLEARBITMASK(REG_FIFO_CTRL, 0x01);
 541   1      
 542   1          WRITEREG(REG_IRQ0_CLEAR, 0xff);
 543   1          WRITEREG(REG_IRQ0_CLEAR, 0x00);
 544   1          WRITEREG(REG_IRQ1_CLEAR, 0x07);
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 10  

 545   1          WRITEREG(REG_IRQ1_CLEAR, 0x00);
 546   1      
 547   1      
 548   1          if (bit_rate == TX_BAUD_RATE_106)
 549   1          {
 550   2              WRITEREG(REG_MOD_WIDTH, 0x26);
 551   2              CLEARBITMASK(REG_TX_PA_GAIN_CTRL, 0x20);
 552   2          }
 553   1          else if (bit_rate == TX_BAUD_RATE_212)
 554   1          {
 555   2              WRITEREG(REG_MOD_WIDTH, 0x12); // 16.5~20
 556   2              SETBITMASK(REG_TX_PA_GAIN_CTRL, 0x20);
 557   2          }
 558   1          else if (bit_rate == TX_BAUD_RATE_424)
 559   1          {
 560   2              WRITEREG(REG_MOD_WIDTH, 0x08); // 8~10
 561   2              SETBITMASK(REG_TX_PA_GAIN_CTRL, 0x20);
 562   2          }
 563   1          else
 564   1          {
 565   2              WRITEREG(REG_MOD_WIDTH, 0x04); // 4~5
 566   2              SETBITMASK(REG_TX_PA_GAIN_CTRL, 0x20);
 567   2          }
 568   1      
 569   1          if (txalign >= 8 || rxalign >= 8)
 570   1          {
 571   2              return NFC_ERR_PARA;
 572   2          }
 573   1          if (txalign != 0 || rxalign != 0)
 574   1          {
 575   2              CLEARBITMASK(REG_TX_CODER_CTRL, (BIT0 | BIT1 | BIT2) << 3);
 576   2              CLEARBITMASK(REG_RX_BIT_CTRL, BIT0 | BIT1 | BIT2);
 577   2      
 578   2              SETBITMASK(REG_TX_CODER_CTRL, txalign << 3);
 579   2              SETBITMASK(REG_RX_BIT_CTRL, rxalign & 0x07);
 580   2          }
 581   1          else
 582   1          {
 583   2              CLEARBITMASK(REG_TX_CODER_CTRL, (BIT0 | BIT1 | BIT2) << 3);
 584   2              CLEARBITMASK(REG_RX_BIT_CTRL, BIT0 | BIT1 | BIT2);
 585   2          }
 586   1      
 587   1        if(cmd == CMD_ANTICOLLISION || cmd == CMD_SELECT || cmd == CMD_RATS \
 588   1            || cmd == CMD_HLTA || cmd == CMD_IBLOCK || cmd == CMD_RBLOCK  ||cmd == CMD_SBLOCK \
 589   1          ||cmd==CMD_M0READ||cmd==CMD_M0WRITE)
 590   1        {
 591   2              SETBITMASK(REG_FRAM_CON, BIT0);
 592   2              SETBITMASK(REG_FRAM_CON, BIT1);
 593   2          }
 594   1        else if(cmd==CMD_MTRANSFER||cmd==CMD_MAUTH1||cmd==CMD_MAUTH2)
 595   1        {
 596   2          CLEARBITMASK(REG_FRAM_CON,BIT0);
 597   2          CLEARBITMASK(REG_FRAM_CON,BIT1);
 598   2        }
 599   1          else
 600   1          {
 601   2              CLEARBITMASK(REG_FRAM_CON, BIT0);
 602   2              SETBITMASK(REG_FRAM_CON, BIT1);
 603   2          }
 604   1      
 605   1          if (cmd == CMD_WUPA || cmd == CMD_REQA || cmd == CMD_ANTICOLLISION)
 606   1          {
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 11  

 607   2              CLEARBITMASK(REG_TX_CRC_CTRL, BIT0);
 608   2              CLEARBITMASK(REG_RX_CRC_CTRL, BIT0);
 609   2          }
 610   1        else if((cmd==CMD_MAUTH2)||cmd==CMD_MAUTH1||(cmd==CMD_MTRANSFER))
 611   1        {
 612   2          CLEARBITMASK(REG_TX_CRC_CTRL, BIT0);
 613   2          CLEARBITMASK(REG_RX_CRC_CTRL, BIT0);
 614   2        }
 615   1          else
 616   1          {
 617   2              SETBITMASK(REG_TX_CRC_CTRL, BIT0);
 618   2              SETBITMASK(REG_RX_CRC_CTRL, BIT0);
 619   2          }
 620   1      
 621   1          if (cmd == CMD_ANTICOLLISION || cmd == CMD_SELECT)
 622   1          {
 623   2              NFC_Set_Timer(0, 1400);        //9 * 128 + 84/20
 624   2          }
 625   1      
 626   1          else if (cmd == CMD_WUPA || cmd == CMD_REQA)
 627   1          {
 628   2              NFC_Set_Timer(WAIT_ATQA_PRESCALER, WAIT_ATQA_RELOAD);        //9 * 128 + 84/20
 629   2          }
 630   1      
 631   1          else if (cmd == CMD_RATS)
 632   1          {
 633   2              NFC_Set_Timer(4, 58812);        //FWT,ACTIVATION + Delta,Tpcd(16.4ms)
 634   2          }
 635   1      
 636   1          else if (cmd == CMD_WUPB || cmd == CMD_REQB)
 637   1          {
 638   2              NFC_Set_Timer(WAIT_ATQB_PRESCALER, WAIT_ATQB_RELOAD);        //FWT,ATQB + Delta,Tpcd(16.4ms)
 639   2          }
 640   1      
 641   1          else if (cmd == CMD_IBLOCK || cmd == CMD_RBLOCK || cmd == CMD_ATTRIB || cmd == CMD_HLTB)
 642   1          {
 643   2              t = (256 * 16 * NFC_Power(FWI) + 49152 + 222384) / 65535- 1;                         //FWT + Delta
             -,FWT + Delta,Tpcd
 644   2              NFC_Set_Timer((u16)t, 0xffff);  
 645   2              //NFC_Set_FWT(t);
 646   2          }
 647   1        else if(cmd==CMD_MAUTH1||cmd==CMD_MAUTH2||cmd==CMD_MTRANSFER||cmd==CMD_M0READ||cmd==CMD_M0WRITE)
 648   1        {
 649   2          NFC_Set_Timer(3, 0xffff);
 650   2          //NFC_Set_FWT(271200);
 651   2        }
 652   1        else if (cmd == CMD_SBLOCK)
 653   1        {
 654   2      
 655   2            if (WTXM * NFC_Power(FWI) > NFC_Power(14))
 656   2            {
 657   3                t = (256 * 16 * NFC_Power(14) + 49152 + 222384) / 65535 - 1;                  //FWT + Delta,FWT + Del
             -ta,Tpcd
 658   3                NFC_Set_Timer((u16)t, 0xffff); 
 659   3              //NFC_Set_FWT(t);
 660   3            }
 661   2            else
 662   2            {
 663   3                t = (WTXM * 256 * 16 * NFC_Power(FWI) + 49152 + 222384) / 65535 -1;  //WTXM * FWT + Delta,FWT + Delta
             -,Tpcd
 664   3                NFC_Set_Timer((u16)t, 0xffff); 
 665   3              //NFC_Set_FWT(t);
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 12  

 666   3            }
 667   2        }
 668   1        
 669   1        if((cmd==CMD_MTRANSFER)||cmd==CMD_MAUTH1||cmd==CMD_MAUTH2)
 670   1        {
 671   2          bn=requestlen%8;
 672   2          if(bn)
 673   2          {
 674   3            for(i=0;i<requestlen/8+1 && i<FIFO_LENGTH-3;i++)
 675   3            {
 676   4              WRITEREG(REG_FIFO_DATA,request[i]);
 677   4            }
 678   3          }
 679   2          else
 680   2          {
 681   3            for(i=0;i<requestlen/8 && i<FIFO_LENGTH-3;i++)
 682   3            {
 683   4              WRITEREG(REG_FIFO_DATA,request[i]);
 684   4            }
 685   3          }
 686   2          bn=requestlen%8;
 687   2          if(requestlen%8!=0)
 688   2          {
 689   3            WRITEREG(REG_TX_CODER_CTRL,(bn<<3));
 690   3          }
 691   2          i=requestlen;
 692   2        }
 693   1        else
 694   1        {
 695   2          if (cmd == CMD_IBLOCK)
 696   2          {
 697   3            WRITEREG(REG_FIFO_DATA, PCB);
 698   3          }
 699   2          for (i = 0; i < requestlen && i < FIFO_LENGTH - 3; i++)
 700   2          {
 701   3            WRITEREG(REG_FIFO_DATA, request[i]);
 702   3          }
 703   2        
 704   2        
 705   2        }
 706   1          
 707   1      
 708   1      
 709   1          SETBITMASK(REG_IRQ0_CLEAR, 0x20);
 710   1          CLEARBITMASK(REG_IRQ0_CLEAR, 0x20);
 711   1      
 712   1      
 713   1          if (cmd == CMD_HLTA)
 714   1          {
 715   2              WRITEREG(REG_COMMAND, TRANSMIT);
 716   2          }
 717   1          else
 718   1          {
 719   2              WRITEREG(REG_COMMAND, TRANSCEIVE);
 720   2          }
 721   1          while (i < requestlen)
 722   1          {
 723   2      
 724   2              if ((READREG(REG_IRQ0_STATE) & 0x20) != 0)
 725   2              {
 726   3                  if (requestlen - i > FIFO_LENGTH - WATER_LEVEL - 2)
 727   3                  {
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 13  

 728   4                      for (j = 0; j < FIFO_LENGTH - WATER_LEVEL - 2; j++)
 729   4                      {
 730   5                          WRITEREG(REG_FIFO_DATA, request[i++]);
 731   5                      }
 732   4                  }
 733   3                  else
 734   3                  {
 735   4                      for (; i < requestlen; i++)
 736   4                      {
 737   5                          WRITEREG(REG_FIFO_DATA, request[i]);
 738   5                      }
 739   4                  }
 740   3      
 741   3      
 742   3                  SETBITMASK(REG_IRQ0_CLEAR, 0x20);
 743   3                  CLEARBITMASK(REG_IRQ0_CLEAR, 0x20);
 744   3              }
 745   2          }
 746   1          NFC_TIM_COUNT = 0;
 747   1          while ((READREG(REG_IRQ0_STATE) & 0x08) == 0)
 748   1          {
 749   2            if( NFC_TIM_COUNT > 15 )
 750   2            {
 751   3              NFC_TIM_COUNT = 0;
 752   3              return EOT_SHOUT;
 753   3            }
 754   2          }
 755   1        
 756   1      
 757   1          SETBITMASK(REG_IRQ0_CLEAR, 0x40);
 758   1          CLEARBITMASK(REG_IRQ0_CLEAR, 0x40);
 759   1      //    SETBITMASK(REG_IRQ0_CLEAR, 0x01);
 760   1      //    CLEARBITMASK(REG_IRQ0_CLEAR, 0x01);
 761   1      
 762   1          if (cmd == CMD_HLTA)
 763   1          {
 764   2              return NFC_ERR_NONE;
 765   2          }
 766   1          
 767   1          NFC_TIM_COUNT = 0;
 768   1          
 769   1          while (1)
 770   1          {
 771   2             
 772   2      //        if ((READREG(REG_IRQ0_STATE) & 0x01) != 0)
 773   2      //        {
 774   2      //          return NFC_ERR_TIME_OUT;
 775   2      //        }
 776   2      
 777   2      
 778   2              if ((READREG(REG_IRQ0_STATE) & 0x04) != 0)
 779   2              {
 780   3                  break;
 781   3              }
 782   2      
 783   2      
 784   2              if ((READREG(REG_IRQ0_STATE) & 0x40) != 0)
 785   2              {
 786   3                  break;
 787   3              }
 788   2              
 789   2              if ((READREG(REG_IRQ0_STATE) & 0x01) != 0)
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 14  

 790   2              {
 791   3                return NFC_ERR_TIME_OUT;
 792   3              }
 793   2      
 794   2      
 795   2          }
 796   1          *responselen = 0;
 797   1      
 798   1          while ((READREG(REG_IRQ0_STATE) & 0x04) == 0)
 799   1          {
 800   2      
 801   2              if ((READREG(REG_IRQ0_STATE) & 0x40) != 0)
 802   2              {
 803   3                  for (i = 0; i < FIFO_LENGTH - WATER_LEVEL; i++)
 804   3                  {
 805   4      
 806   4                      if (*responselen > FSD)
 807   4                      {
 808   5                          return NFC_ERR_OVERFLOW;
 809   5                      }
 810   4                      if (*responselen < FSD)
 811   4                      {
 812   5                          response[*responselen] = READREG(REG_FIFO_DATA);
 813   5                      }
 814   4                      else
 815   4                      {
 816   5                          READREG(REG_FIFO_DATA);
 817   5                      }
 818   4      
 819   4                      *responselen += 1;
 820   4                  }
 821   3      
 822   3      
 823   3                  SETBITMASK(REG_IRQ0_CLEAR, 0x40);
 824   3                  CLEARBITMASK(REG_IRQ0_CLEAR, 0x40);
 825   3              }
 826   2      
 827   2      
 828   2          }
 829   1      
 830   1          len = READREG(REG_FIFO_LENGTH);
 831   1        b_len = READREG(REG_RX_LAST_BITS);
 832   1      
 833   1          for (i = 0; i < len; i++)
 834   1          {
 835   2              if (*responselen > FSD)
 836   2              {
 837   3                  return NFC_ERR_OVERFLOW;
 838   3              }
 839   2              if (*responselen < FSD)
 840   2              {
 841   3                  response[*responselen] = READREG(REG_FIFO_DATA);
 842   3              }
 843   2              else
 844   2              {
 845   3                  READREG(REG_FIFO_DATA);
 846   3              }
 847   2      
 848   2              *responselen += 1;
 849   2          }
 850   1        if (cmd ==CMD_MAUTH1 || cmd ==CMD_MAUTH2 || cmd ==CMD_MTRANSFER || cmd == CMD_M0READ || cmd == CMD_M0WRIT
             -E)
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 15  

 851   1        {
 852   2          err_flag = 0;
 853   2        }
 854   1        else
 855   1        {
 856   2          err_flag = READREG(REG_ERROR_FLAG);
 857   2        }
 858   1          if ((err_flag & 0x80) || (err_flag & 0x04) || (err_flag & 0x02) || (err_flag & 0x01))
 859   1          {
 860   2              return NFC_ERR_TRANSMISSION;
 861   2          }
 862   1          return NFC_ERR_NONE;
 863   1      }
 864          
 865          /**
 866            * @brief  APDU processing
 867            * @param  inf: APDU
 868            * @param  inflen: APDU length
 869            * @param  res: APDU response
 870            * @param  reslen: APDU response length
 871            * @retval Error code
 872            */
 873          unsigned char YC_NFC_Contactless_APDU_Transceive(const unsigned char *inf,
 874                  u16 inflen,
 875                  unsigned char *res,
 876                  u16 *reslen)
 877          {
 878   1          u16 i=0;
 879   1      
 880   1          unsigned char Recv[FSD] = {0};
 881   1          unsigned char S_Block[2] = {0};
 882   1          unsigned char R_Block[1] = {0};
 883   1      
 884   1          u16 FSC = 0;
 885   1          unsigned char Send_Len = 0;
 886   1          u16 Recv_Len = 0;
 887   1          unsigned char Send_Offset = 0;
 888   1          unsigned char Recv_Offset = 0;
 889   1      
 890   1          unsigned char Swtx=0;
 891   1      
 892   1          unsigned char Time_Out=0;
 893   1      
 894   1          unsigned char Tran_Err=0;
 895   1      
 896   1          unsigned char Retran=0;
 897   1      
 898   1          unsigned char Recieving=0;
 899   1          unsigned char errno = NFC_ERR_NONE;
 900   1      
 901   1          if (!inf || !res || !reslen)
 902   1          {
 903   2              return NFC_ERR_PARA;
 904   2          }
 905   1      
 906   1      #define ACK 0x0
 907   1      #define NAK 0x10
 908   1      #define SendFinish()    ((PCB & 0x10) == 0)
 909   1      #define SendRB(type)    do{                                                                               
             -                                                                      \
 910   1                                  if(Swtx > 2)                                                                                
             -                                    \
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 16  

 911   1                                  {                                                                                           
             -                                                    \
 912   1                                          return NFC_ERR_TIME_OUT;                                                                
             -                        \
 913   1                                  }                                                                                           
             -                                                    \
 914   1                                  if(Time_Out > 2)                                                                            
             -                                    \
 915   1                                  {                                                                                           
             -                                                    \
 916   1                                          return  NFC_ERR_TIME_OUT;                                                               
             -                        \
 917   1                                  }                                                                                           
             -                                                    \
 918   1                                  if(Tran_Err > 2)                                                                            
             -                                    \
 919   1                                  {                                                                                           
             -                                                    \
 920   1                                          return NFC_ERR_TRANSMISSION;                                                            
             -                \
 921   1                                  }                                                                                           
             -                                                    \
 922   1                                  R_Block[0] = (R_BLOCK << 6) | type | 0x22 | Block_Num;                                  \
 923   1                                  errno = NFC_Transceive(CMD_RBLOCK, R_Block, 1, 0, Recv, &Recv_Len, 0);  \
 924   1                          }while(0)
 925   1      
 926   1          FSC = FSC_Table[FSCI];
 927   1          if (FSC > FSC_CHAINING)
 928   1          {
 929   2              FSC = FSC_CHAINING;
 930   2          }
 931   1      
 932   1          *reslen = 0;
 933   1      
 934   1          while (1)
 935   1          {
 936   2              if ((inflen - Send_Offset) > FSC - 3)
 937   2              {
 938   3                  Send_Len = FSC - 3;
 939   3                  PCB = 0x12;
 940   3              }
 941   2              else
 942   2              {
 943   3                  Send_Len = inflen - Send_Offset;
 944   3                  PCB = 0x02;
 945   3              }
 946   2              PCB |= Block_Num;
 947   2              Retran = 0;
 948   2      
 949   2      send:
 950   2              Swtx = 0;
 951   2              Time_Out = 0;
 952   2              Tran_Err = 0;
 953   2              Recieving = 0;
 954   2              errno = NFC_Transceive(CMD_IBLOCK, inf + Send_Offset, Send_Len, 0, Recv, &Recv_Len, 0);
 955   2      
 956   2      check:
 957   2              if (errno == EOT_SHOUT)
 958   2              {
 959   3                  return EOT_SHOUT;
 960   3              }
 961   2              if (errno == NFC_ERR_TIME_OUT)
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 17  

 962   2              {
 963   3                  Time_Out += 1;
 964   3      
 965   3                  if (Recieving)
 966   3                  {
 967   4                      SendRB(ACK);
 968   4                  }
 969   3                  else
 970   3                  {
 971   4                      SendRB(NAK);
 972   4                  }
 973   3      
 974   3                  goto check;
 975   3              }
 976   2      
 977   2              if (errno == NFC_ERR_TRANSMISSION)
 978   2              {
 979   3                  Tran_Err += 1;
 980   3      
 981   3                  if (Recieving)
 982   3                  {
 983   4                      SendRB(ACK);
 984   4                  }
 985   3                  else
 986   3                  {
 987   4                      SendRB(NAK);
 988   4                  }
 989   3      
 990   3                  goto check;
 991   3              }
 992   2      
 993   2              switch ((Recv[0] >> 6) & 0x03)
 994   2              {
 995   3              case I_BLOCK:
 996   3                  if (Recv_Len + 2 > FSD)                                         //I-Block of length > FSD
 997   3                  {
 998   4                      return NFC_ERR_PROTOCOL;
 999   4                  }
1000   3                  if ((Recv[0] & 0x20) || !(Recv[0] & 0x02))      //b6 must be 0, b2 must be 1.
1001   3                  {
1002   4                      return NFC_ERR_PROTOCOL;
1003   4                  }
1004   3                  if ((Recv[0] & 0x08) || (Recv[0] & 0x04))       //CID and NAD are not allowed.
1005   3                  {
1006   4                      return NFC_ERR_PROTOCOL;
1007   4                  }
1008   3                  if ((Recv[0] & 0x01) != Block_Num)
1009   3                  {
1010   4                      return NFC_ERR_PROTOCOL;
1011   4                  }
1012   3      
1013   3                  if (!SendFinish())
1014   3                  {
1015   4                      return NFC_ERR_PROTOCOL;
1016   4                  }
1017   3      
1018   3                  Block_Num ^= 0x01;
1019   3                  *reslen += Recv_Len - 1;
1020   3                  for (i = 1; i < Recv_Len; i++)
1021   3                  {
1022   4                      (res + Recv_Offset)[i - 1] = Recv[i];
1023   4                  }
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 18  

1024   3                  Recv_Offset += Recv_Len - 1;
1025   3      
1026   3                  if (Recv[0] & 0x10)
1027   3                  {
1028   4                      Swtx = 0;
1029   4                      Time_Out = 0;
1030   4                      Tran_Err = 0;
1031   4                      Recieving = 1;
1032   4      
1033   4                      SendRB(ACK);
1034   4      
1035   4                      goto check;
1036   4                  }
1037   3                  else
1038   3                  {
1039   4                      return NFC_ERR_NONE;
1040   4                  }
1041   3      
1042   3              case R_BLOCK:
1043   3                  if (!(Recv[0] & 0x20) || !(Recv[0] & 0x02))
1044   3                  {
1045   4                      return NFC_ERR_PROTOCOL;
1046   4                  }
1047   3                  if ((Recv[0] & 0x08) || (Recv[0] & 0x04))
1048   3                  {
1049   4                      return NFC_ERR_PROTOCOL;
1050   4                  }
1051   3                  if (Recv[0] & 0x10)
1052   3                  {
1053   4                      return NFC_ERR_PROTOCOL;
1054   4                  }
1055   3                  else
1056   3                  {
1057   4                      if (Recieving)
1058   4                      {
1059   5                          return NFC_ERR_PROTOCOL;
1060   5                      }
1061   4      
1062   4      
1063   4                      if ((Recv[0] & 0x01) != Block_Num)
1064   4                      {
1065   5                          if (++Retran > 2)
1066   5                          {
1067   6                              return NFC_ERR_PROTOCOL;
1068   6                          }
1069   5      
1070   5                          goto send;
1071   5                      }
1072   4      
1073   4      
1074   4                      if (SendFinish())
1075   4                      {
1076   5                          return NFC_ERR_PROTOCOL;
1077   5                      }
1078   4      
1079   4      
1080   4                      Block_Num ^= 0x01;
1081   4                      Send_Offset += Send_Len;
1082   4                  }
1083   3      
1084   3                  break;
1085   3      
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 19  

1086   3              case S_BLOCK:
1087   3                  if (Recv[0] & 0x01)
1088   3                  {
1089   4                      return NFC_ERR_PROTOCOL;
1090   4                  }
1091   3                  if ((Recv[0] & 0x04) || (Recv[0] & 0x08))
1092   3                  {
1093   4                      return NFC_ERR_PROTOCOL;
1094   4                  }
1095   3                  if (!(Recv[0] & 0x02) || ((Recv[0] & 0x30) != 0x30))
1096   3                  {
1097   4                      return NFC_ERR_PROTOCOL;
1098   4                  }
1099   3      
1100   3      
1101   3                  WTXM = Recv[1] & 0x3f;
1102   3                  if ((WTXM < 1) || (WTXM > 59))
1103   3                  {
1104   4                      return NFC_ERR_PROTOCOL;
1105   4                  }
1106   3      
1107   3      
1108   3                  S_Block[0] = (S_BLOCK << 6) | 0x30 | 0x02;
1109   3      
1110   3                  S_Block[1] = WTXM;
1111   3      
1112   3                  errno = NFC_Transceive(CMD_SBLOCK, S_Block, 2, 0, Recv, &Recv_Len, 0);
1113   3      
1114   3                  Swtx += 1;
1115   3      
1116   3                  goto check;
1117   3      
1118   3              default:
1119   3                  return NFC_ERR_PROTOCOL;
1120   3              }
1121   2          }
1122   1      }
1123          
1124          /*********************************************************** Type A command ******************************
             -*********************************/
1125          /**
1126            * @brief  WUPA
1127            * @param  None
1128            * @retval Error code
1129            */
1130          unsigned char YC_NFC_Contactless_WUPA(void)
1131          {
1132   1          unsigned char i=0;
1133   1          u16 len = 0;
1134   1          unsigned char errno = NFC_ERR_NONE;
1135   1          unsigned char WUPA[1]={0};
1136   1          unsigned char ATQA[FSD]={0};
1137   1      
1138   1      
1139   1          YC_NFC_Contactless_Switch_Card_Type(TYPE_A);
1140   1          Tp();
1141   1          WUPA[0] = 0x52;
1142   1      
1143   1      
1144   1      
1145   1      
1146   1          errno = NFC_Transceive(CMD_WUPA, WUPA, 1, 7, ATQA, &len, 0);
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 20  

1147   1          if (errno == NFC_ERR_NONE)
1148   1          {
1149   2      
1150   2      
1151   2              if (len != 2)
1152   2              {
1153   3                  return NFC_ERR_PROTOCOL;
1154   3              }
1155   2          }
1156   1      
1157   1          return errno;
1158   1      }
1159          
1160          /**
1161            * @brief  REQA
1162            * @param  None
1163            * @retval Error code
1164            */
1165          unsigned char YC_NFC_Contactless_REQA(void)
1166          {
1167   1          unsigned char i=0;
1168   1          u16 len = 0;
1169   1          unsigned char errno = NFC_ERR_NONE;
1170   1          unsigned char REQA[1]={0};
1171   1          unsigned char ATQA[FSD]={0};
1172   1      
1173   1          REQA[0] = 0x26;
1174   1      
1175   1      
1176   1      #ifdef  SDK_DEBUG
                  //PRINT("REQA ->: %02x\r\n", REQA[0]);
              #endif
1179   1      
1180   1          errno = NFC_Transceive(CMD_REQA, REQA, 1, 7, ATQA, &len, 0);
1181   1      
1182   1      
1183   1          if (errno == NFC_ERR_NONE)
1184   1          {
1185   2      #ifdef SDK_DEBUG
                      //PRINT("ATQA <-: ");
                      for (i = 0; i < len; i++)
                      {
                          //PRINT("%02x ", ATQA[i]);
                      }
                      //PRINT("\r\n");
              #endif
1193   2      
1194   2              if (len != 2)
1195   2              {
1196   3                  return NFC_ERR_PROTOCOL;
1197   3              }
1198   2          }
1199   1      
1200   1          return errno;
1201   1      }
1202          
1203          /**
1204            * @brief  ANTICOLLISION
1205            * @param  Cascade levelï¿½ï¿½ specifies cascade level
1206            *   This parameter can be one of the values:
1207            *     @arg CL1: cascase level 1
1208            *     @arg CL2: cascase level 2
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 21  

1209            *     @arg CL2: cascase level 3
1210            * @retval Error code
1211            */
1212          unsigned char YC_NFC_Contactless_ANTICOLLISION(unsigned char cl)
1213          {
1214   1          unsigned char i=0;
1215   1          u16 len = 0;
1216   1          unsigned char errno = NFC_ERR_NONE;
1217   1          unsigned char ANTICOLLISION[2]={0};
1218   1          unsigned char  UID_CLn_Temp[FSD]={0};
1219   1      
1220   1          ANTICOLLISION[0] = cl;
1221   1          ANTICOLLISION[1] = 0x20;
1222   1      
1223   1      
1224   1          SETBITMASK(REG_RX_BIT_CTRL, 0x10);
1225   1          CLEARBITMASK(REG_RX_BIT_CTRL, 0x08);
1226   1      
1227   1      #ifdef SDK_DEBUG
                  //PRINT("ANTICOLLISION ->: ");
                  for (i = 0; i < 2; i++)
                  {
                      //PRINT("%02x ", ANTICOLLISION[i]);
                  }
                  //PRINT("\r\n");
              #endif
1235   1      
1236   1          errno = NFC_Transceive(CMD_ANTICOLLISION, ANTICOLLISION, 2, 0, UID_CLn_Temp, &len, 0);
1237   1      
1238   1      
1239   1          CLEARBITMASK(REG_RX_BIT_CTRL, 0x10);
1240   1          SETBITMASK(REG_RX_BIT_CTRL, 0x08);
1241   1      
1242   1      
1243   1          if (errno == NFC_ERR_NONE)
1244   1          {
1245   2      
1246   2      #ifdef SDK_DEBUG
                      //PRINT("UID CLn <-: ");
                      for (i = 0; i < len; i++)
                      {
                          //PRINT("%02x ", UID_CLn_Temp[i]);
                      }
                      //PRINT("\r\n");
              #endif
1254   2              if (len != 5)
1255   2              {
1256   3                  return NFC_ERR_PROTOCOL;
1257   3              }
1258   2      
1259   2      
1260   2              if (UID_CLn_Temp[4] != (((UID_CLn_Temp[0] ^ UID_CLn_Temp[1]) ^ UID_CLn_Temp[2]) ^ UID_CLn_Temp[3])
             -)
1261   2              {
1262   3                  return NFC_ERR_TRANSMISSION;
1263   3      
1264   3              }
1265   2              switch (cl)
1266   2              {
1267   3              case CL1:
1268   3                  for (i = 0; i < len; i++)
1269   3                  {
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 22  

1270   4                      picc_a.UID_CLn[0][i] = UID_CLn_Temp[i];
1271   4                  }
1272   3                  break;
1273   3      
1274   3              case CL2:
1275   3                  for (i = 0; i < len; i++)
1276   3                  {
1277   4                      picc_a.UID_CLn[1][i] = UID_CLn_Temp[i];
1278   4                  }
1279   3                  break;
1280   3      
1281   3              case CL3:
1282   3                  for (i = 0; i < len; i++)
1283   3                  {
1284   4                      picc_a.UID_CLn[2][i] = UID_CLn_Temp[i];
1285   4                  }
1286   3                  break;
1287   3      
1288   3              default:
1289   3                  return NFC_ERR_PARA;
1290   3              }
1291   2          }
1292   1      
1293   1          return errno;
1294   1      }
1295          
1296          /**
1297            * @brief  SELECT
1298            * @note   When UID is complete, then check if PICC is compliant with ISO/IEC 14443-4
1299            * @param  clï¿½ï¿½ specifies cascade level
1300            *   This parameter can be one of the values:
1301            *     @arg CL1: cascase level 1
1302            *     @arg CL2: cascase level 2
1303            *     @arg CL2: cascase level 3
1304            * @param  UID_complete:
1305            *                       1: UID not complete
1306            *                       0: UID complete
1307            *     @note if not use this value, can input NULL
1308            * @param  ISOIEC14443_4_compliant:
1309            *           1: PICC compliant with ISO/IEC 14443-4
1310            *           0: PICC not compliant with ISO/IEC 14443-4
1311            *     @note if not use this value, can input NULL
1312            * @retval Error code
1313            */
1314          unsigned char YC_NFC_Contactless_SELECT(unsigned char cl,
1315                  unsigned char *UID_complete,
1316                  unsigned char *ISOIEC14443_4_compliant)
1317          {
1318   1          unsigned char i=0;
1319   1          u16 len = 0;
1320   1          unsigned char errno = NFC_ERR_NONE;
1321   1          unsigned char SELECT[7]={0};
1322   1          unsigned char SAK[FSD]={0};
1323   1      
1324   1          SELECT[0] = cl;
1325   1          SELECT[1] = 0x70;
1326   1      
1327   1          switch (cl)
1328   1          {
1329   2          case CL1:
1330   2              for (i = 0; i < 5; i++)
1331   2              {
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 23  

1332   3                  SELECT[2 + i] = picc_a.UID_CLn[0][i];
1333   3              }
1334   2              break;
1335   2      
1336   2          case CL2:
1337   2              for (i = 0; i < 5; i++)
1338   2              {
1339   3                  SELECT[2 + i] = picc_a.UID_CLn[1][i];
1340   3              }
1341   2              break;
1342   2      
1343   2          case CL3:
1344   2              for (i = 0; i < 5; i++)
1345   2              {
1346   3                  SELECT[2 + i] = picc_a.UID_CLn[2][i];
1347   3              }
1348   2              break;
1349   2      
1350   2          default:
1351   2              return NFC_ERR_PARA;
1352   2          }
1353   1      
1354   1      
1355   1      #ifdef SDK_DEBUG
                  //PRINT("SELECT ->: ");
                  for (i = 0; i < 7; i++)
                  {
                      //PRINT("%02x ", SELECT[i]);
                  }
                  //PRINT("\r\n");
              #endif
1363   1      
1364   1      
1365   1          errno = NFC_Transceive(CMD_SELECT, SELECT, 7, 0, SAK, &len, 0);
1366   1      
1367   1          if (errno == NFC_ERR_NONE)
1368   1          {
1369   2      #ifdef SDK_DEBUG
                      //PRINT("SAK <-: ");
                      for (i = 0; i < len; i++)
                      {
                          //PRINT("%02x ", SAK[i]);
                      }
                      //PRINT("\r\n");
              #endif
1377   2      
1378   2              if (len != 1)
1379   2              {
1380   3                  return NFC_ERR_PROTOCOL;
1381   3              }
1382   2      
1383   2              if (UID_complete)
1384   2              {
1385   3                  *UID_complete = (SAK[0] >> 2) & 0x01;
1386   3              }
1387   2      
1388   2              if (ISOIEC14443_4_compliant)
1389   2              {
1390   3                  *ISOIEC14443_4_compliant = (SAK[0] >> 5) & 0x01;
1391   3              }
1392   2          }
1393   1      
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 24  

1394   1          return errno;
1395   1      }
1396          
1397          /**
1398            * @brief  RATS
1399            * @param  None
1400            * @retval Error code
1401            */
1402          unsigned char YC_NFC_Contactless_RATS(void)
1403          {
1404   1          unsigned char i=0;
1405   1          u16 len = 0;
1406   1          unsigned char SFGI=0;
1407   1          unsigned char TA = 0, TB = 0, TC = 0;
1408   1          unsigned char errno = NFC_ERR_NONE;
1409   1          unsigned char RATS[2]={0};
1410   1          unsigned char ATS[FSD]={0};
1411   1      
1412   1          RATS[0] = 0xE0;
1413   1      
1414   1          RATS[1] = ((0x8 & 0xf) << 4);
1415   1      
1416   1          SETBITMASK(REG_RX_CODER_CTRL, 0x20);
1417   1      
1418   1      #ifdef SDK_DEBUG
                  //PRINT("RATS ->: ");
                  for (i = 0; i < 2; i++)
                  {
                      //PRINT("%02x ", RATS[i]);
                  }
                  //PRINT("\r\n");
              #endif
1426   1      
1427   1          errno = NFC_Transceive(CMD_RATS, RATS, 2, 0, ATS, &len, 0);
1428   1      
1429   1          if (errno == NFC_ERR_NONE)
1430   1          {
1431   2      #ifdef SDK_DEBUG
                      //PRINT("ATS <-: ");
                      for (i = 0; i < len; i++)
                      {
                          //PRINT("%02x ", ATS[i]);
                      }
                      //PRINT("\r\n");
              #endif
1439   2      
1440   2              if (ATS[0] != len)
1441   2              {
1442   3                  return NFC_ERR_PROTOCOL;
1443   3              }
1444   2      
1445   2              FWI = 4;
1446   2              FSCI = 2;
1447   2      
1448   2              if (ATS[0] != 1)
1449   2              {
1450   3                  if ((ATS[1] & 0xf) > 0xc)
1451   3                  {
1452   4                      FSCI = 0xc;
1453   4                  }
1454   3                  else
1455   3                  {
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 25  

1456   4                      FSCI = ATS[1] & 0xf;
1457   4                  }
1458   3      
1459   3                  if (ATS[1] & 0x10)
1460   3                  {
1461   4                      TA = 1;
1462   4                  }
1463   3      
1464   3                  if (ATS[1] & 0x20)
1465   3                  {
1466   4                      TB = 1;
1467   4                  }
1468   3      
1469   3                  if (ATS[1] & 0x40)
1470   3                  {
1471   4                      TC = 1;
1472   4                  }
1473   3      
1474   3                  if (TA)
1475   3                  {
1476   4      
1477   4      
1478   4                  }
1479   3      
1480   3                  if (TB)
1481   3                  {
1482   4      
1483   4                      if (((ATS[2 + TA] >> 4) & 0x0f) == 15)
1484   4                      {
1485   5                          FWI = 4;
1486   5                      }
1487   4                      else
1488   4                      {
1489   5                          FWI = (ATS[2 + TA] >> 4) & 0x0f;
1490   5                      }
1491   4      
1492   4      
1493   4                      if ((ATS[2 + TA] & 0x0f) == 15)
1494   4                      {
1495   5      
1496   5                      }
1497   4                      else
1498   4                      {
1499   5                          SFGI = ATS[2 + TA] & 0x0f;
1500   5      
1501   5                          WRITEREG(REG_T_PRESCAL_HI, (4480 >> 8) & 0x1f);
1502   5                          WRITEREG(REG_T_PRESCAL_LO, 4480 & 0xff);
1503   5                          WRITEREG(REG_T_RELOAD_HI, (NFC_Power(SFGI) >> 8) & 0xff);
1504   5                          WRITEREG(REG_T_RELOAD_LO, NFC_Power(SFGI) & 0xff);
1505   5      
1506   5      
1507   5                          SETBITMASK(REG_IRQ0_CLEAR, 0x01);
1508   5                          CLEARBITMASK(REG_IRQ0_CLEAR, 0x01);
1509   5      
1510   5      
1511   5                          WRITEREG(REG_T_CTRL, 0x01);
1512   5                          WRITEREG(REG_T_CTRL, 0x00);
1513   5                          NFC_TIM_COUNT = 0;
1514   5                          while ((READREG(REG_IRQ0_STATE) & 0x01) == 0)
1515   5                          {
1516   6                            if( NFC_TIM_COUNT > 1000 )
1517   6                            { 
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 26  

1518   7                              //NFC_TIM_COUNT = 0;
1519   7                              return EOT_SHOUT;     
1520   7                            }
1521   6                          }
1522   5                      }
1523   4                  }
1524   3                  if (TC)
1525   3                  {
1526   4      
1527   4                  }
1528   3      
1529   3      
1530   3              }
1531   2          }
1532   1      
1533   1          return errno;
1534   1      }
1535          
1536          /**
1537            * @brief  HLTA
1538            * @param  None
1539            * @retval None
1540            */
1541          void YC_NFC_Contactless_HLTA(void)
1542          {
1543   1          unsigned char i=0;
1544   1          unsigned char HLTA[2]={0};
1545   1      
1546   1          HLTA[0] = 0x50;
1547   1          HLTA[1] = 0x00;
1548   1      
1549   1      #ifdef SDK_DEBUG
                  //PRINT("HLTA ->: ");
                  for (i = 0; i < 2; i++)
                  {
                      //PRINT("%02x ", HLTA[i]);
                  }
                  //PRINT("\r\n");
              #endif
1557   1      
1558   1          NFC_Transceive(CMD_HLTA, HLTA, 2, 0, NULL, NULL, 0);
1559   1      }
1560          
1561          /*********************************************************** Type B command ******************************
             -*********************************/
1562          /**
1563            * @brief  WUPB
1564            * @param  ISOIEC14443_4_compliant:
1565            *           1: PICC compliant with ISO/IEC 14443-4
1566            *           0: PICC not compliant with ISO/IEC 14443-4
1567            *     @note if not use this value, can input NULL
1568            * @retval Error code
1569            */
1570          unsigned char YC_NFC_Contactless_WUPB(unsigned char *ISOIEC14443_4_compliant)
1571          {
1572   1          unsigned char i=0;
1573   1          u16 len = 0;
1574   1          unsigned char errno = NFC_ERR_NONE;
1575   1          unsigned char ATQB[FSD]={0};
1576   1          unsigned char WUPB[3]={0};
1577   1      
1578   1          YC_NFC_Contactless_Switch_Card_Type(TYPE_B);
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 27  

1579   1          Soft_Delay1ms(8);
1580   1      
1581   1          WUPB[0] = 0x05;
1582   1          WUPB[1] = 0x00;
1583   1          WUPB[2] = 0x08;
1584   1      
1585   1      #ifdef SDK_DEBUG
                  //PRINT("WUPB ->: ");
                  for (i = 0; i < 3; i++)
                  {
                      //PRINT("%02x ", WUPB[i]);
                  }
                  //PRINT("\r\n");
              #endif
1593   1      
1594   1      
1595   1          errno = NFC_Transceive(CMD_WUPB, WUPB, 3, 0, ATQB, &len, 0);
1596   1      
1597   1          if (errno == NFC_ERR_NONE)
1598   1          {
1599   2      
1600   2      #ifdef SDK_DEBUG
                      //PRINT("ATQB <-: ");
                      for (i = 0; i < len; i++)
                      {
                          //PRINT("%02x ", ATQB[i]);
                      }
                      //PRINT("\r\n");
              #endif
1608   2      
1609   2              if (ATQB[0] != 0x50)
1610   2              {
1611   3                  return NFC_ERR_PROTOCOL;
1612   3              }
1613   2      
1614   2              if (len < 12)
1615   2              {
1616   3                  return NFC_ERR_PROTOCOL;
1617   3              }
1618   2      
1619   2      
1620   2              for (i = 0; i < 4; i++)
1621   2              {
1622   3                  picc_b.PUPI[i] = ATQB[1 + i];
1623   3              }
1624   2      
1625   2      
1626   2              if (((ATQB[10] >> 4) & 0xf) > 0xc)
1627   2              {
1628   3                  FSCI = 0xc;
1629   3              }
1630   2              else
1631   2              {
1632   3                  FSCI = (ATQB[10] >> 4) & 0xf;
1633   3              }
1634   2      
1635   2      
1636   2              if (ISOIEC14443_4_compliant)
1637   2              {
1638   3                  *ISOIEC14443_4_compliant = ATQB[10] & 0x1;
1639   3              }
1640   2      
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 28  

1641   2              if ((ATQB[10] & 0x8) != 0)
1642   2              {
1643   3                  return NFC_ERR_PROTOCOL;
1644   3              }
1645   2      
1646   2      
1647   2              if (((ATQB[11] >> 4) & 0xf) == 15)
1648   2              {
1649   3                  FWI = 4;
1650   3              }
1651   2              else
1652   2              {
1653   3                  FWI = (ATQB[11] >> 4) & 0xf;
1654   3              }
1655   2          }
1656   1          return errno;
1657   1      }
1658          
1659          /**
1660            * @brief  REQB
1661            * @param  ISOIEC14443_4_compliant:
1662            *           1: PICC compliant with ISO/IEC 14443-4
1663            *           0: PICC not compliant with ISO/IEC 14443-4
1664            *     @note if not use this value, can input NULL
1665            * @retval Error code
1666            */
1667          unsigned char YC_NFC_Contactless_REQB(unsigned char *ISOIEC14443_4_compliant)
1668          {
1669   1          unsigned char i=0;
1670   1          u16 len=0;
1671   1          unsigned char errno = NFC_ERR_NONE;
1672   1          unsigned char ATQB[FSD]={0};
1673   1          unsigned char REQB[3]={0};
1674   1      
1675   1          YC_NFC_Contactless_Switch_Card_Type(TYPE_B);
1676   1          Soft_Delay1ms(3);
1677   1      
1678   1          REQB[0] = 0x05;
1679   1      
1680   1          REQB[1] = 0x00;
1681   1      
1682   1          REQB[2] = 0x00;
1683   1      
1684   1      
1685   1      #ifdef SDK_DEBUG
                  //PRINT("REQB ->: ");
                  for (i = 0; i < 3; i++)
                  {
                      //PRINT("%02x ", REQB[i]);
                  }
                  //PRINT("\r\n");
              #endif
1693   1      
1694   1          errno = NFC_Transceive(CMD_REQB, REQB, 3, 0, ATQB, &len, 0);
1695   1      
1696   1          if (errno == NFC_ERR_NONE)
1697   1          {
1698   2      
1699   2      
1700   2          #ifdef SDK_DEBUG
                      //PRINT("ATQB <-: ");
                      for (i = 0; i < len; i++)
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 29  

                      {
                          //PRINT("%02x ", ATQB[i]);
                      }
                      //PRINT("\r\n");
              #endif
1708   2      
1709   2              if (ATQB[0] != 0x50)
1710   2              {
1711   3                  return NFC_ERR_PROTOCOL;
1712   3              }
1713   2      
1714   2              if (len < 12)
1715   2              {
1716   3                  return NFC_ERR_PROTOCOL;
1717   3              }
1718   2      
1719   2      
1720   2              for (i = 0; i < 4; i++)
1721   2              {
1722   3                  picc_b.PUPI[i] = ATQB[1 + i];
1723   3              }
1724   2      
1725   2      
1726   2              if (((ATQB[10] >> 4) & 0xf) > 0xc)
1727   2              {
1728   3                  FSCI = 0xc;
1729   3              }
1730   2              else
1731   2              {
1732   3                  FSCI = (ATQB[10] >> 4) & 0xf;
1733   3              }
1734   2      
1735   2      
1736   2              if (ISOIEC14443_4_compliant)
1737   2              {
1738   3                  *ISOIEC14443_4_compliant = ATQB[10] & 0x1;
1739   3              }
1740   2      
1741   2              if ((ATQB[10] & 0x8) != 0)
1742   2              {
1743   3                  return NFC_ERR_PROTOCOL;
1744   3              }
1745   2      
1746   2      
1747   2              if (((ATQB[11] >> 4) & 0xf) == 15)
1748   2              {
1749   3                  FWI = 4;
1750   3              }
1751   2              else
1752   2              {
1753   3                  FWI = (ATQB[11] >> 4) & 0xf;
1754   3              }
1755   2      
1756   2          }
1757   1          return errno;
1758   1      }
1759          
1760          /**
1761            * @brief  ATTRIB
1762            * @param  None
1763            * @retval Error code
1764            */
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 30  

1765          unsigned char YC_NFC_Contactless_ATTRIB(void)
1766          {
1767   1          unsigned char i=0;
1768   1          u16 len=0;
1769   1          unsigned char errno = NFC_ERR_NONE;
1770   1          unsigned char ATTRIB[9]={0};
1771   1          unsigned char  ATTRIB_RES[FSD]={0};
1772   1      
1773   1          ATTRIB[0] = 0x1D;
1774   1      
1775   1          ATTRIB[1] = picc_b.PUPI[0];
1776   1          ATTRIB[2] = picc_b.PUPI[1];
1777   1          ATTRIB[3] = picc_b.PUPI[2];
1778   1          ATTRIB[4] = picc_b.PUPI[3];
1779   1      
1780   1          ATTRIB[5] = 0x00;
1781   1      
1782   1          ATTRIB[6] = 0x8 & 0xf;
1783   1      
1784   1          ATTRIB[7] = 0x01;
1785   1      
1786   1          ATTRIB[8] = 0x00;
1787   1      
1788   1      
1789   1          SETBITMASK(REG_RX_CODER_CTRL, 0x20);
1790   1      
1791   1      #ifdef SDK_DEBUG
                  //PRINT("ATTRIB ->: ");
                  for (i = 0; i < 9; i++)
                  {
                      //PRINT("%02x ", ATTRIB[i]);
                  }
                  //PRINT("\r\n");
              #endif
1799   1      
1800   1          errno = NFC_Transceive(CMD_ATTRIB, ATTRIB, 9, 0, ATTRIB_RES, &len, 0);
1801   1      
1802   1          if (errno == NFC_ERR_NONE)
1803   1          {
1804   2      
1805   2      
1806   2      #ifdef SDK_DEBUG
                      //PRINT("ATTRIB_RES <-: ");
                      for (i = 0; i < len; i++)
                      {
                          //PRINT("%02x ", ATTRIB_RES[i]);
                      }
                      //PRINT("\r\n");
              #endif
1814   2      
1815   2              if (len != 1)
1816   2              {
1817   3                  return NFC_ERR_PROTOCOL;
1818   3              }
1819   2      
1820   2      
1821   2              if ((ATTRIB_RES[0] & 0xf) != 0x00)
1822   2              {
1823   3                  return NFC_ERR_PROTOCOL;
1824   3              }
1825   2          }
1826   1          return errno;
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 31  

1827   1      }
1828          
1829          /**
1830            * @brief  HLTB
1831            * @param  None
1832            * @retval Error code
1833            */
1834          unsigned char YC_NFC_Contactless_HLTB(void)
1835          {
1836   1          unsigned char i=0;
1837   1          u16 len=0;
1838   1          unsigned char errno = NFC_ERR_NONE;
1839   1          unsigned char HLTB[5]={0};
1840   1          unsigned char HLTB_RES[FSD]={0};
1841   1      
1842   1          HLTB[0] = 0x50;
1843   1          HLTB[1] = picc_b.PUPI[0];
1844   1          HLTB[2] = picc_b.PUPI[1];
1845   1          HLTB[3] = picc_b.PUPI[2];
1846   1          HLTB[4] = picc_b.PUPI[3];
1847   1      
1848   1      #ifdef SDK_DEBUG
                  //PRINT("HLTB ->: ");
                  for (i = 0; i < 5; i++)
                  {
                      //PRINT("%02x ", HLTB[i]);
                  }
                  //PRINT("\r\n");
              #endif
1856   1      
1857   1          errno = NFC_Transceive(CMD_HLTB, HLTB, 5, 0, HLTB_RES, (u16 *)&len, 0);
1858   1      
1859   1      
1860   1      
1861   1      #ifdef SDK_DEBUG
                  //PRINT("HLTB_RES <-: ");
                  for (i = 0; i < len; i++)
                  {
                      //PRINT("%02x ", HLTB_RES[i]);
                  }
                  //PRINT("\r\n");
              #endif
1869   1      
1870   1          return errno;
1871   1      }
1872          
1873          //static u8 YC_NFC_Poll(void)
1874          //{
1875          //    u8 errno = 0;
1876          //    Poll_Type.Type_A = 0;
1877          //    Poll_Type.Type_B = 0;
1878          
1879          //    while (1)
1880          //    {
1881          
1882          //        if (!Poll_Type.Type_A)
1883          //        {
1884          //            Tp();
1885          //            errno  = YC_NFC_Contactless_WUPA();
1886          
1887          //            if (errno == EOT_SHOUT)
1888          //            {
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 32  

1889          //                return EOT_SHOUT;
1890          //            }
1891          
1892          //            if (errno  == NFC_ERR_NONE)
1893          //            {
1894          //                Poll_Type.Type_A = 1;
1895          
1896          //                YC_NFC_Contactless_HLTA();
1897          //            }
1898          
1899          //            if (!Poll_Type.Type_B)
1900          //            {
1901          //                Tp();
1902          //                errno  = YC_NFC_Contactless_WUPB(NULL);
1903          //                if (errno == EOT_SHOUT)
1904          //                {
1905          //                    return EOT_SHOUT;
1906          //                }
1907          //                if (errno == NFC_ERR_NONE)
1908          //                {
1909          //                    Poll_Type.Type_B = 1;
1910          //                }
1911          //            }
1912          //            else
1913          //            {
1914          //                break;
1915          //            }
1916          //        }
1917          //        else
1918          //        {
1919          //            break;
1920          //        }
1921          
1922          //        if (!(Poll_Type.Type_A || Poll_Type.Type_B))
1923          //        {
1924          //            return NFC_ERR_NO_CARD;
1925          //        }
1926          //    }
1927          
1928          //    return NFC_ERR_NONE;
1929          //}
1930          
1931          /**
1932            * @brief  Type A Collision Detection
1933            *                 Requirements 9.4: Type A Collision Detection
1934            * @param  None
1935            * @retval Error code
1936            */
1937          unsigned char YC_NFC_A_Collision_Detect(void)
1938          {
1939   1          u8 i = 0;
1940   1          u8 cl=0;
1941   1          u8 UID_complete=0;
1942   1          u8 ISOIEC14443_4_compliant=0;
1943   1          u8 retr = 0;
1944   1          u8 errno = NFC_ERR_NONE;
1945   1      
1946   1          Tp();
1947   1      
1948   1          while (1)
1949   1          {
1950   2              errno = YC_NFC_Contactless_WUPA();
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 33  

1951   2              if (errno == EOT_SHOUT)
1952   2              {
1953   3                  return EOT_SHOUT;
1954   3              }
1955   2              if (errno == NFC_ERR_NONE)
1956   2              {
1957   3                  break;
1958   3              }
1959   2      
1960   2              AntiColExceptionProcess();
1961   2          }
1962   1      
1963   1          do
1964   1          {
1965   2              ++i;
1966   2      
1967   2              if (i == 1)
1968   2              {
1969   3                  cl = CL1;
1970   3              }
1971   2              else if (i == 2)
1972   2              {
1973   3                  cl = CL2;
1974   3              }
1975   2              else
1976   2              {
1977   3                  cl = CL3;
1978   3              }
1979   2      
1980   2              retr = 0;
1981   2              while (1)
1982   2              {
1983   3      
1984   3                  errno = YC_NFC_Contactless_ANTICOLLISION(cl);
1985   3                  if (errno == EOT_SHOUT)
1986   3                  {
1987   4                      return EOT_SHOUT;
1988   4                  }
1989   3                  if (errno == NFC_ERR_NONE)
1990   3                  {
1991   4                      break;
1992   4                  }
1993   3      
1994   3                  AntiColExceptionProcess();
1995   3              }
1996   2      
1997   2              retr = 0;
1998   2              while (1)
1999   2              {
2000   3      
2001   3                  errno = YC_NFC_Contactless_SELECT(cl, &UID_complete, &ISOIEC14443_4_compliant);
2002   3                  if (errno == EOT_SHOUT)
2003   3                  {
2004   4                      return EOT_SHOUT;
2005   4                  }
2006   3                  if (errno == NFC_ERR_NONE)
2007   3                  {
2008   4                      break;
2009   4                  }
2010   3      
2011   3                  GeneralExceptionProcess();
2012   3              }
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 34  

2013   2      
2014   2              if (!UID_complete)
2015   2              {
2016   3                  if(!ISOIEC14443_4_compliant)
2017   3              cardtype = TYPEA_M1;
2018   3            else
2019   3              cardtype = TYPE_A;
2020   3            
2021   3            break;
2022   3              }
2023   2      
2024   2              if (i == 3)
2025   2              {
2026   3                  return NFC_ERR_PROTOCOL;
2027   3              }
2028   2      
2029   2          }
2030   1          while (i < 3);
2031   1      
2032   1          return errno;
2033   1      }
2034          /**
2035            * @brief  Type B Collision Detection
2036            *                     Requirements 9.5: Type B Collision Detection
2037            * @param  None
2038            * @retval Error code
2039            */
2040          unsigned char YC_NFC_B_Collision_Detect(void)
2041          {
2042   1          u8 retr = 0;
2043   1          u8 ISOIEC14443_4_compliant = 0;
2044   1          u8 errno = NFC_ERR_NONE;
2045   1      
2046   1          Tp();
2047   1      
2048   1          while (1)
2049   1          {
2050   2      
2051   2              errno = YC_NFC_Contactless_WUPB(&ISOIEC14443_4_compliant);
2052   2              if (errno == EOT_SHOUT)
2053   2              {
2054   3                  return EOT_SHOUT;
2055   3              }
2056   2              if (errno == NFC_ERR_NONE)
2057   2              {
2058   3                  if (!ISOIEC14443_4_compliant)
2059   3                  {
2060   4                      cardtype = TYPEB_IDENTITY;
2061   4                      return NFC_IDENTITY_CARD;
2062   4                  }
2063   3                  else
2064   3            {
2065   4              cardtype = TYPE_B;
2066   4            }
2067   3      
2068   3                  break;
2069   3              }
2070   2      
2071   2              AntiColExceptionProcess();
2072   2          }
2073   1      
2074   1          return errno;
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 35  

2075   1      }
2076          
2077          /**
2078            * @brief  General Collision Detection
2079            *                 Requirements 9.3: Collision Detection
2080            * @param  None
2081            * @retval Error code
2082            */
2083          //static u8 YC_NFC_Collision_General_Detect(void)
2084          //{
2085          //    u8 errno = NFC_ERR_NONE;
2086          
2087          //    if (Poll_Type.Type_A && Poll_Type.Type_B)
2088          //    {
2089          //        return NFC_ERR_COLLISION;
2090          //    }
2091          //    else if (Poll_Type.Type_A)
2092          //    {
2093          //        errno = YC_NFC_A_Collision_Detect();
2094          //    }
2095          //    else if (Poll_Type.Type_B)
2096          //    {
2097          //        errno = YC_NFC_B_Collision_Detect();
2098          //    }
2099          
2100          //    return errno;
2101          //}
2102          
2103          /**
2104            * @brief  PICC activation
2105            * @param  None
2106            * @retval error code
2107            */
2108          //static u8 YC_NFC_Active(void)
2109          //{
2110          //    u8 retr = 0;
2111          //    u8 errno = NFC_ERR_NONE;
2112          
2113          //    errno = YC_NFC_Poll();
2114          //    
2115          //    if (errno == EOT_SHOUT)
2116          //    {
2117          //        return EOT_SHOUT;
2118          //    }
2119          
2120          //    if (errno != NFC_ERR_NONE)
2121          //    {
2122          //        return NFC_ERR_NO_CARD;
2123          //    }
2124          
2125          //    errno = YC_NFC_Collision_General_Detect();
2126          //    if(errno == EOT_SHOUT)
2127          //    {
2128          //        return EOT_SHOUT;
2129          //    }
2130          
2131          //    if (errno == NFC_ERR_NONE)
2132          //    {
2133          //        if (Poll_Type.Type_A)
2134          //        {
2135          //            while (1)
2136          //            {
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 36  

2137          
2138          //                errno = YC_NFC_Contactless_RATS();
2139          //                if (errno == EOT_SHOUT)
2140          //                {
2141          //                    return EOT_SHOUT;
2142          //                }
2143          //                if (errno == NFC_ERR_NONE)
2144          //                {
2145          //                    break;
2146          //                }
2147          
2148          //                GeneralExceptionProcess();
2149          //            }
2150          //        }
2151          //        else if (Poll_Type.Type_B)
2152          //        {
2153          //            while (1)
2154          //            {
2155          
2156          //                errno = YC_NFC_Contactless_ATTRIB();
2157          //                if (errno == EOT_SHOUT)
2158          //                {
2159          //                    return EOT_SHOUT;
2160          //                }
2161          //                if (errno == NFC_ERR_NONE)
2162          //                {
2163          //                    break;
2164          //                }
2165          
2166          //                GeneralExceptionProcess();
2167          //            }
2168          //        }
2169          //    }
2170          
2171          //    return errno;
2172          //}
2173          
2174          /**
2175            * @brief  Remove PICC
2176            * @param  None
2177            * @retval error code
2178            */
2179          //static u8 YC_NFC_PICC_Remove(void)
2180          //{
2181          //    if (Poll_Type.Type_A)
2182          //    {
2183          //        YC_NFC_Contactless_Switch_Card_Type(TYPE_A);
2184          
2185          //        Tp();
2186          
2187          //        while (YC_NFC_Contactless_WUPA() == NFC_ERR_NONE)
2188          //        {
2189          //removea:
2190          //            YC_NFC_Contactless_HLTA();
2191          
2192          //            Tp();
2193          //        }
2194          
2195          //        Tretransmission();
2196          
2197          //        if (YC_NFC_Contactless_WUPA() == NFC_ERR_NONE)
2198          //        {
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 37  

2199          //            goto removea;
2200          //        }
2201          
2202          //        Tretransmission();
2203          
2204          //        if (YC_NFC_Contactless_WUPA() == NFC_ERR_NONE)
2205          //        {
2206          //            goto removea;
2207          //        }
2208          
2209          //        return NFC_ERR_TIME_OUT;
2210          //    }
2211          //    else if (Poll_Type.Type_B)
2212          //    {
2213          //        YC_NFC_Contactless_Switch_Card_Type(TYPE_B);
2214          
2215          //        Tp();
2216          
2217          //        while (YC_NFC_Contactless_WUPB(NULL) == NFC_ERR_NONE)
2218          //        {
2219          //removeb:
2220          //            Tp();
2221          //        }
2222          
2223          //        Tretransmission();
2224          
2225          //        if (YC_NFC_Contactless_WUPB(NULL) == NFC_ERR_NONE)
2226          //        {
2227          //            goto removeb;
2228          //        }
2229          
2230          //        Tretransmission();
2231          
2232          //        if (YC_NFC_Contactless_WUPB(NULL) == NFC_ERR_NONE)
2233          //        {
2234          //            goto removeb;
2235          //        }
2236          
2237          //        return NFC_ERR_TIME_OUT;
2238          //    }
2239          //    else
2240          //    {
2241          //        return NFC_ERR_NO_CARD;
2242          //    }
2243          //}
2244          
2245          
2246          
2247          //static u8 NFC_LoopBack(void)
2248          //{
2249          //    u16 i=0;
2250          //    u8 errno = NFC_ERR_NONE;
2251          //    u8 res[FSD]={0};
2252          //    u16 reslen=0;
2253          
2254          //    code u8 APDU_PPSE[] = {0x00, 0xA4, 0x04, 0x00, 0x0E,
2255          //                                 0x32, 0x50, 0x41, 0x59, 0x2E, 0x53, 0x59, 0x53, 0x2E, 0x44, 0x44, 0x46,
             - 0x30, 0x31,
2256          //                                 0x00
2257          //                                };
2258          
2259          //#ifdef SDK_DEBUG
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 38  

2260          //    //PRINT("C-APDU ->: ");
2261          //    for (i = 0; i < sizeof(APDU_PPSE); i++)
2262          //    {
2263          //        //PRINT("%02x ", APDU_PPSE[i]);
2264          //    }
2265          //    //PRINT("\n");
2266          //#endif
2267          //    errno = YC_NFC_Contactless_APDU_Transceive(APDU_PPSE, sizeof(APDU_PPSE), res, &reslen);
2268          
2269          
2270          //    if (errno != NFC_ERR_NONE)
2271          //    {
2272          //        return errno;
2273          //    }
2274          
2275          
2276          //#ifdef SDK_DEBUG
2277          //    //PRINT("R-APDU <-: ");
2278          //    for (i = 0; i < reslen; i++)
2279          //    {
2280          //        //PRINT("%02x ", res[i]);
2281          //    }
2282          //    //PRINT("\n");
2283          //#endif
2284          
2285          //    while (1)
2286          //    {
2287          //        if (res[1] == 0x70)
2288          //        {
2289          //            return EOT_IND_REMOVE;
2290          //        }
2291          
2292          //        if (res[1] == 0x72)
2293          //        {
2294          //            return EOT_IND_POWER_OFF;
2295          //        }
2296          
2297          
2298          //#ifdef SDK_DEBUG
2299          //        //PRINT("C-APDU ->: ");
2300          //        for (i = 0; i < reslen - 2; i++)
2301          //        {
2302          //            //PRINT("%02x ", res[i]);
2303          //        }
2304          //        //PRINT("\n");
2305          //#endif
2306          
2307          //        errno = YC_NFC_Contactless_APDU_Transceive(res, reslen - 2, res, &reslen);
2308          
2309          //        if (errno != NFC_ERR_NONE)
2310          //        {
2311          //            return errno;
2312          //        }
2313          
2314          
2315          //#ifdef SDK_DEBUG
2316          //        //PRINT("R-APDU <-: ");
2317          //        for (i = 0; i < reslen; i++)
2318          //        {
2319          //            //PRINT("%02x ", res[i]);
2320          //        }
2321          //        //PRINT("\n");
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 39  

2322          //#endif
2323          //    }
2324          //}
2325          static void YC_NFC_Field_Reset(void)
2326          {
2327   1          YC_NFC_Contactless_Rf_Switch(OFF);
2328   1          Tp();
2329   1          YC_NFC_Contactless_Rf_Switch(ON);
2330   1      }
2331          
2332          //static void YC_NFC_Field_Power_Off(void)
2333          //{
2334          //    YC_NFC_Contactless_L1_Rf_Switch(OFF);
2335          //    Tpoweroff();
2336          //    YC_NFC_Contactless_L1_Rf_Switch(ON);
2337          //}
2338          
2339          /**
2340            * @brief  Enter low power mode
2341            * @param  None
2342            * @retval None
2343            */
2344          void YC_NFC_Contactless_Sleep(void)
2345          {
2346   1        CLEARBITMASK(REG_TX_PA_GAIN_CTRL,0x20);
2347   1        CLEARBITMASK(REG_TX_PA_GAIN_CTRL,0x10);
2348   1        Soft_Delay1ms(20);
2349   1          CLEARBITMASK(REG_TOP_CTRL, BIT0);
2350   1          SETBITMASK(REG_TOP_CTRL, BIT2);
2351   1      }
2352          
2353          /**
2354            * @brief  Exit low power mode
2355            * @param  None
2356            * @retval None
2357            */
2358          void YC_NFC_Contactless_Wake(void)
2359          {
2360   1          CLEARBITMASK(REG_TOP_CTRL, BIT2);
2361   1          SETBITMASK(REG_TOP_CTRL, BIT0);
2362   1      }
2363          
2364          //uint8_t GetIdcardNum(uint8_t *pid)
2365          //{
2366          //  uint8_t  errno;
2367          //  uint8_t i=0;
2368          
2369          //  uint8_t  sendbuf[5];
2370          //  uint8_t recvbuf[10];
2371          //  uint16_t recvlen;
2372          
2373          //  sendbuf[0] =0x00; //ISO14443B_ANTICOLLISION;             // APf code
2374          //  sendbuf[1] =0x36;// AFI;                // 
2375          //  sendbuf[2] =0x00; //((req_code<<3)&0x08) | (N&0x07);  // PARAM
2376          //  sendbuf[3] =0x00;
2377          //  sendbuf[4] =0x08;
2378          
2379          //  errno = NFC_Transceive(CMD_RATS, sendbuf, 5, 0, recvbuf, &recvlen, 0);
2380          //  if (errno == 0) 
2381          //  { 
2382          //    for (i=0;i<recvlen;i++)
2383          //    {
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 40  

2384          //      *pid++ = recvbuf[i];
2385          //    }
2386          //  } 
2387          //  return errno;
2388          //} 
2389          
2390          status_t YC_NFC_M_Code(uint8_t *Point)
2391          { 
2392   1        u8 Recv_Test[30] = {0};
2393   1        u8 Val_Test[16] = {0x44, 0x00, 0x00, 0x00 , 0xbb , 0xff , 0xff , 0xff , 0x44 , 0x00 , 0x00 , 0x00 , 0x02 
             -, 0xfd , 0x02 , 0xfd};
2394   1        u8 add_val[6] = {1,0,0,0,0,0};
2395   1        //u16 Recv_Len;
2396   1        u32 ret_m0 = 0;
2397   1        u32 ret_m1 = 0;
2398   1        u8 block_num_mi=0;
2399   1        u8 key_index = 0;
2400   1        u8 muid[5];
2401   1        u8 mkey[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff,};
2402   1        u8 recv_data[30]={0};
2403   1        u8 errno = 0;
2404   1        u16 recv_len= 0;
2405   1        u8 i = 0;
2406   1      
2407   1        #if 0
                //ntag215 demo
              //  u8 Send_Cmd_2[30];
              //  u8 Send_Cmd_len;
              //  ret_m0 = Mifare0_Read(0,Recv_Test, &Recv_Len);
              //  ret_m0 = Mifare0_Read(1,Recv_Test, &Recv_Len);
              //  ret_m0 = Mifare0_Read(2,Recv_Test, &Recv_Len);
              
              //  Send_Cmd_2[0] = 0xaa;
              //  Send_Cmd_2[1] = 0x55;
              //  Send_Cmd_2[2] = 0xaa;
              //  Send_Cmd_2[3] = 0x55;
              //  Send_Cmd_len = 4;
              //  ret_m0 = Mifare0_Write(6, Send_Cmd_2, Send_Cmd_len);
              //  ret_m0 = Mifare0_Read (6, Recv_Test, &Recv_Len);
              
              //  Send_Cmd_2[0] = 0xff;
              //  Send_Cmd_2[1] = 0x00;
              //  Send_Cmd_2[2] = 0xff;
              //  Send_Cmd_2[3] = 0x00;
              //  Send_Cmd_2[4] = 0xff;
              //  Send_Cmd_2[5] = 0x00;
              //  Send_Cmd_2[6] = 0xaa;
              //  Send_Cmd_2[7] = 0x55;
              //  Send_Cmd_2[8] = 0xaa;
              //  Send_Cmd_2[9] = 0x55;
              //  Send_Cmd_2[10] = 0xff;
              //  Send_Cmd_2[11] = 0x55;
              //  Send_Cmd_2[12] = 0xaa;
              //  Send_Cmd_2[13] = 0x55;
              //  Send_Cmd_2[14] = 0xff;
              //  Send_Cmd_2[15] = 0x55;
              //  Send_Cmd_len = 16;
              //  ret_m0 = Mifare0_Compatibility_Write(6, Send_Cmd_2, Send_Cmd_len);
              //  ret_m0 = Mifare0_Read(6,Recv_Test, &Recv_Len);
                
              
                #else  //m1
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 41  

2445   1        block_num_mi = 0;
2446   1        key_index = 1;
2447   1        Get_Mifare_uid(muid);
2448   1        errno = Mifare_Auth_Fun(mkey, key_index, muid, block_num_mi);
2449   1      
2450   1        if (errno ==M1_ERR_NONE)
2451   1        {
2452   2          Mif_read(block_num_mi, recv_data, &recv_len);
2453   2          //PRINT("M1 UID ->: ");
2454   2          for (i=0;i<4;i++)
2455   2          {
2456   3            *Point = recv_data[i];
2457   3            Point++;
2458   3          }
2459   2          return S_SUCCESS;
2460   2        } 
2461   1        return S_FAIL;
2462   1      //  Mifare_Auth_Fun(mkey,0,muid,3);
2463   1      //  
2464   1      //  ret_m1 = Mifare_Auth_Fun(mkey,1,muid,2);
2465   1      //  ret_m1 = Mifare_Auth_Fun(mkey,0,muid,2);
2466   1      //  ret_m1 = Mif_write(1,Recv_Test,16);
2467   1      //  ret_m1 = Mif_write(2,Recv_Test,16);
2468   1      //  ret_m1 = Mif_write(2,Val_Test,16);
2469   1      //  ret_m1 = Mif_read(1,Recv_Test,&Recv_Len);
2470   1      //  ret_m1 = Mif_read(2,Recv_Test,&Recv_Len);
2471   1        
2472   1      //  Mif_read(2,Recv_Test,&Recv_Len);
2473   1      //  Mif_increment(2,add_val);
2474   1      //  Mif_Transfer(2);
2475   1      //  Mif_read(2,Recv_Test,&Recv_Len);
2476   1      //  Mif_increment(2,add_val);
2477   1      //  Mif_Transfer(2);
2478   1      //  Mif_read(2,Recv_Test,&Recv_Len);
2479   1      //  Mif_decrement(2,add_val);
2480   1      //  Mif_Transfer(2);
2481   1      //  Mif_read(2,Recv_Test,&Recv_Len);
2482   1      //  Mif_decrement(2,add_val);
2483   1      //  Mif_Transfer(2);
2484   1      //  Mif_read(2,Recv_Test,&Recv_Len);
2485   1      
2486   1        #endif    
2487   1      }
2488          
2489          void set_dc_win(u8 win)
2490          {
2491   1          u8 tmp=0;
2492   1          tmp = READREG(REG_RSSI_CALC_CONFIG);
2493   1          WRITEREG(REG_RSSI_CALC_CONFIG, ((tmp & 0xFC) | win));
2494   1      }
2495          
2496          void set_rssi_calc_en(u8 en)
2497          {
2498   1          u8 tmp=0;
2499   1          tmp = READREG(REG_RSSI_CALC_CTRL);
2500   1          tmp = tmp & 0xfd;
2501   1          tmp = tmp | ((en & 0x01) << 1);
2502   1          WRITEREG(REG_RSSI_CALC_CTRL, tmp);
2503   1      }
2504          
2505          void force_dc_calc(void)
2506          {
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 42  

2507   1          u8 tmp=0;
2508   1          tmp = READREG(REG_RSSI_CALC_CTRL);
2509   1          WRITEREG(REG_RSSI_CALC_CTRL, (tmp & 0xFE));
2510   1          WRITEREG(REG_RSSI_CALC_CTRL, (tmp | 0x01));
2511   1          Soft_Delay1ms(1);
2512   1          WRITEREG(REG_RSSI_CALC_CTRL, (tmp & 0xFE));
2513   1          Soft_Delay1ms(2);
2514   1      }
2515          u8 dc_cali_i(void)
2516          {
2517   1          u8 cali = 0, dc = 0, cnt = 0;
2518   1        set_cali_i(0x00);
2519   1          while (1)
2520   1          {
2521   2              cnt ++;
2522   2              force_dc_calc();
2523   2              dc = get_dc_i();
2524   2              cali = get_cali_i();
2525   2              if (cnt == 0xff)
2526   2              {
2527   3                  return CALI_FAIL;
2528   3              }
2529   2      
2530   2              if ((dc <= DC_ACCEPT_RANGE) || (dc >= (256 - DC_ACCEPT_RANGE)))
2531   2              {
2532   3                  return CALI_OK;
2533   3              }
2534   2      
2535   2              if ((dc & 0x80) == 0)
2536   2              {
2537   3                  if ((cali & 0x80) == 0)
2538   3                  {
2539   4                      if (cali == 0)
2540   4                      {
2541   5                          cali = 0x80;
2542   5                      }
2543   4                      else
2544   4                      {
2545   5                          cali = cali - 1;
2546   5                      }
2547   4      
2548   4                  }
2549   3                  else
2550   3                  {
2551   4                      if (cali == 0xff)
2552   4                      {
2553   5                          cali = cali;
2554   5                      }
2555   4                      else
2556   4                      {
2557   5                          cali = cali + 1;
2558   5                      }
2559   4                  }
2560   3      
2561   3              }
2562   2              else
2563   2              {
2564   3                  if ((cali & 0x80) == 0)
2565   3                  {
2566   4                      if (cali == 0x7f)
2567   4                      {
2568   5                          cali = 0x7f;
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 43  

2569   5                      }
2570   4                      else
2571   4                      {
2572   5                          cali = cali + 1;
2573   5                      }
2574   4                  }
2575   3                  else
2576   3                  {
2577   4                      if (cali == 0x80)
2578   4                      {
2579   5                          cali = 0x00;
2580   5                      }
2581   4                      else
2582   4                      {
2583   5                          cali = cali - 1;
2584   5                      }
2585   4                  }
2586   3              }
2587   2      
2588   2              set_cali_i(cali);
2589   2      
2590   2          }
2591   1      }
2592          u8 dc_cali_q(void)
2593          {
2594   1          u8 cali = 0, dc = 0, cnt = 0;
2595   1        set_cali_q(0x00);
2596   1          while (1)
2597   1          {
2598   2              cnt ++;
2599   2              force_dc_calc();
2600   2              dc = get_dc_q();
2601   2      
2602   2              cali = get_cali_q();
2603   2      
2604   2              if (cnt == 0xff)
2605   2              {
2606   3                  return CALI_FAIL;
2607   3              }
2608   2      
2609   2              if ((dc <= DC_ACCEPT_RANGE) || (dc >= (256 - DC_ACCEPT_RANGE)))
2610   2              {
2611   3                  return CALI_OK;
2612   3              }
2613   2              if ((dc & 0x80) == 0)
2614   2              {
2615   3                  if ((cali & 0x80) == 0)
2616   3                  {
2617   4                      if (cali == 0)
2618   4                      {
2619   5                          cali = 0x80;
2620   5                      }
2621   4                      else
2622   4                      {
2623   5                          cali = cali - 1;
2624   5                      }
2625   4                  }
2626   3                  else
2627   3                  {
2628   4                      if (cali == 0xff)
2629   4                      {
2630   5                          cali = cali;
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 44  

2631   5                      }
2632   4                      else
2633   4                      {
2634   5                          cali = cali + 1;
2635   5                      }
2636   4                  }
2637   3              }
2638   2              else
2639   2              {
2640   3                  if ((cali & 0x80) == 0)
2641   3                  {
2642   4                      if (cali == 0x7f)
2643   4                      {
2644   5                          cali = 0x7f;
2645   5                      }
2646   4                      else
2647   4                      {
2648   5                          cali = cali + 1;
2649   5                      }
2650   4                  }
2651   3                  else
2652   3                  {
2653   4                      if (cali == 0x80)
2654   4                      {
2655   5                          cali = 0x00;
2656   5                      }
2657   4                      else
2658   4                      {
2659   5                          cali = cali - 1;
2660   5                      }
2661   4                  }
2662   3              }
2663   2              set_cali_q(cali);
2664   2      
2665   2          }
2666   1      
2667   1      }
2668          
2669          void DC_cali_alg(u8 win_size)
2670          {
2671   1          WRITEREG(REG_DA_RX_FLT_GRCK_EN, 0x00);
2672   1          WRITEREG(REG_DA_TX_PA_EN, 0x00);
2673   1          set_dc_win(win_size);
2674   1      
2675   1          WRITEREG(REG_TOP_CTRL, 0x11);
2676   1          set_rssi_calc_en(1);
2677   1      
2678   1          WRITEREG(REG_ADC_CTRL, 0x08);
2679   1      
2680   1          WRITEREG(REG_RX_CTRL3, RX_CTRL3);
2681   1          WRITEREG(REG_RX_CTRL4, RX_CTRL4);
2682   1          WRITEREG(REG_RX_CTRL5, RX_CTRL5);
2683   1        Set_Receive_Parameters(RX_GAIN_6DB, RX_I_R_1K);
2684   1      
2685   1          if (CALI_OK == dc_cali_i())
2686   1          {
2687   2              gain_i_q_table[0][1] = get_cali_i();
2688   2          }
2689   1          else
2690   1          {
2691   2              gain_i_q_table[0][1] = 0;
2692   2          }
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 45  

2693   1          if (CALI_OK == dc_cali_q())
2694   1          {
2695   2              gain_i_q_table[0][2] = get_cali_q();
2696   2          }
2697   1          else
2698   1          {
2699   2              gain_i_q_table[0][2] = 0;
2700   2          }
2701   1          Set_Receive_Parameters(RX_GAIN_18DB, RX_I_R_500);
2702   1      
2703   1          if (CALI_OK == dc_cali_i())
2704   1          {
2705   2              gain_i_q_table[2][1] = get_cali_i();
2706   2          }
2707   1          else
2708   1          {
2709   2              gain_i_q_table[2][1] = 0;
2710   2          }
2711   1          if (CALI_OK == dc_cali_q())
2712   1          {
2713   2              gain_i_q_table[2][2] = get_cali_q();
2714   2          }
2715   1          else
2716   1          {
2717   2              gain_i_q_table[2][2] = 0;
2718   2          }
2719   1      }
2720          
2721          /************************************Parameter Adjustment Function**************************************/
2722          void Set_Carrier_Strength(unsigned char PaGain)
2723          {
2724   1          WRITEREG(REG_TX_PA_GAIN, PaGain);
2725   1      }
2726          void Set_Receive_Parameters(unsigned char RxGain, unsigned char RfAtt)
2727          {
2728   1          u8 val = 0;
2729   1          u8 i = 0;
2730   1      
2731   1          val = RxGain | RfAtt;
2732   1          WRITEREG(REG_RX_CTRL0, val);
2733   1          switch (RxGain)
2734   1          {
2735   2          case    RX_GAIN_6DB:
2736   2              i = 0;
2737   2              break;
2738   2          case    RX_GAIN_12DB:
2739   2              i = 1;
2740   2              break;
2741   2          case    RX_GAIN_18DB:
2742   2              i = 2;
2743   2              break;
2744   2          case    RX_GAIN_24DB:
2745   2              i = 3;
2746   2              break;
2747   2          case    RX_GAIN_30DB:
2748   2              i = 4;
2749   2              break;
2750   2          case    RX_GAIN_36DB:
2751   2              i = 5;
2752   2              break;
2753   2          case    RX_GAIN_42DB:
2754   2              i = 6;
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 46  

2755   2              break;
2756   2          case    RX_GAIN_48DB:
2757   2              i = 7;
2758   2              break;
2759   2          case    RX_GAIN_54DB:
2760   2              i = 8;
2761   2              break;
2762   2          default:
2763   2              i = 0;
2764   2              break;
2765   2          }
2766   1          WRITEREG(REG_RX_CTRL1, gain_i_q_table[i][1]);
2767   1          WRITEREG(REG_RX_CTRL2, gain_i_q_table[i][2]);
2768   1      }
2769          
2770          void Set_Min_Level(u16 MinLevel)
2771          {
2772   1          WRITEREG(REG_MIN_LEVEL_LOW, MinLevel & 0xFF);
2773   1          WRITEREG(REG_MIN_LEVEL_HIGH, MinLevel >> 8);
2774   1      }
2775          void YC_NFC_Contactless_InitRSSI( void)
2776          {
2777   1        SETBITMASK(REG_TOP_CTRL, 0x10);
2778   1        WRITEREG(REG_RX_CTRL3, 0x3D);
2779   1        SETBITMASK(REG_RX_CTRL4,0x01);
2780   1        WRITEREG(REG_RX_CTRL5, 0x7C);
2781   1        SETBITMASK(REG_RSSI_CALC_CONFIG, 0x04);
2782   1        SETBITMASK(REG_RSSI_CALC_CTRL, 0x02);
2783   1      
2784   1      }
2785          
2786          
2787          u8 RSSI_maxi=0,RSSI_maxq=0;
2788          u8 Aset_read_power_index(void)
2789          {
2790   1        u8 tmp=0;
2791   1        WRITEREG(REG_RSSI_CALC_CTRL, 0x02);
2792   1        WRITEREG(REG_RSSI_CALC_CTRL, 0x03);
2793   1        Soft_Delay_us(100);
2794   1        tmp = READREG(REG_AVG_POW);
2795   1        RSSI_maxi =READREG(REG_AVG_I);
2796   1        RSSI_maxq =READREG(REG_AVG_Q);
2797   1        WRITEREG(REG_RSSI_CALC_CTRL, 0x00);
2798   1        
2799   1        
2800   1        return tmp;
2801   1        
2802   1      
2803   1      }
2804          signed char positive_numi=0,positive_numq=0 ;
2805          signed char negative_numi=0 ,negative_numq=0 ;
2806          unsigned char  Aset_read_power_xRSSI(void) 
2807          {
2808   1      
2809   1        unsigned char tmp=0,tmp_avgi = 0,tmp_avgq=0;
2810   1        set_dc_win(WIN_SIZE_128);
2811   1      
2812   1        WRITEREG(REG_TX_PA_GAIN, PA_GAIN_VAL);
2813   1        
2814   1        YC_NFC_Contactless_Rf_Switch(ON);
2815   1        Set_Receive_Parameters(RX_GAIN_6DB,RX_I_R_1K);        //è®¾ç½®æŽ¥æ”¶å¢žç›ŠåŠå†…éƒ¨ç”µé˜»
2816   1      
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 47  

2817   1      
2818   1        WRITEREG(REG_ADC_CTRL, 0x08);
2819   1        WRITEREG(REG_XTAL_CTRL4, 0x07);
2820   1        
2821   1        WRITEREG(REG_RSSI_CALC_CTRL, 0x02);
2822   1        WRITEREG(REG_RSSI_CALC_CTRL, 0x03);
2823   1        Soft_Delay_us(100);
2824   1        
2825   1        tmp = READREG(REG_AVG_POW); 
2826   1        tmp_avgi = READREG(REG_AVG_I);
2827   1        tmp_avgq = READREG(REG_AVG_Q);
2828   1      
2829   1        if((tmp_avgi & 0x80) | (tmp_avgq & 0x80) )
2830   1        {
2831   2          negative_numi = tmp_avgi;
2832   2          negative_numq = tmp_avgq;
2833   2          
2834   2          return 11;
2835   2        
2836   2        }
2837   1        else
2838   1        {
2839   2          positive_numi = tmp_avgi;
2840   2          positive_numq = tmp_avgq;
2841   2          WRITEREG(REG_ADC_CTRL, 0x00);
2842   2          WRITEREG(REG_XTAL_CTRL4, 0x06);
2843   2          WRITEREG(REG_RSSI_CALC_CTRL, 0x02);
2844   2      
2845   2          return 0;
2846   2        
2847   2        }
2848   1      }
2849          
2850          unsigned char  Aset_read_power_xRSSI_RXVPP(void) 
2851          {
2852   1          unsigned char i=0,j=0,time=0;
2853   1      
2854   1        
2855   1        YC_NFC_Contactless_InitRSSI();
2856   1        YC_NFC_Contactless_Rf_Switch(ON);
2857   1        
2858   1        Soft_Delay1ms(30);
2859   1        while(0x0b == Aset_read_power_xRSSI())
2860   1        {
2861   2          time++;
2862   2          YC_NFC_Contactless_Rf_Switch(OFF);
2863   2          Soft_Delay1ms(30);
2864   2          YC_NFC_Contactless_Rf_Switch(ON);
2865   2          if(time >0x0f)
2866   2          {
2867   3            break;
2868   3          }
2869   2        }
2870   1        set_dc_win(WIN_SIZE_256);
2871   1      
2872   1        WRITEREG(REG_TX_PA_GAIN, 0);
2873   1        
2874   1        YC_NFC_Contactless_Rf_Switch(ON);
2875   1        Set_Receive_Parameters(RX_GAIN_6DB,RX_I_R_500);        //è®¾ç½®æŽ¥æ”¶å¢žç›ŠåŠå†…éƒ¨ç”µé˜»
2876   1      
2877   1        WRITEREG(REG_ADC_CTRL, 0x08);
2878   1        WRITEREG(REG_XTAL_CTRL4, 0x07);
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 48  

2879   1        Soft_Delay_us(100);
2880   1      
2881   1        
2882   1        for(j = 0;j<=PA_GAIN_VAL;j++)
2883   1        {
2884   2          WRITEREG(REG_TX_PA_GAIN, j);
2885   2          i = Aset_read_power_index();
2886   2          //PRINT("pa = 0x%02x, rssi = 0x%02x \r\n",j,i);
2887   2          
2888   2        }
2889   1        WRITEREG(REG_ADC_CTRL, 0x00);
2890   1        WRITEREG(REG_XTAL_CTRL4, 0x06);
2891   1        WRITEREG(REG_RSSI_CALC_CTRL, 0x02);
2892   1      
2893   1        return i;
2894   1      }
2895          
2896          void MFC_Init(void)
2897          {
2898   1        YC_NFC_HwReset();
2899   1        DC_cali_alg(3);
2900   1        YC_NFC_HwReset();
2901   1        Soft_Delay1ms(10);
2902   1        /*Contactless Init*/
2903   1        YC_NFC_Contactless_Init();
2904   1        /*Open Rf*/
2905   1        YC_NFC_Contactless_Rf_Switch(ON);
2906   1        NFC_TIM_FLAG = 1;
2907   1      }
2908          
2909          void MFC_POWERDOWN(void)
2910          {
2911   1        SET_MFC_RST_L;
2912   1        Soft_Delay1ms(1);
2913   1        /*Close Rf*/
2914   1        //YC_NFC_Contactless_L1_Rf_Switch(OFF);
2915   1      }
2916          
2917          void MFC_WAKEUP(void)
2918          { 
2919   1        SET_MFC_RST_H;
2920   1        Soft_Delay1ms(1);
2921   1      }
2922          
2923          u8 Resart= 0;
2924          
2925          status_t MFC_Auto_Reader(uint8_t *Point)
2926          { 
2927   1        u8 errno = NFC_ERR_NONE;
2928   1        u8 i=0;
2929   1        YC_NFC_Contactless_Rf_Switch(ON);
2930   1        Tp();
2931   1        if(Resart == 1)
2932   1        {
2933   2          YC_NFC_HwReset();
2934   2      
2935   2          Soft_Delay1ms(100);
2936   2          CLRWDT();
2937   2      //    Soft_Delay1ms(200);
2938   2      //    CLRWDT();
2939   2      //    Soft_Delay1ms(200);
2940   2      //    CLRWDT();
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 49  

2941   2          
2942   2          YC_NFC_Contactless_Init();
2943   2          YC_NFC_Contactless_Rf_Switch(ON);
2944   2          Resart = 0;
2945   2        }
2946   1        
2947   1        errno = YC_NFC_Active_card();
2948   1        CLRWDT();
2949   1        if(errno == EOT_SHOUT)
2950   1        {
2951   2          Resart = 1;   
2952   2        }
2953   1        if(errno == NFC_ERR_NONE)
2954   1        {
2955   2          if( cardtype != TYPEA_M1 )
2956   2          {
2957   3            if(errno == NFC_ERR_NONE)
2958   3            {
2959   4              errno = YC_NFC_Apdu_Transmission_Test();
2960   4              if(errno == EOT_SHOUT)
2961   4              {
2962   5                Resart = 1;   
2963   5              }
2964   4              YC_NFC_Field_Reset();
2965   4            }
2966   3          }
2967   2          else if(cardtype == TYPEA_M1)  //M1
2968   2          {                       
2969   3            if( Get_Mifare_uid(NFC_UID) == NFC_ERR_NONE )
2970   3            {
2971   4              YC_NFC_Contactless_Rf_Switch(OFF);
2972   4              for (i=0;i<4;i++)
2973   4              {
2974   5                *Point = NFC_UID[i];
2975   5                Point++;
2976   5              }
2977   4              cardtype = 0;
2978   4              return S_SUCCESS;
2979   4            }
2980   3            cardtype = 0;
2981   3          }
2982   2        }
2983   1        YC_NFC_Contactless_Rf_Switch(OFF);
2984   1        return S_FAIL;
2985   1        
2986   1      //  if(errno == NFC_ERR_NONE)
2987   1      //  {
2988   1      //    errno = NFC_LoopBack();
2989   1      //    if(errno == EOT_IND_REMOVE)
2990   1      //    {
2991   1      //      YC_NFC_Field_Reset();
2992   1      //  
2993   1      //      YC_NFC_PICC_Remove();
2994   1      //    }
2995   1      //    else 
2996   1      //    {
2997   1      //      YC_NFC_Field_Reset();
2998   1      //    }
2999   1      //  }
3000   1      //  else
3001   1      //  {
3002   1      //    Tresetdelay();
C51 COMPILER V9.60.0.0   YC_NFC_CONTACTLESS_L1                                             04/19/2023 13:57:33 PAGE 50  

3003   1      
3004   1      //    YC_NFC_Field_Reset();
3005   1      //  }
3006   1      }
3007          
3008          #endif
3009          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8274    ----
   CONSTANT SIZE    =   2732    ----
   XDATA SIZE       =     74    3120
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

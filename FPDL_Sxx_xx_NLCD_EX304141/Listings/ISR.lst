C51 COMPILER V9.60.0.0   ISR                                                               04/19/2023 13:57:31 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE ISR
OBJECT MODULE PLACED IN .\Objects\ISR.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Softwares\ModuleLogic\ISR.c LARGE OMF2 OPTIMIZE(9,SPEED) BROWSE INCDIR(.
                    -\Drivers\Lib\c;.\Drivers\Lib\H;.\Drivers\Lib\IAP_Lib;.\Drivers\Lib\TouchKey_lib;.\Drivers\Physical;.\Drivers\Protocol;.\
                    -Softwares\Application;.\Softwares\Basic;.\Softwares\ModuleLogic;.\Drivers\Protocol\YC_NFC;.\Drivers\Protocol\WIFI_Tuya) 
                    -DEBUG PRINT(.\Listings\ISR.lst) TABS(2) OBJECT(.\Objects\ISR.obj)

line level    source

   1          /* 头文件包含 INCLUDES */
   2          #include "Project.h"
   3          #include "IO.h"
   4          #include "global_variable.h"
   5          #include "BeepMgr.h"
   6          #include "usart.h"
   7          
   8          uint16_t TimeCunt1024Hz=0;
   9          uint8_t UART1_RXBUFFER[2];
  10          uint8_t UART2_RXBUFFER[2];
  11          
  12          void SysTick_ISR(void)
  13          {
  14   1          G_tflagbits.T1024Hz =1;
  15   1          TimeCunt1024Hz++;
  16   1      
  17   1          //SET_DEBUG_TX_TOGGLE;
  18   1        
  19   1          if ( TimeCunt1024Hz%4==0 )
  20   1          {
  21   2            G_tflagbits.T256Hz =1;
  22   2            
  23   2            if ( TimeCunt1024Hz%8 ==0 )
  24   2            {
  25   3              G_tflagbits.T128Hz =1;
  26   3              if ( TimeCunt1024Hz%16 ==0 )
  27   3              {
  28   4                G_tflagbits.T64Hz =1;
  29   4                if ( TimeCunt1024Hz%64 ==0 )
  30   4                {
  31   5                  G_tflagbits.T16Hz =1;
  32   5                  if ( TimeCunt1024Hz%128==0 )
  33   5                  {
  34   6                    G_tflagbits.T8Hz =1;
  35   6                    if ( TimeCunt1024Hz%512==0 )
  36   6                    {
  37   7                      G_tflagbits.T2Hz =1;  
  38   7                      if ( TimeCunt1024Hz==1024 )
  39   7                      { 
  40   8                        TimeCunt1024Hz = 0;
  41   8                        G_tflagbits.T1Hz =1;
  42   8                      }
  43   7                    }
  44   6                  }
  45   5                } 
  46   4              }
  47   3            }
  48   2          }
  49   1          DEBUG_MARK;
  50   1          return;
  51   1        /* USER CODE END SysTick_IRQn 1 */
  52   1      }
C51 COMPILER V9.60.0.0   ISR                                                               04/19/2023 13:57:31 PAGE 2   

  53          
  54          
  55          //void TIM1_ISR(void)
  56          //{
  57          //  DEBUG_MARK;
  58          //  UART2_TX_Task();
  59          //}
  60          
  61          void TIM3_ISR(void) //300us interval
  62          {
  63   1          DEBUG_MARK;
  64   1        BeepMgrTask();
  65   1          
  66   1      }
  67          
  68          void UART1_ISR(void)
  69          {
  70   1        Uart1ReadByte(UART1_RXBUFFER);
  71   1        if ( ( UART1_Mgr.Status == Idle )&&(UART1_RXBUFFER[0]==0x55) )
  72   1        {
  73   2          UART1_Mgr.RX_DataPoint = 0x00;
  74   2          UART1_Mgr.RX_Buffer[UART1_Mgr.RX_DataPoint] = UART1_RXBUFFER[0];
  75   2          UART1_Mgr.RX_DataPoint++;
  76   2          UART1_Mgr.Status = ReceivingData;
  77   2        }
  78   1        else if (UART1_Mgr.Status == ReceivingData)
  79   1        {
  80   2          UART1_Mgr.RX_Buffer[UART1_Mgr.RX_DataPoint] = UART1_RXBUFFER[0];
  81   2          UART1_Mgr.RX_DataPoint++;
  82   2          if ((UART1_Mgr.RX_Buffer[0]==0x55)&&( UART1_Mgr.RX_DataPoint == (UART1_Mgr.RX_Buffer[5]+7))&&( UART1_Mgr
             -.RX_DataPoint >6 ))
  83   2          {
  84   3            UART1_Mgr.Status = GotNewCmd;
  85   3          }
  86   2          else if ( ( UART1_Mgr.RX_DataPoint > (UART1_Mgr.RX_Buffer[5]+7) ) ||  \
  87   2                    ( UART1_Mgr.RX_DataPoint > 80 )  )
  88   2          {
  89   3            UART1_Mgr.RX_DataPoint = 0x00;
  90   3            UART1_Mgr.Status = Idle;
  91   3          }
  92   2        }
  93   1        else if ( UART1_Mgr.Status == GotNewCmd )
  94   1        {
  95   2          //do nothing
  96   2        }
  97   1            
  98   1        return;
  99   1      }
 100          
 101          void UART2_ISR(void)
 102          {
 103   1        Uart2ReadByte(UART2_RXBUFFER);
 104   1        //UART2_RXBUFFER[0]= USXCON3;
 105   1        if (  UART2_Mgr.Status == GotNewCmd )
 106   1        {
 107   2          //do nothing
 108   2        }
 109   1        else if ( (UART2_Mgr.Status == Idle )&&(UART2_RXBUFFER[0]==0xEF) )
 110   1        {
 111   2          UART2_Mgr.RX_DataPoint = 0x00;
 112   2          UART2_Mgr.RX_Buffer[UART2_Mgr.RX_DataPoint] = UART2_RXBUFFER[0];
 113   2          UART2_Mgr.RX_DataPoint++;
C51 COMPILER V9.60.0.0   ISR                                                               04/19/2023 13:57:31 PAGE 3   

 114   2          UART2_Mgr.Status = ReceivingData;
 115   2        }
 116   1        else if (UART2_Mgr.Status == ReceivingData)
 117   1        {
 118   2          UART2_Mgr.RX_Buffer[UART2_Mgr.RX_DataPoint] = UART2_RXBUFFER[0];
 119   2          UART2_Mgr.RX_DataPoint++;
 120   2          if ((UART2_Mgr.RX_Buffer[0]==0xEF)&&( UART2_Mgr.RX_DataPoint == (UART2_Mgr.RX_Buffer[8]+9))&&( UART2_Mgr
             -.RX_DataPoint >8 ))
 121   2          {
 122   3            UART2_Mgr.Status = GotNewCmd;
 123   3          }
 124   2          else if ( UART2_Mgr.RX_DataPoint > 50)
 125   2          {
 126   3            UART2_Mgr.RX_DataPoint = 0x00;
 127   3            UART2_Mgr.Status = Idle;
 128   3          }
 129   2        }
 130   1            
 131   1        return;
 132   1      }
 133          
 134          void UART3_ISR(void)
 135          {
 136   1        Uart3ReadByte(UART1_RXBUFFER);
 137   1        if ( ( UART1_Mgr.Status == Idle )&&(UART1_RXBUFFER[0]==0x55) )
 138   1        {
 139   2          UART1_Mgr.RX_DataPoint = 0x00;
 140   2          UART1_Mgr.RX_Buffer[UART1_Mgr.RX_DataPoint] = UART1_RXBUFFER[0];
 141   2          UART1_Mgr.RX_DataPoint++;
 142   2          UART1_Mgr.Status = ReceivingData;
 143   2        }
 144   1        else if (UART1_Mgr.Status == ReceivingData)
 145   1        {
 146   2          UART1_Mgr.RX_Buffer[UART1_Mgr.RX_DataPoint] = UART1_RXBUFFER[0];
 147   2          UART1_Mgr.RX_DataPoint++;
 148   2          if ((UART1_Mgr.RX_Buffer[0]==0x55)&&( UART1_Mgr.RX_DataPoint == (UART1_Mgr.RX_Buffer[5]+7))&&( UART1_Mgr
             -.RX_DataPoint >6 ))
 149   2          {
 150   3            UART1_Mgr.Status = GotNewCmd;
 151   3          }
 152   2          else if ( ( UART1_Mgr.RX_DataPoint > (UART1_Mgr.RX_Buffer[5]+7) ) ||  \
 153   2                    ( UART1_Mgr.RX_DataPoint > 80 )  )
 154   2          {
 155   3            UART1_Mgr.RX_DataPoint = 0x00;
 156   3            UART1_Mgr.Status = Idle;
 157   3          }
 158   2        }
 159   1        else if ( UART1_Mgr.Status == GotNewCmd )
 160   1        {
 161   2          //do nothing
 162   2        }
 163   1            
 164   1        return;
 165   1      }
 166          
 167           
 168          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    543    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V9.60.0.0   ISR                                                               04/19/2023 13:57:31 PAGE 4   

   XDATA SIZE       =      6    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.60.0.0   BEEPLOGIC                                                         02/09/2023 18:47:27 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE BEEPLOGIC
OBJECT MODULE PLACED IN .\Objects\BeepLogic.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Softwares\ModuleLogic\BeepLogic.c LARGE OMF2 OPTIMIZE(9,SPEED) BROWSE IN
                    -CDIR(.\Drivers\Lib\c;.\Drivers\Lib\H;.\Drivers\Lib\IAP_Lib;.\Drivers\Lib\TouchKey_lib;.\Drivers\Physical;.\Drivers\Proto
                    -col;.\Softwares\Application;.\Softwares\Basic;.\Softwares\ModuleLogic) DEBUG PRINT(.\Listings\BeepLogic.lst) TABS(2) OBJ
                    -ECT(.\Objects\BeepLogic.obj)

line level    source

   1          #include "BeepLogic.h"
   2          #include "global_variable.h"
   3          #include "BeepMgr.h"
   4          #include "IO.h"
   5          //#include "StdTypes.h"
   6          
   7          void STOP_VOICEPLAY(void)
   8          {
   9   1        PLAY_VOICE_ONESEGMENT_FIXED(0xFE);
  10   1      }
  11          
  12          void SET_VOLUME(uint8_t volume)
  13          {
  14   1        PLAY_VOICE_ONESEGMENT_FIXED(0xE0+volume);//,VOICE_VolumeAdjust);
  15   1      }
  16          
  17          void PLAY_VOICE_ONESEGMENT_FIXED(uint8_t segment)
  18          {
  19   1        if (  ( VoiceMgr.Enable == bFALSE)&&
  20   1            ( ( CurrentScreen == SCREEN_Main)
  21   1              ||( CurrentScreen == SCREEN_IdentifySuccess)
  22   1              ||( CurrentScreen == SCREEN_IdentifyFail)
  23   1            )
  24   1          )
  25   1        {
  26   2          return;
  27   2        }
  28   1        VoiceDataTransferMgr.DataBuff[0]= segment;
  29   1        VoiceDataTransferMgr.BitPoint = 0x00;
  30   1        VoiceDataTransferMgr.SendDataNum = 0;
  31   1        VoiceDataTransferMgr.TotalDataNum = 1;
  32   1        VoiceDataTransferMgr.Status = SendingDataStart;
  33   1        VoiceDataTransferMgr.VoicePlayEndCnt=0;
  34   1        VoiceDataTransferMgr.VoicePlayEnd = bFALSE;
  35   1      }
  36          
  37          
  38          
  39          void PLAY_VOICE_ONESEGMENT(uint8_t segment)
  40          {
  41   1        uint8_t Buff[2];
  42   1      
  43   1        Buff[0]= segment;
  44   1        Buff[1]= DEF_VoiceSegmentEndFlag;
  45   1        PLAY_VOICE_MULTISEGMENTS(Buff);
  46   1      }
  47          
  48          void PLAY_VOICE_TWOSEGMENT(uint8_t segment1,uint8_t segment2)
  49          {
  50   1        uint8_t Buff[3];
  51   1      
  52   1        Buff[0]= segment1;
C51 COMPILER V9.60.0.0   BEEPLOGIC                                                         02/09/2023 18:47:27 PAGE 2   

  53   1        Buff[1]= segment2;
  54   1        Buff[2]= DEF_VoiceSegmentEndFlag;
  55   1        PLAY_VOICE_MULTISEGMENTS(Buff);
  56   1      
  57   1      }
  58          
  59          void PLAY_VOICE_THREESEGMENT(uint8_t segment1,uint8_t segment2,uint8_t segment3)
  60          {
  61   1        uint8_t Buff[4];
  62   1      
  63   1        Buff[0]= segment1;
  64   1        Buff[1]= segment2;
  65   1        Buff[2]= segment3;
  66   1        Buff[3]= DEF_VoiceSegmentEndFlag;
  67   1        PLAY_VOICE_MULTISEGMENTS(Buff);
  68   1      }
  69          
  70          
  71          
  72          void PLAY_VOICE_MULTISEGMENTS(uint8_t BUFF[])
  73          {
  74   1        uint8_t SegmentCnt;
  75   1        
  76   1        if (  ( VoiceMgr.Enable == bFALSE)&&
  77   1            ( ( CurrentScreen == SCREEN_Main)
  78   1              ||( CurrentScreen == SCREEN_IdentifySuccess)
  79   1              ||( CurrentScreen == SCREEN_IdentifyFail)
  80   1            )
  81   1          )
  82   1        {
  83   2          return;
  84   2        }
  85   1        VoiceDataTransferMgr.DataBuff[0] = 0xfe;
  86   1        for ( SegmentCnt =0;SegmentCnt<49;SegmentCnt++)
  87   1        {
  88   2          if ( BUFF[SegmentCnt] == DEF_VoiceSegmentEndFlag ){break;}
  89   2          VoiceDataTransferMgr.DataBuff[2*SegmentCnt+1] = 0xF3; //Continue play
  90   2          //VoiceDataTransferMgr.DataBuff[2*SegmentCnt+1] = BUFF[SegmentCnt]+SystemLanguage; //Continue play
  91   2          VoiceDataTransferMgr.DataBuff[2*SegmentCnt+2] = BUFF[SegmentCnt]; //Continue play
  92   2        }
  93   1        VoiceDataTransferMgr.BitPoint = 0x00;
  94   1        VoiceDataTransferMgr.SendDataNum = 0;
  95   1        VoiceDataTransferMgr.TotalDataNum = 2*SegmentCnt+1;
  96   1        VoiceDataTransferMgr.Status = SendingDataStart;
  97   1        VoiceDataTransferMgr.VoicePlayEndCnt=0;
  98   1        VoiceDataTransferMgr.VoicePlayEnd = bFALSE;
  99   1      }
 100          
 101          void PLAY_VOICE_DOORBELL(void)
 102          {
 103   1        if ( VoiceDataTransferMgr.Status != VoiceIdle )
 104   1        {
 105   2          return;
 106   2        }
 107   1        VoiceDataTransferMgr.DataBuff[0] = 0xfe;
 108   1        VoiceDataTransferMgr.DataBuff[1]= 0xF3;
 109   1        VoiceDataTransferMgr.DataBuff[2]= VOICE_Doorbell;
 110   1        VoiceDataTransferMgr.DataBuff[3]= 0xF3;
 111   1        VoiceDataTransferMgr.DataBuff[4]= VOICE_Doorbell;
 112   1        VoiceDataTransferMgr.BitPoint = 0x00;
 113   1        VoiceDataTransferMgr.SendDataNum = 0;
 114   1        VoiceDataTransferMgr.TotalDataNum = 5;
C51 COMPILER V9.60.0.0   BEEPLOGIC                                                         02/09/2023 18:47:27 PAGE 3   

 115   1        VoiceDataTransferMgr.Status = SendingDataStart;
 116   1        VoiceDataTransferMgr.VoicePlayEndCnt=0;
 117   1        VoiceDataTransferMgr.VoicePlayEnd = bFALSE;
 118   1      }
 119          
 120          void PLAY_VOICE2_DOORBELL(void)
 121          {
 122   1        VoiceDataTransferMgr2.BitPoint = 0x00;
 123   1        VoiceDataTransferMgr2.DataBuff[3] = 0xF3;
 124   1        VoiceDataTransferMgr2.DataBuff[2] = VOICE_Doorbell;
 125   1        VoiceDataTransferMgr2.DataBuff[1] = 0xF3;
 126   1        VoiceDataTransferMgr2.DataBuff[0] = VOICE_Doorbell;
 127   1        VoiceDataTransferMgr2.SendDataNum = 4;
 128   1        VoiceDataTransferMgr2.Status = SendingDataStart;
 129   1      }
 130          
 131          
 132          void BeepMgrTask(void)
 133          {
 134   1        if ( VoiceDataTransferMgr.PulseWidthCnt > 0 )
 135   1          {
 136   2            VoiceDataTransferMgr.PulseWidthCnt--;
 137   2          }
 138   1          
 139   1          if ( VoiceDataTransferMgr.PulseWidthCnt == 0 )
 140   1          {
 141   2            switch ( VoiceDataTransferMgr.Status )
 142   2            {
 143   3              default:
 144   3                
 145   3              case VoiceIdle:
 146   3                SET_VOICEDATA_H;
 147   3      
 148   3                if ( STATUS_PINMACRO_VOICEBUSY != 0 )
 149   3                { 
 150   4                  if ( VoiceDataTransferMgr.VoicePlayEndCnt < 1500)
 151   4                  {
 152   5                    VoiceDataTransferMgr.VoicePlayEndCnt++;
 153   5                  }
 154   4                  else{
 155   5                    VoiceDataTransferMgr.VoicePlayEnd = bTRUE;
 156   5                  }
 157   4                  DEBUG_MARK;
 158   4                }
 159   3                else
 160   3                {
 161   4                  VoiceDataTransferMgr.VoicePlayEndCnt=0;
 162   4                  VoiceDataTransferMgr.VoicePlayEnd = bFALSE;
 163   4                  DEBUG_MARK;
 164   4                }
 165   3                break;  
 166   3                  
 167   3              case SendingDataStart:
 168   3      //  
 169   3      //          if ( STATUS_PINMACRO_VOICEDATA != 0 )
 170   3      //          {
 171   3      //            SET_VOICEDATA_L;
 172   3      //            VoiceDataTransferMgr.PulseWidthCnt = 17;  //5.1ms
 173   3      //          }
 174   3      //          else
 175   3      //          {
 176   3      //            VoiceDataTransferMgr.Status =  SendingData;//SendingData;
C51 COMPILER V9.60.0.0   BEEPLOGIC                                                         02/09/2023 18:47:27 PAGE 4   

 177   3      //            VoiceDataTransferMgr.Data = VoiceDataTransferMgr.DataBuff[VoiceDataTransferMgr.SendDataNum];
 178   3      //          }
 179   3                  SET_VOICEDATA_L;
 180   3                  VoiceDataTransferMgr.PulseWidthCnt = 27;
 181   3                  VoiceDataTransferMgr.Status =  SendingData;//SendingData;
 182   3                  VoiceDataTransferMgr.Data = VoiceDataTransferMgr.DataBuff[VoiceDataTransferMgr.SendDataNum];
 183   3                  
 184   3                break;
 185   3                
 186   3              case SendingData:
 187   3        
 188   3                  if ( STATUS_PINMACRO_VOICEDATA == 0 ) //send High level
 189   3                  {
 190   4                    SET_VOICEDATA_H;
 191   4                    if ( (VoiceDataTransferMgr.Data&0x01) != 0x00)
 192   4                    {
 193   5                      VoiceDataTransferMgr.PulseWidthCnt = 3; //900US
 194   5                      DEBUG_MARK;
 195   5                    }
 196   4                    else
 197   4                    {
 198   5                      VoiceDataTransferMgr.PulseWidthCnt = 1; //300US
 199   5                      DEBUG_MARK;
 200   5                    }
 201   4                  }
 202   3                  else    //send low level
 203   3                  {
 204   4                    SET_VOICEDATA_L;
 205   4                    if ( (VoiceDataTransferMgr.Data&0x01) != 0x00)
 206   4                    {
 207   5                      VoiceDataTransferMgr.PulseWidthCnt = 1; //300US
 208   5                    }
 209   4                    else
 210   4                    {
 211   5                      VoiceDataTransferMgr.PulseWidthCnt = 3; //900US
 212   5                    }
 213   4                    VoiceDataTransferMgr.Data>>=1;
 214   4        
 215   4                    if ( ++VoiceDataTransferMgr.BitPoint >=8 )
 216   4                    {
 217   5                      VoiceDataTransferMgr.Status = SendingDataEnd;
 218   5                      DEBUG_MARK;
 219   5                    }
 220   4                  }
 221   3                break;
 222   3                
 223   3                case SendingDataEnd:  
 224   3                  
 225   3                  SET_VOICEDATA_H;
 226   3                
 227   3                  VoiceDataTransferMgr.SendDataNum++;
 228   3                
 229   3                  if (VoiceDataTransferMgr.SendDataNum < VoiceDataTransferMgr.TotalDataNum )
 230   3                  {
 231   4                    VoiceDataTransferMgr.Status = ContinueSendData;
 232   4                    VoiceDataTransferMgr.PulseWidthCnt = 10; //3MS
 233   4                  }
 234   3                  else
 235   3                  {
 236   4                    VoiceDataTransferMgr.Status = VoiceIdle;
 237   4                    VoiceDataTransferMgr.PulseWidthCnt = 333; //100MS
 238   4                  }
C51 COMPILER V9.60.0.0   BEEPLOGIC                                                         02/09/2023 18:47:27 PAGE 5   

 239   3                  
 240   3                  
 241   3                  DEBUG_MARK;
 242   3                break;  
 243   3                
 244   3                case ContinueSendData:  
 245   3      
 246   3                  //if ( STATUS_PINMACRO_VOICEBUSY != 0 )
 247   3                  {
 248   4                    VoiceDataTransferMgr.Status = SendingDataStart;
 249   4                    VoiceDataTransferMgr.BitPoint = 0x00;
 250   4                  }
 251   3      
 252   3                  DEBUG_MARK;
 253   3                break;  
 254   3                
 255   3            }
 256   2          }
 257   1        return;
 258   1      
 259   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    642    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      12
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

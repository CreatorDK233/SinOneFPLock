C51 COMPILER V9.60.0.0   BEEPMGR                                                           04/21/2023 14:26:37 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE BEEPMGR
OBJECT MODULE PLACED IN .\Objects\BeepMgr.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Drivers\Protocol\BeepMgr.c LARGE OMF2 OPTIMIZE(9,SPEED) BROWSE INCDIR(.\
                    -Drivers\Lib\c;.\Drivers\Lib\H;.\Drivers\Lib\IAP_Lib;.\Drivers\Lib\TouchKey_lib;.\Drivers\Physical;.\Drivers\Protocol;.\S
                    -oftwares\Application;.\Softwares\Basic;.\Softwares\ModuleLogic) DEBUG PRINT(.\Listings\BeepMgr.lst) TABS(2) OBJECT(.\Obj
                    -ects\BeepMgr.obj)

line level    source

   1          #include "IO.h"
   2          #include "global_variable.h"
   3          #include "BeepMgr.h"
   4          
   5          void PLAY_VOICE_ONESEGMENT(uint8_t segment)
   6          {
   7   1        uint8_t Buff[2];
   8   1      
   9   1        Buff[0]= segment;
  10   1        Buff[1]= DEF_VoiceSegmentEndFlag;
  11   1        PLAY_VOICE_MULTISEGMENTS(Buff);
  12   1      }
  13          
  14          void PLAY_VOICE_TWOSEGMENT(uint8_t segment1,uint8_t segment2)
  15          {
  16   1        uint8_t Buff[3];
  17   1      
  18   1        Buff[0]= segment1;
  19   1        Buff[1]= segment2;
  20   1        Buff[2]= DEF_VoiceSegmentEndFlag;
  21   1        PLAY_VOICE_MULTISEGMENTS(Buff);
  22   1      
  23   1      }
  24          
  25          void PLAY_VOICE_THREESEGMENT(uint8_t segment1,uint8_t segment2,uint8_t segment3)
  26          {
  27   1        uint8_t Buff[4];
  28   1      
  29   1        Buff[0]= segment1;
  30   1        Buff[1]= segment2;
  31   1        Buff[2]= segment3;
  32   1        Buff[3]= DEF_VoiceSegmentEndFlag;
  33   1        PLAY_VOICE_MULTISEGMENTS(Buff);
  34   1      }
  35          
  36          void PLAY_VOICE_MULTISEGMENTS(uint8_t BUFF[])
  37          {
  38   1        uint8_t SegmentCnt;
  39   1        
  40   1        if (  ( VoiceMgr.Enable == bFALSE)&&
  41   1            ( ( CurrentScreen == SCREEN_Main)
  42   1              ||( CurrentScreen == SCREEN_IdentifySuccess)
  43   1              ||( CurrentScreen == SCREEN_IdentifyFail)
  44   1            )
  45   1          )
  46   1        {
  47   2          return;
  48   2        }
  49   1        VoiceDataTransferMgr.DataBuff[0] = 0xfe;
  50   1        for ( SegmentCnt =0;SegmentCnt<49;SegmentCnt++)
  51   1        {
  52   2          if ( BUFF[SegmentCnt] == DEF_VoiceSegmentEndFlag ){break;}
C51 COMPILER V9.60.0.0   BEEPMGR                                                           04/21/2023 14:26:37 PAGE 2   

  53   2          VoiceDataTransferMgr.DataBuff[2*SegmentCnt+1] = 0xF3; //Continue play
  54   2          //VoiceDataTransferMgr.DataBuff[2*SegmentCnt+1] = BUFF[SegmentCnt]+SystemLanguage; //Continue play
  55   2          VoiceDataTransferMgr.DataBuff[2*SegmentCnt+2] = BUFF[SegmentCnt]; //Continue play
  56   2        }
  57   1        VoiceDataTransferMgr.BitPoint = 0x00;
  58   1        VoiceDataTransferMgr.SendDataNum = 0;
  59   1        VoiceDataTransferMgr.TotalDataNum = 2*SegmentCnt+1;
  60   1        VoiceDataTransferMgr.Status = SendingDataStart;
  61   1        VoiceDataTransferMgr.VoicePlayEndCnt=0;
  62   1        VoiceDataTransferMgr.VoicePlayEnd = bFALSE;
  63   1      }
  64          
  65          void PLAY_VOICE_ONESEGMENT_FIXED(uint8_t segment)
  66          {
  67   1        if (  ( VoiceMgr.Enable == bFALSE)&&
  68   1            ( ( CurrentScreen == SCREEN_Main)
  69   1              ||( CurrentScreen == SCREEN_IdentifySuccess)
  70   1              ||( CurrentScreen == SCREEN_IdentifyFail)
  71   1            )
  72   1          )
  73   1        {
  74   2          return;
  75   2        }
  76   1        VoiceDataTransferMgr.DataBuff[0]= segment;
  77   1        VoiceDataTransferMgr.BitPoint = 0x00;
  78   1        VoiceDataTransferMgr.SendDataNum = 0;
  79   1        VoiceDataTransferMgr.TotalDataNum = 1;
  80   1        VoiceDataTransferMgr.Status = SendingDataStart;
  81   1        VoiceDataTransferMgr.VoicePlayEndCnt=0;
  82   1        VoiceDataTransferMgr.VoicePlayEnd = bFALSE;
  83   1      }
  84          
  85          void PLAY_VOICE_TWOSEGMENT_FIXED(uint8_t segment1,uint8_t segment2)
  86          {
  87   1        uint8_t Buff[4];
  88   1      
  89   1        Buff[0]= segment1;
  90   1        Buff[1]= segment2;
  91   1        Buff[2]= DEF_VoiceSegmentEndFlag;
  92   1        PLAY_VOICE_MULTISEGMENTS_FIXED(Buff);
  93   1      }
  94          
  95          void PLAY_VOICE_THREESEGMENT_FIXED(uint8_t segment1,uint8_t segment2,uint8_t segment3)
  96          {
  97   1        uint8_t Buff[4];
  98   1      
  99   1        Buff[0]= segment1;
 100   1        Buff[1]= segment2;
 101   1        Buff[2]= segment3;
 102   1        Buff[3]= DEF_VoiceSegmentEndFlag;
 103   1        PLAY_VOICE_MULTISEGMENTS_FIXED(Buff);
 104   1      }
 105          
 106          void PLAY_VOICE_MULTISEGMENTS_FIXED(uint8_t BUFF[])
 107          {
 108   1        uint8_t SegmentCnt;
 109   1        
 110   1        if (  ( VoiceMgr.Enable == bFALSE)&&
 111   1            ( ( CurrentScreen == SCREEN_Main)
 112   1              ||( CurrentScreen == SCREEN_IdentifySuccess)
 113   1              ||( CurrentScreen == SCREEN_IdentifyFail)
 114   1            )
C51 COMPILER V9.60.0.0   BEEPMGR                                                           04/21/2023 14:26:37 PAGE 3   

 115   1          )
 116   1        {
 117   2          return;
 118   2        }
 119   1        VoiceDataTransferMgr.DataBuff[0] = 0xfe;
 120   1        for ( SegmentCnt =0;SegmentCnt<49;SegmentCnt++)
 121   1        {
 122   2          if ( BUFF[SegmentCnt] == DEF_VoiceSegmentEndFlag ){break;}
 123   2          VoiceDataTransferMgr.DataBuff[2*SegmentCnt+1] = 0xF3; //Continue play
 124   2          VoiceDataTransferMgr.DataBuff[2*SegmentCnt+2] = BUFF[SegmentCnt]; //Continue play
 125   2        }
 126   1        VoiceDataTransferMgr.BitPoint = 0x00;
 127   1        VoiceDataTransferMgr.SendDataNum = 0;
 128   1        VoiceDataTransferMgr.TotalDataNum = 2*SegmentCnt+1;
 129   1        VoiceDataTransferMgr.Status = SendingDataStart;
 130   1        VoiceDataTransferMgr.VoicePlayEndCnt=0;
 131   1        VoiceDataTransferMgr.VoicePlayEnd = bFALSE;
 132   1      }
 133          
 134          void SET_VOLUME(uint8_t volume)
 135          {
 136   1        PLAY_VOICE_ONESEGMENT_FIXED(0xE0+volume);
 137   1      }
 138          
 139          void STOP_VOICEPLAY(void)
 140          {
 141   1        PLAY_VOICE_ONESEGMENT_FIXED(0xFE);
 142   1      }
 143          
 144          void VoicePlayerPowerDown(void)
 145          {
 146   1        SET_VOICEDATA_SLEEP;
 147   1        SET_VOICEBUSY_SLEEP;
 148   1      }
 149          
 150          void PLAY_VOICE_DOORBELL(void)
 151          {
 152   1        if ( VoiceDataTransferMgr.Status != VoiceIdle )
 153   1        {
 154   2          return;
 155   2        }
 156   1        VoiceDataTransferMgr.DataBuff[0] = 0xfe;
 157   1        VoiceDataTransferMgr.DataBuff[1]= 0xF3;
 158   1        VoiceDataTransferMgr.DataBuff[2]= VOICE_Doorbell;
 159   1        VoiceDataTransferMgr.DataBuff[3]= 0xF3;
 160   1        VoiceDataTransferMgr.DataBuff[4]= VOICE_Doorbell;
 161   1        VoiceDataTransferMgr.BitPoint = 0x00;
 162   1        VoiceDataTransferMgr.SendDataNum = 0;
 163   1        VoiceDataTransferMgr.TotalDataNum = 5;
 164   1        VoiceDataTransferMgr.Status = SendingDataStart;
 165   1        VoiceDataTransferMgr.VoicePlayEndCnt=0;
 166   1        VoiceDataTransferMgr.VoicePlayEnd = bFALSE;
 167   1      }
 168          
 169          void PLAY_VOICE2_ONESEGMENT(uint8_t segment)
 170          {
 171   1        VoiceDataTransferMgr2.BitPoint = 0x00;
 172   1        VoiceDataTransferMgr2.DataBuff[0] = segment;
 173   1        VoiceDataTransferMgr2.SendDataNum = 1;
 174   1        VoiceDataTransferMgr2.Status = SendingDataStart;
 175   1      }
 176          
C51 COMPILER V9.60.0.0   BEEPMGR                                                           04/21/2023 14:26:37 PAGE 4   

 177          void PLAY_VOICE2_TWOSEGMENT(uint8_t segment1,uint8_t segment2)
 178          {
 179   1        if ( VoiceMgr.Enable == bTRUE)
 180   1        {
 181   2          VoiceDataTransferMgr2.BitPoint = 0x00;
 182   2          VoiceDataTransferMgr2.DataBuff[3] = 0xF3;
 183   2          VoiceDataTransferMgr2.DataBuff[2] = segment1;
 184   2          VoiceDataTransferMgr2.DataBuff[1] = 0xF3;
 185   2          VoiceDataTransferMgr2.DataBuff[0] = segment2;
 186   2          VoiceDataTransferMgr2.SendDataNum = 4;
 187   2          VoiceDataTransferMgr2.Status = SendingDataStart;
 188   2        }
 189   1      }
 190          
 191          void PLAY_VOICE2_DOORBELL(void)
 192          {
 193   1        VoiceDataTransferMgr2.BitPoint = 0x00;
 194   1        VoiceDataTransferMgr2.DataBuff[3] = 0xF3;
 195   1        VoiceDataTransferMgr2.DataBuff[2] = VOICE_Doorbell;
 196   1        VoiceDataTransferMgr2.DataBuff[1] = 0xF3;
 197   1        VoiceDataTransferMgr2.DataBuff[0] = VOICE_Doorbell;
 198   1        VoiceDataTransferMgr2.SendDataNum = 4;
 199   1        VoiceDataTransferMgr2.Status = SendingDataStart;
 200   1      }
 201          
 202          void PLAY_VOICE2_CONTINUE(uint8_t segment)
 203          {
 204   1        VoiceDataTransferMgr2.BitPoint = 0x00;
 205   1        VoiceDataTransferMgr2.DataBuff[1] = segment;
 206   1        VoiceDataTransferMgr2.DataBuff[0] = 0xF2;
 207   1        VoiceDataTransferMgr2.SendDataNum = 2;
 208   1        VoiceDataTransferMgr2.Status = SendingDataStart;
 209   1      }
 210          
 211          void STOP_VOICEPLAY2(void)
 212          {
 213   1        VoiceDataTransferMgr2.BitPoint = 0x00;
 214   1        VoiceDataTransferMgr2.DataBuff[0] = 0xFE;
 215   1        VoiceDataTransferMgr2.SendDataNum = 1;
 216   1        VoiceDataTransferMgr2.Status = SendingDataStart;
 217   1      }
 218          
 219          void VOICE_Init(void)
 220          {
 221   1        VoiceDataTransferMgr.PulseWidthCnt = 0;
 222   1        VoiceDataTransferMgr.Status = VoiceIdle;
 223   1        VoiceDataTransferMgr2.PulseWidthCnt = 0;  
 224   1        VoiceDataTransferMgr2.Status = VoiceIdle; 
 225   1      }
 226          
 227          void BeepMgrTask(void)
 228          {
 229   1        if ( VoiceDataTransferMgr.PulseWidthCnt > 0 )
 230   1          {
 231   2            VoiceDataTransferMgr.PulseWidthCnt--;
 232   2          }
 233   1          
 234   1          if ( VoiceDataTransferMgr.PulseWidthCnt == 0 )
 235   1          {
 236   2            switch ( VoiceDataTransferMgr.Status )
 237   2            {
 238   3              default:
C51 COMPILER V9.60.0.0   BEEPMGR                                                           04/21/2023 14:26:37 PAGE 5   

 239   3                
 240   3              case VoiceIdle:
 241   3                SET_VOICEDATA_H;
 242   3      
 243   3                if ( STATUS_PINMACRO_VOICEBUSY != 0 )
 244   3                { 
 245   4                  if ( VoiceDataTransferMgr.VoicePlayEndCnt < 1500)
 246   4                  {
 247   5                    VoiceDataTransferMgr.VoicePlayEndCnt++;
 248   5                  }
 249   4                  else{
 250   5                    VoiceDataTransferMgr.VoicePlayEnd = bTRUE;
 251   5                  }
 252   4                  DEBUG_MARK;
 253   4                }
 254   3                else
 255   3                {
 256   4                  VoiceDataTransferMgr.VoicePlayEndCnt=0;
 257   4                  VoiceDataTransferMgr.VoicePlayEnd = bFALSE;
 258   4                  DEBUG_MARK;
 259   4                }
 260   3                break;  
 261   3                  
 262   3              case SendingDataStart:
 263   3      //  
 264   3      //          if ( STATUS_PINMACRO_VOICEDATA != 0 )
 265   3      //          {
 266   3      //            SET_VOICEDATA_L;
 267   3      //            VoiceDataTransferMgr.PulseWidthCnt = 17;  //5.1ms
 268   3      //          }
 269   3      //          else
 270   3      //          {
 271   3      //            VoiceDataTransferMgr.Status =  SendingData;//SendingData;
 272   3      //            VoiceDataTransferMgr.Data = VoiceDataTransferMgr.DataBuff[VoiceDataTransferMgr.SendDataNum];
 273   3      //          }
 274   3                  SET_VOICEDATA_L;
 275   3                  VoiceDataTransferMgr.PulseWidthCnt = 27;
 276   3                  VoiceDataTransferMgr.Status =  SendingData;//SendingData;
 277   3                  VoiceDataTransferMgr.Data = VoiceDataTransferMgr.DataBuff[VoiceDataTransferMgr.SendDataNum];
 278   3                  
 279   3                break;
 280   3                
 281   3              case SendingData:
 282   3        
 283   3                  if ( STATUS_PINMACRO_VOICEDATA == 0 ) //send High level
 284   3                  {
 285   4                    SET_VOICEDATA_H;
 286   4                    if ( (VoiceDataTransferMgr.Data&0x01) != 0x00)
 287   4                    {
 288   5                      VoiceDataTransferMgr.PulseWidthCnt = 3; //900US
 289   5                      DEBUG_MARK;
 290   5                    }
 291   4                    else
 292   4                    {
 293   5                      VoiceDataTransferMgr.PulseWidthCnt = 1; //300US
 294   5                      DEBUG_MARK;
 295   5                    }
 296   4                  }
 297   3                  else    //send low level
 298   3                  {
 299   4                    SET_VOICEDATA_L;
 300   4                    if ( (VoiceDataTransferMgr.Data&0x01) != 0x00)
C51 COMPILER V9.60.0.0   BEEPMGR                                                           04/21/2023 14:26:37 PAGE 6   

 301   4                    {
 302   5                      VoiceDataTransferMgr.PulseWidthCnt = 1; //300US
 303   5                    }
 304   4                    else
 305   4                    {
 306   5                      VoiceDataTransferMgr.PulseWidthCnt = 3; //900US
 307   5                    }
 308   4                    VoiceDataTransferMgr.Data>>=1;
 309   4        
 310   4                    if ( ++VoiceDataTransferMgr.BitPoint >=8 )
 311   4                    {
 312   5                      VoiceDataTransferMgr.Status = SendingDataEnd;
 313   5                      DEBUG_MARK;
 314   5                    }
 315   4                  }
 316   3                break;
 317   3                
 318   3                case SendingDataEnd:  
 319   3                  
 320   3                  SET_VOICEDATA_H;
 321   3                
 322   3                  VoiceDataTransferMgr.SendDataNum++;
 323   3                
 324   3                  if (VoiceDataTransferMgr.SendDataNum < VoiceDataTransferMgr.TotalDataNum )
 325   3                  {
 326   4                    VoiceDataTransferMgr.Status = ContinueSendData;
 327   4                    VoiceDataTransferMgr.PulseWidthCnt = 10; //3MS
 328   4                  }
 329   3                  else
 330   3                  {
 331   4                    VoiceDataTransferMgr.Status = VoiceIdle;
 332   4                    VoiceDataTransferMgr.PulseWidthCnt = 333; //100MS
 333   4                  }
 334   3                  
 335   3                  
 336   3                  DEBUG_MARK;
 337   3                break;  
 338   3                
 339   3                case ContinueSendData:  
 340   3      
 341   3                  //if ( STATUS_PINMACRO_VOICEBUSY != 0 )
 342   3                  {
 343   4                    VoiceDataTransferMgr.Status = SendingDataStart;
 344   4                    VoiceDataTransferMgr.BitPoint = 0x00;
 345   4                  }
 346   3      
 347   3                  DEBUG_MARK;
 348   3                break;  
 349   3                
 350   3            }
 351   2          }
 352   1        return;
 353   1      
 354   1      }
 355          
 356          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    897    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      23
C51 COMPILER V9.60.0.0   BEEPMGR                                                           04/21/2023 14:26:37 PAGE 7   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.60.0.0   MCU_API                                                           03/08/2023 18:02:10 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MCU_API
OBJECT MODULE PLACED IN .\Objects\mcu_api.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Drivers\Protocol\WIFI_Tuya\mcu_api.c LARGE OMF2 OPTIMIZE(9,SPEED) BROWSE
                    - INCDIR(.\Drivers\Lib\c;.\Drivers\Lib\H;.\Drivers\Lib\IAP_Lib;.\Drivers\Lib\TouchKey_lib;.\Drivers\Physical;.\Drivers\Pr
                    -otocol;.\Softwares\Application;.\Softwares\Basic;.\Softwares\ModuleLogic;.\Drivers\Protocol\YC_NFC;.\Drivers\Protocol\WI
                    -FI_Tuya) DEBUG PRINT(.\Listings\mcu_api.lst) TABS(2) OBJECT(.\Objects\mcu_api.obj)

line level    source

   1          /**********************************Copyright (c)**********************************
   2          **                       ç‰ˆæƒæ‰€æœ‰ (C), 2015-2020, æ¶‚é¸¦ç§‘æŠ€
   3          **
   4          **                             http://www.tuya.com
   5          **
   6          *********************************************************************************/
   7          /**
   8           * @file    mcu_api.c
   9           * @author  æ¶‚é¸¦ç»¼åˆåè®®å¼€å‘ç»„
  10           * @version v1.0.7
  11           * @date    2020.11.9
  12           * @brief   ç”¨æˆ·éœ€è¦ä¸»åŠ¨è°ƒç”¨çš„å‡½æ•°éƒ½åœ¨è¯¥æ–‡ä»¶å†…
  13           */
  14          
  15          
  16          #define MCU_API_GLOBAL
  17          
  18          #include "mcu_api.h"
  19          #include "wifi.h"
  20          
  21          extern const DOWNLOAD_CMD_S download_cmd[];
  22          
  23          /**
  24           * @brief  hexè½¬bcd
  25           * @param[in] {Value_H} é«˜å­—èŠ‚
  26           * @param[in] {Value_L} ä½å­—èŠ‚
  27           * @return è½¬æ¢å®Œæˆåæ•°æ®
  28           */
  29          unsigned char hex_to_bcd(unsigned char Value_H,unsigned char Value_L)
  30          {
  31   1          unsigned char bcd_value;
  32   1          
  33   1          if((Value_H >= '0') && (Value_H <= '9'))
  34   1              Value_H -= '0';
  35   1          else if((Value_H >= 'A') && (Value_H <= 'F'))
  36   1              Value_H = Value_H - 'A' + 10;
  37   1          else if((Value_H >= 'a') && (Value_H <= 'f'))
  38   1              Value_H = Value_H - 'a' + 10;
  39   1           
  40   1          bcd_value = Value_H & 0x0f;
  41   1          
  42   1          bcd_value <<= 4;
  43   1          if((Value_L >= '0') && (Value_L <= '9'))
  44   1              Value_L -= '0';
  45   1          else if((Value_L >= 'A') && (Value_L <= 'F'))
  46   1              Value_L = Value_L - 'a' + 10;
  47   1          else if((Value_L >= 'a') && (Value_L <= 'f'))
  48   1              Value_L = Value_L - 'a' + 10;
  49   1          
  50   1          bcd_value |= Value_L & 0x0f;
  51   1      
  52   1          return bcd_value;
C51 COMPILER V9.60.0.0   MCU_API                                                           03/08/2023 18:02:10 PAGE 2   

  53   1      }
  54          
  55          /**
  56           * @brief  æ±‚å­—ç¬¦ä¸²é•¿åº¦
  57           * @param[in] {str} å­—ç¬¦ä¸²åœ°å€
  58           * @return æ•°æ®é•¿åº¦
  59           */
  60          unsigned long my_strlen(unsigned char *str)  
  61          {
  62   1          unsigned long len = 0;
  63   1          if(str == NULL) { 
  64   2              return 0;
  65   2          }
  66   1          
  67   1          for(len = 0; *str ++ != '\0'; ) {
  68   2              len ++;
  69   2          }
  70   1          
  71   1          return len;
  72   1      }
  73          
  74          /**
  75           * @brief  æŠŠsrcæ‰€æŒ‡å†…å­˜åŒºåŸŸçš„å‰countä¸ªå­—èŠ‚è®¾ç½®æˆå­—ç¬¦c
  76           * @param[out] {src} å¾…è®¾ç½®çš„å†…å­˜é¦–åœ°å€
  77           * @param[in] {ch} è®¾ç½®çš„å­—ç¬¦
  78           * @param[in] {count} è®¾ç½®çš„å†…å­˜é•¿åº¦
  79           * @return å¾…è®¾ç½®çš„å†…å­˜é¦–åœ°å€
  80           */
  81          void *my_memset(void *src,unsigned char ch,unsigned short count)
  82          {
  83   1          unsigned char *tmp = (unsigned char *)src;
  84   1          
  85   1          if(src == NULL) {
  86   2              return NULL;
  87   2          }
  88   1          
  89   1          while(count --) {
  90   2              *tmp ++ = ch;
  91   2          }
  92   1          
  93   1          return src;
  94   1      }
  95          
  96          /**
  97           * @brief  å†…å­˜æ‹·è´
  98           * @param[out] {dest} ç›®æ ‡åœ°å€
  99           * @param[in] {src} æºåœ°å€
 100           * @param[in] {count} æ‹·è´æ•°æ®ä¸ªæ•°
 101           * @return æ•°æ®å¤„ç†å®Œåçš„æºåœ°å€
 102           */
 103          void *my_memcpy(void *dest, const void *src, unsigned short count)  
 104          {  
 105   1          unsigned char *pdest = (unsigned char *)dest;  
 106   1          const unsigned char *psrc  = (const unsigned char *)src;  
 107   1          unsigned short i;
 108   1          
 109   1          if(dest == NULL || src == NULL) { 
 110   2              return NULL;
 111   2          }
 112   1          
 113   1          if((pdest <= psrc) || (pdest > psrc + count)) {  
 114   2              for(i = 0; i < count; i ++) {  
C51 COMPILER V9.60.0.0   MCU_API                                                           03/08/2023 18:02:10 PAGE 3   

 115   3                  pdest[i] = psrc[i];  
 116   3              }
 117   2          }else {
 118   2              for(i = count; i > 0; i --) {  
 119   3                  pdest[i - 1] = psrc[i - 1];  
 120   3              }
 121   2          }  
 122   1          
 123   1          return dest;  
 124   1      }
 125          
 126          /**
 127           * @brief  å­—ç¬¦ä¸²æ‹·è´
 128           * @param[in] {dest} ç›®æ ‡åœ°å€
 129           * @param[in] {src} æºåœ°å€
 130           * @return æ•°æ®å¤„ç†å®Œåçš„æºåœ°å€
 131           */
 132          char *my_strcpy(char *dest, const char *src)  
 133          {
 134   1          char *p = dest;
 135   1          while(*src!='\0') {
 136   2              *dest++ = *src++;
 137   2          }
 138   1          *dest = '\0';
 139   1          return p;
 140   1      }
 141          
 142          /**
 143           * @brief  å­—ç¬¦ä¸²æ¯”è¾ƒ
 144           * @param[in] {s1} å­—ç¬¦ä¸² 1
 145           * @param[in] {s2} å­—ç¬¦ä¸² 2
 146           * @return å¤§å°æ¯”è¾ƒå€¼
 147           * -         0:s1=s2
 148           * -         <0:s1<s2
 149           * -         >0:s1>s2
 150           */
 151          int my_strcmp(char *s1 , char *s2)
 152          {
 153   1          while( *s1 && *s2 && *s1 == *s2 ) {
 154   2              s1++;
 155   2              s2++;
 156   2          }
 157   1          return *s1 - *s2;
 158   1      }
 159          
 160          /**
 161           * @brief  å°†intç±»å‹æ‹†åˆ†å››ä¸ªå­—èŠ‚
 162           * @param[in] {number} 4å­—èŠ‚åŸæ•°æ®
 163           * @param[out] {value} å¤„ç†å®Œæˆå4å­—èŠ‚æ•°æ®
 164           * @return Null
 165           */
 166          void int_to_byte(unsigned long number,unsigned char value[4])
 167          {
 168   1          value[0] = number >> 24;
 169   1          value[1] = number >> 16;
 170   1          value[2] = number >> 8;
 171   1          value[3] = number & 0xff;
 172   1      }
 173          
 174          /**
 175           * @brief  å°†4å­—èŠ‚åˆå¹¶ä¸º1ä¸ª32bitå˜é‡
 176           * @param[in] {value} 4å­—èŠ‚æ•°ç»„
C51 COMPILER V9.60.0.0   MCU_API                                                           03/08/2023 18:02:10 PAGE 4   

 177           * @return åˆå¹¶å®Œæˆåçš„32bitå˜é‡
 178           */
 179          unsigned long byte_to_int(const unsigned char value[4])
 180          {
 181   1          unsigned long nubmer = 0;
 182   1      
 183   1          nubmer = (unsigned long)value[0];
 184   1          nubmer <<= 8;
 185   1          nubmer |= (unsigned long)value[1];
 186   1          nubmer <<= 8;
 187   1          nubmer |= (unsigned long)value[2];
 188   1          nubmer <<= 8;
 189   1          nubmer |= (unsigned long)value[3];
 190   1          
 191   1          return nubmer;
 192   1      }
 193          
 194          
 195          /**
 196           * @brief  rawå‹dpæ•°æ®ä¸Šä¼ 
 197           * @param[in] {dpid} dpidå·
 198           * @param[in] {value} å½“å‰dpå€¼æŒ‡é’ˆ
 199           * @param[in] {len} æ•°æ®é•¿åº¦
 200           * @return Null
 201           * @note   Null
 202           */
 203          unsigned char mcu_dp_raw_update(unsigned char dpid,const unsigned char value[],unsigned short len)
 204          {
 205   1          unsigned short length = 0;
 206   1          
 207   1          if(stop_update_flag == ENABLE)
 208   1            return SUCCESS;
 209   1          //
 210   1          length = set_wifi_uart_byte(length,dpid);
 211   1          length = set_wifi_uart_byte(length,DP_TYPE_RAW);
 212   1          //
 213   1          length = set_wifi_uart_byte(length,len / 0x100);
 214   1          length = set_wifi_uart_byte(length,len % 0x100);
 215   1          //
 216   1          length = set_wifi_uart_buffer(length,(unsigned char *)value,len);
 217   1          
 218   1          wifi_uart_write_frame(STATE_UPLOAD_CMD,length);
 219   1          
 220   1          return SUCCESS;
 221   1      }
 222          
 223          /**
 224           * @brief  boolå‹dpæ•°æ®ä¸Šä¼ 
 225           * @param[in] {dpid} dpidå·
 226           * @param[in] {value} å½“å‰dpå€¼
 227           * @return Null
 228           * @note   Null
 229           */
 230          unsigned char mcu_dp_bool_update(unsigned char dpid,unsigned char value)
 231          {
 232   1          unsigned short length = 0;
 233   1          
 234   1          if(stop_update_flag == ENABLE)
 235   1              return SUCCESS;
 236   1          
 237   1          length = set_wifi_uart_byte(length,dpid);
 238   1          length = set_wifi_uart_byte(length,DP_TYPE_BOOL);
C51 COMPILER V9.60.0.0   MCU_API                                                           03/08/2023 18:02:10 PAGE 5   

 239   1          //
 240   1          length = set_wifi_uart_byte(length,0);
 241   1          length = set_wifi_uart_byte(length,1);
 242   1          //
 243   1          if(value == FALSE) {
 244   2              length = set_wifi_uart_byte(length,FALSE);
 245   2          }else {
 246   2              length = set_wifi_uart_byte(length,1);
 247   2          }
 248   1          
 249   1          wifi_uart_write_frame(STATE_UPLOAD_CMD,length);
 250   1          
 251   1          return SUCCESS;
 252   1      }
 253          
 254          /**
 255           * @brief  valueå‹dpæ•°æ®ä¸Šä¼ 
 256           * @param[in] {dpid} dpidå·
 257           * @param[in] {value} å½“å‰dpå€¼
 258           * @return Null
 259           * @note   Null
 260           */
 261          unsigned char mcu_dp_value_update(unsigned char dpid,unsigned long value)
 262          {
 263   1          unsigned short length = 0;
 264   1          
 265   1          if(stop_update_flag == ENABLE)
 266   1              return SUCCESS;
 267   1          
 268   1          length = set_wifi_uart_byte(length,dpid);
 269   1          length = set_wifi_uart_byte(length,DP_TYPE_VALUE);
 270   1          //
 271   1          length = set_wifi_uart_byte(length,0);
 272   1          length = set_wifi_uart_byte(length,4);
 273   1          //
 274   1          length = set_wifi_uart_byte(length,value >> 24);
 275   1          length = set_wifi_uart_byte(length,value >> 16);
 276   1          length = set_wifi_uart_byte(length,value >> 8);
 277   1          length = set_wifi_uart_byte(length,value & 0xff);
 278   1          
 279   1          wifi_uart_write_frame(STATE_UPLOAD_CMD,length);
 280   1          
 281   1          return SUCCESS;
 282   1      }
 283          
 284          /**
 285           * @brief  stringå‹dpæ•°æ®ä¸Šä¼ 
 286           * @param[in] {dpid} dpidå·
 287           * @param[in] {value} å½“å‰dpå€¼æŒ‡é’ˆ
 288           * @param[in] {len} æ•°æ®é•¿åº¦
 289           * @return Null
 290           * @note   Null
 291           */
 292          unsigned char mcu_dp_string_update(unsigned char dpid,const unsigned char value[],unsigned short len)
 293          {
 294   1          unsigned short length = 0;
 295   1          
 296   1          if(stop_update_flag == ENABLE)
 297   1              return SUCCESS;
 298   1          //
 299   1          length = set_wifi_uart_byte(length,dpid);
 300   1          length = set_wifi_uart_byte(length,DP_TYPE_STRING);
C51 COMPILER V9.60.0.0   MCU_API                                                           03/08/2023 18:02:10 PAGE 6   

 301   1          //
 302   1          length = set_wifi_uart_byte(length,len / 0x100);
 303   1          length = set_wifi_uart_byte(length,len % 0x100);
 304   1          //
 305   1          length = set_wifi_uart_buffer(length,(unsigned char *)value,len);
 306   1          
 307   1          wifi_uart_write_frame(STATE_UPLOAD_CMD,length);
 308   1          
 309   1          return SUCCESS;
 310   1      }
 311          
 312          /**
 313           * @brief  enumå‹dpæ•°æ®ä¸Šä¼ 
 314           * @param[in] {dpid} dpidå·
 315           * @param[in] {value} å½“å‰dpå€¼
 316           * @return Null
 317           * @note   Null
 318           */
 319          unsigned char mcu_dp_enum_update(unsigned char dpid,unsigned char value)
 320          {
 321   1          unsigned short length = 0;
 322   1          
 323   1          if(stop_update_flag == ENABLE)
 324   1              return SUCCESS;
 325   1          
 326   1          length = set_wifi_uart_byte(length,dpid);
 327   1          length = set_wifi_uart_byte(length,DP_TYPE_ENUM);
 328   1          //
 329   1          length = set_wifi_uart_byte(length,0);
 330   1          length = set_wifi_uart_byte(length,1);
 331   1          //
 332   1          length = set_wifi_uart_byte(length,value);
 333   1          
 334   1          wifi_uart_write_frame(STATE_UPLOAD_CMD,length);
 335   1          
 336   1          return SUCCESS;
 337   1      }
 338          
 339          /**
 340           * @brief  faultå‹dpæ•°æ®ä¸Šä¼ 
 341           * @param[in] {dpid} dpidå·
 342           * @param[in] {value} å½“å‰dpå€¼
 343           * @return Null
 344           * @note   Null
 345           */
 346          unsigned char mcu_dp_fault_update(unsigned char dpid,unsigned long value)
 347          {
 348   1          unsigned short length = 0;
 349   1           
 350   1          if(stop_update_flag == ENABLE)
 351   1              return SUCCESS;
 352   1          
 353   1          length = set_wifi_uart_byte(length,dpid);
 354   1          length = set_wifi_uart_byte(length,DP_TYPE_BITMAP);
 355   1          //
 356   1          length = set_wifi_uart_byte(length,0);
 357   1          
 358   1          if((value | 0xff) == 0xff) {
 359   2              length = set_wifi_uart_byte(length,1);
 360   2              length = set_wifi_uart_byte(length,value);
 361   2          }else if((value | 0xffff) == 0xffff) {
 362   2              length = set_wifi_uart_byte(length,2);
C51 COMPILER V9.60.0.0   MCU_API                                                           03/08/2023 18:02:10 PAGE 7   

 363   2              length = set_wifi_uart_byte(length,value >> 8);
 364   2              length = set_wifi_uart_byte(length,value & 0xff);
 365   2          }else {
 366   2              length = set_wifi_uart_byte(length,4);
 367   2              length = set_wifi_uart_byte(length,value >> 24);
 368   2              length = set_wifi_uart_byte(length,value >> 16);
 369   2              length = set_wifi_uart_byte(length,value >> 8);
 370   2              length = set_wifi_uart_byte(length,value & 0xff);
 371   2          }    
 372   1          
 373   1          wifi_uart_write_frame(STATE_UPLOAD_CMD,length);
 374   1      
 375   1          return SUCCESS;
 376   1      }
 377          
 378          /**
 379           * @brief  mcuè·å–boolå‹ä¸‹å‘dpå€¼
 380           * @param[in] {value} dpæ•°æ®ç¼“å†²åŒºåœ°å€
 381           * @param[in] {len} dpæ•°æ®é•¿åº¦
 382           * @return å½“å‰dpå€¼
 383           * @note   Null
 384           */
 385          unsigned char mcu_get_dp_download_bool(const unsigned char value[],unsigned short len)
 386          {
 387   1          return(value[0]);
 388   1      }
*** WARNING C280 IN LINE 385 OF Drivers\Protocol\WIFI_Tuya\mcu_api.c: 'len': unreferenced local variable
 389          
 390          /**
 391           * @brief  mcuè·å–enumå‹ä¸‹å‘dpå€¼
 392           * @param[in] {value} dpæ•°æ®ç¼“å†²åŒºåœ°å€
 393           * @param[in] {len} dpæ•°æ®é•¿åº¦
 394           * @return å½“å‰dpå€¼
 395           * @note   Null
 396           */
 397          unsigned char mcu_get_dp_download_enum(const unsigned char value[],unsigned short len)
 398          {
 399   1          return(value[0]);
 400   1      }
*** WARNING C280 IN LINE 397 OF Drivers\Protocol\WIFI_Tuya\mcu_api.c: 'len': unreferenced local variable
 401          
 402          /**
 403           * @brief  mcuè·å–valueå‹ä¸‹å‘dpå€¼
 404           * @param[in] {value} dpæ•°æ®ç¼“å†²åŒºåœ°å€
 405           * @param[in] {len} dpæ•°æ®é•¿åº¦
 406           * @return å½“å‰dpå€¼
 407           * @note   Null
 408           */
 409          unsigned long mcu_get_dp_download_value(const unsigned char value[],unsigned short len)
 410          {
 411   1          return(byte_to_int(value));
 412   1      }
*** WARNING C280 IN LINE 409 OF Drivers\Protocol\WIFI_Tuya\mcu_api.c: 'len': unreferenced local variable
 413          
 414          /**
 415           * @brief  ä¸²å£æ¥æ”¶æ•°æ®æš‚å­˜å¤„ç†
 416           * @param[in] {value} ä¸²å£æ”¶åˆ°çš„1å­—èŠ‚æ•°æ®
 417           * @return Null
 418           * @note   åœ¨MCUä¸²å£å¤„ç†å‡½æ•°ä¸­è°ƒç”¨è¯¥å‡½æ•°,å¹¶å°†æ¥æ”¶åˆ°çš„æ•°æ®ä½œä¸ºå‚æ•°ä¼ å…¥
 419           */
 420          void uart_receive_input(unsigned char value)
 421          {
C51 COMPILER V9.60.0.0   MCU_API                                                           03/08/2023 18:02:10 PAGE 8   

 422   1          //#error "è¯·åœ¨ä¸²å£æ¥æ”¶ä¸­æ–­ä¸­è°ƒç”¨uart_receive_input(value),ä¸²å£æ•°æ®ç”±MCU_SDKå¤„ç†,ç”¨æ
             -ˆ·è¯·å‹¿å†å¦è¡Œå¤„ç†,å®Œæˆååˆ é™¤è¯¥è¡Œ" 
 423   1          if(1 == queue_out - queue_in) {
 424   2              //æ•°æ®é˜Ÿåˆ—æ»¡
 425   2          }else if((queue_in > queue_out) && ((queue_in - queue_out) >= sizeof(wifi_uart_rx_buf))) {
 426   2              //æ•°æ®é˜Ÿåˆ—æ»¡
 427   2          }else {
 428   2              //é˜Ÿåˆ—ä¸æ»¡
 429   2              if(queue_in >= (unsigned char *)(wifi_uart_rx_buf + sizeof(wifi_uart_rx_buf))) {
 430   3                  queue_in = (unsigned char *)(wifi_uart_rx_buf);
 431   3              }
 432   2              
 433   2              *queue_in ++ = value;
 434   2          }
 435   1      }
 436          
 437          /**
 438           * @brief  wifiä¸²å£æ•°æ®å¤„ç†æœåŠ¡
 439           * @param  Null
 440           * @return Null
 441           * @note   åœ¨MCUä¸»å‡½æ•°whileå¾ªç¯ä¸­è°ƒç”¨è¯¥å‡½æ•°
 442           */
 443          void wifi_uart_service(void)
 444          {
 445   1          //#error "è¯·ç›´æ¥åœ¨mainå‡½æ•°çš„while(1){}ä¸­æ·»åŠ wifi_uart_service(),è°ƒç”¨è¯¥å‡½æ•°ä¸è¦åŠ ä»»ä
             -½•æ¡ä»¶åˆ¤æ–­,å®Œæˆååˆ é™¤è¯¥è¡Œ"
 446   1          static unsigned short rx_in = 0;
 447   1          unsigned short offset = 0;
 448   1          unsigned short rx_value_len = 0;             //æ•°æ®å¸§é•¿åº¦
 449   1          
 450   1          while((rx_in < sizeof(wifi_data_process_buf)) && get_queue_total_data() > 0) {
 451   2              wifi_data_process_buf[rx_in ++] = Queue_Read_Byte();
 452   2          }
 453   1          
 454   1          if(rx_in < PROTOCOL_HEAD)
 455   1              return;
 456   1          
 457   1          while((rx_in - offset) >= PROTOCOL_HEAD) {
 458   2              if(wifi_data_process_buf[offset + HEAD_FIRST] != FRAME_FIRST) {
 459   3                  offset ++;
 460   3                  continue;
 461   3              }
 462   2              
 463   2              if(wifi_data_process_buf[offset + HEAD_SECOND] != FRAME_SECOND) {
 464   3                  offset ++;
 465   3                  continue;
 466   3              }  
 467   2              
 468   2              if(wifi_data_process_buf[offset + PROTOCOL_VERSION] != MCU_RX_VER) {
 469   3                  offset += 2;
 470   3                  continue;
 471   3              }      
 472   2              
 473   2              rx_value_len = wifi_data_process_buf[offset + LENGTH_HIGH] * 0x100 + wifi_data_process_buf[offset 
             -+ LENGTH_LOW] + PROTOCOL_HEAD;
 474   2              if(rx_value_len > sizeof(wifi_data_process_buf) + PROTOCOL_HEAD) {
 475   3                  offset += 3;
 476   3                  continue;
 477   3              }
 478   2              
 479   2              if((rx_in - offset) < rx_value_len) {
 480   3                  break;
C51 COMPILER V9.60.0.0   MCU_API                                                           03/08/2023 18:02:10 PAGE 9   

 481   3              }
 482   2              
 483   2              //æ•°æ®æ¥æ”¶å®Œæˆ
 484   2              if(get_check_sum((unsigned char *)wifi_data_process_buf + offset,rx_value_len - 1) != wifi_data_pr
             -ocess_buf[offset + rx_value_len - 1]) {
 485   3                  //æ ¡éªŒå‡ºé”™
 486   3                  //printf("crc error (crc:0x%X  but _data:0x%X)\r\n",get_check_sum((unsigned char *)wifi_data_p
             -rocess_buf + offset,rx_value_len - 1),wifi_data_process_buf[offset + rx_value_len - 1]);
 487   3                  offset += 3;
 488   3                  continue;
 489   3              }
 490   2              
 491   2              data_handle(offset);
 492   2              offset += rx_value_len;
 493   2          }//end while
 494   1      
 495   1          rx_in -= offset;
 496   1          if(rx_in > 0) {
 497   2              my_memcpy(wifi_data_process_buf,wifi_data_process_buf + offset,rx_in);
 498   2          }
 499   1      }
 500          
 501          /**
 502           * @brief  åè®®ä¸²å£åˆå§‹åŒ–å‡½æ•°
 503           * @param  Null
 504           * @return Null
 505           * @note   åœ¨MCUåˆå§‹åŒ–ä»£ç ä¸­è°ƒç”¨è¯¥å‡½æ•°
 506           */
 507          void wifi_protocol_init(void)
 508          {
 509   1          //#error " è¯·åœ¨mainå‡½æ•°ä¸­æ·»åŠ wifi_protocol_init()å®Œæˆwifiåè®®åˆå§‹åŒ–,å¹¶åˆ é™¤è¯¥è¡Œ"
 510   1          queue_in = (unsigned char *)wifi_uart_rx_buf;
 511   1          queue_out = (unsigned char *)wifi_uart_rx_buf;
 512   1          
 513   1          stop_update_flag = DISABLE;
 514   1          
 515   1      #ifndef WIFI_CONTROL_SELF_MODE
 516   1          wifi_work_state = WIFI_SATE_UNKNOW;
 517   1      #endif
 518   1      }
 519          
 520          
 521          /**
 522           * @brief  è®°å½•å‹æ•°æ®ç»„åˆä¸ŠæŠ¥
 523           * @param[in] {time} æ—¶é—´æ•°æ®é•¿åº¦7ï¼Œé¦–å­—èŠ‚è¡¨ç¤ºæ˜¯å¦ä¼ è¾“æ ‡å¿—ä½ï¼Œå…¶ä½™ä¾æ¬¡ä¸ºå¹´ã€æœˆ
             -ã€æ—¥ã€æ—¶ã€åˆ†ã€ç§’
 524           * @param[in] {dp_node} dpæ•°æ®ç»“æ„ï¼Œéœ€è¦åœ¨è°ƒç”¨æ­¤å‡½æ•°ä¹‹å‰ï¼Œåˆ›å»ºä¸€ä¸ªæ­¤ç»“æ„ä½“ç±»å‹çš
             -„æ•°ç»„ï¼Œæ•°ç»„é•¿åº¦ä¸ºdpä¸ªæ•°ï¼Œ
 525                                              å°†è®°å½•å‹dpæ•°æ®ç¼“å­˜åˆ°æ­¤ç»“æ„ä½“ä¸­ï¼Œdpå€¼éœ€è¦æ ¹æ®dpçš„æ
             -•°æ®ç±»å‹ï¼Œå­˜å…¥åˆ°å¯¹åº”ç±»å‹çš„ç»“æ„ä½“æˆå‘˜ä¸­
 526           * @param[in] {dp_node_num} dpä¸ªæ•°
 527           * @return ç»“æœ
 528           * -           0(ERROR): å¤±è´¥
 529           * -           1(SUCCESS): æˆåŠŸ
 530           * @note   MCUéœ€è¦è‡ªè¡Œè°ƒç”¨è¯¥å‡½æ•°
 531           */
 532          unsigned char dp_record_combine_update(unsigned char time[], t_DP_NODE dp_node[], unsigned char dp_node_nu
             -m)
 533          {
 534   1          unsigned short length = 0;
 535   1          unsigned char i = 0;
 536   1          unsigned char dp_type;
C51 COMPILER V9.60.0.0   MCU_API                                                           03/08/2023 18:02:10 PAGE 10  

 537   1          
 538   1          if(stop_update_flag == ENABLE)
 539   1              return ERROR;
 540   1          
 541   1          //local_time
 542   1          length = set_wifi_uart_buffer(length,(unsigned char *)time,7);
 543   1          
 544   1          for(i = 0; i < dp_node_num; i++) {
 545   2              if(SUCCESS != get_dp_type(dp_node[i].dp_id, &dp_type)) {
 546   3                  //åœ¨æ­¤æ·»åŠ æç¤ºä¿¡æ¯ï¼šdpidä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥
 547   3                  continue;
 548   3              }
 549   2              
 550   2              length = set_wifi_uart_byte(length, dp_node[i].dp_id);
 551   2              length = set_wifi_uart_byte(length, dp_type);
 552   2              
 553   2              switch(dp_type) {
 554   3                  case DP_TYPE_RAW:{
 555   4                      length = set_wifi_uart_byte(length, (dp_node[i].dp_len >> 8) & 0xff);
 556   4                      length = set_wifi_uart_byte(length, dp_node[i].dp_len & 0xff);
 557   4                      length = set_wifi_uart_buffer(length, dp_node[i].dp_raw_val ,dp_node[i].dp_len);
 558   4                  }
 559   3                  break;
 560   3                  
 561   3                  case DP_TYPE_BOOL:{
 562   4                      length = set_wifi_uart_byte(length, 0);
 563   4                      length = set_wifi_uart_byte(length, 1);
 564   4                      length = set_wifi_uart_byte(length, dp_node[i].dp_bool_val);
 565   4                  }
 566   3                  break;
 567   3                  
 568   3                  case DP_TYPE_VALUE:{
 569   4                      length = set_wifi_uart_byte(length, 0);
 570   4                      length = set_wifi_uart_byte(length, 4);
 571   4                      length = set_wifi_uart_byte(length, (dp_node[i].dp_value_val >> 24) & 0xff);
 572   4                      length = set_wifi_uart_byte(length, (dp_node[i].dp_value_val >> 16) & 0xff);
 573   4                      length = set_wifi_uart_byte(length, (dp_node[i].dp_value_val >> 8) & 0xff);
 574   4                      length = set_wifi_uart_byte(length, dp_node[i].dp_value_val & 0xff);
 575   4                  }
 576   3                  break;
 577   3                  
 578   3                  case DP_TYPE_STRING:{
 579   4                      length = set_wifi_uart_byte(length, (dp_node[i].dp_len >> 8) & 0xff);
 580   4                      length = set_wifi_uart_byte(length, dp_node[i].dp_len & 0xff);
 581   4                      length = set_wifi_uart_buffer(length, dp_node[i].dp_str_val ,dp_node[i].dp_len);
 582   4                  }
 583   3                  break;
 584   3                  
 585   3                  case DP_TYPE_ENUM:{
 586   4                      length = set_wifi_uart_byte(length, 0);
 587   4                      length = set_wifi_uart_byte(length, 1);
 588   4                      length = set_wifi_uart_byte(length, dp_node[i].dp_enum_val);
 589   4                  }
 590   3                  break;
 591   3                  
 592   3                  case DP_TYPE_BITMAP:{
 593   4                      length = set_wifi_uart_byte(length, 0);
 594   4      
 595   4                      if(1 == dp_node[i].dp_len) {
 596   5                          length = set_wifi_uart_byte(length, dp_node[i].dp_len);
 597   5                          length = set_wifi_uart_byte(length, dp_node[i].dp_fault_bitmap);
 598   5                      }else if(2 == dp_node[i].dp_len) {
C51 COMPILER V9.60.0.0   MCU_API                                                           03/08/2023 18:02:10 PAGE 11  

 599   5                          length = set_wifi_uart_byte(length, dp_node[i].dp_len);
 600   5                          length = set_wifi_uart_byte(length, (dp_node[i].dp_fault_bitmap >> 8) & 0xff);
 601   5                          length = set_wifi_uart_byte(length, dp_node[i].dp_fault_bitmap & 0xff);
 602   5                      }else {
 603   5                          length = set_wifi_uart_byte(length, 4);
 604   5                          length = set_wifi_uart_byte(length, (dp_node[i].dp_fault_bitmap >> 24) & 0xff);
 605   5                          length = set_wifi_uart_byte(length, (dp_node[i].dp_fault_bitmap >> 16) & 0xff);
 606   5                          length = set_wifi_uart_byte(length, (dp_node[i].dp_fault_bitmap >> 8) & 0xff);
 607   5                          length = set_wifi_uart_byte(length, dp_node[i].dp_fault_bitmap & 0xff);
 608   5                      }
 609   4                  }
 610   3                  break;
 611   3                  
 612   3                  default:break;
 613   3              }
 614   2          }
 615   1          
 616   1          wifi_uart_write_frame(STATE_RC_UPLOAD_CMD,length);
 617   1          
 618   1          return SUCCESS;
 619   1      }
 620          
 621          #ifndef WIFI_CONTROL_SELF_MODE
 622          /**
 623           * @brief  MCUè·å–å¤ä½wifiæˆåŠŸæ ‡å¿—
 624           * @param  Null
 625           * @return å¤ä½æ ‡å¿—
 626           * -           0(RESET_WIFI_ERROR):å¤±è´¥
 627           * -           1(RESET_WIFI_SUCCESS):æˆåŠŸ
 628           * @note   1:MCUä¸»åŠ¨è°ƒç”¨mcu_reset_wifi()åè°ƒç”¨è¯¥å‡½æ•°è·å–å¤ä½çŠ¶æ€
 629           *         2:å¦‚æœä¸ºæ¨¡å—è‡ªå¤„ç†æ¨¡å¼,MCUæ— é¡»è°ƒç”¨è¯¥å‡½æ•°
 630           */
 631          unsigned char mcu_get_reset_wifi_flag(void)
 632          {
 633   1          return reset_wifi_flag;
 634   1      }
 635          
 636          /**
 637           * @brief  MCUä¸»åŠ¨é‡ç½®wifiå·¥ä½œæ¨¡å¼
 638           * @param  Null
 639           * @return Null
 640           * @note   1:MCUä¸»åŠ¨è°ƒç”¨,é€šè¿‡mcu_get_reset_wifi_flag()å‡½æ•°è·å–é‡ç½®wifiæ˜¯å¦æˆåŠŸ
 641           *         2:å¦‚æœä¸ºæ¨¡å—è‡ªå¤„ç†æ¨¡å¼,MCUæ— é¡»è°ƒç”¨è¯¥å‡½æ•°
 642           */
 643          void mcu_reset_wifi(void)
 644          {
 645   1          reset_wifi_flag = RESET_WIFI_ERROR;
 646   1          
 647   1          wifi_uart_write_frame(WIFI_RESET_CMD, 0);
 648   1      }
 649          
 650          /**
 651           * @brief  è·å–è®¾ç½®wifiçŠ¶æ€æˆåŠŸæ ‡å¿—
 652           * @param  Null
 653           * @return wifimode flag
 654           * -           0(SET_WIFICONFIG_ERROR):å¤±è´¥
 655           * -           1(SET_WIFICONFIG_SUCCESS):æˆåŠŸ
 656           * @note   1:MCUä¸»åŠ¨è°ƒç”¨mcu_set_wifi_mode()åè°ƒç”¨è¯¥å‡½æ•°è·å–å¤ä½çŠ¶æ€
 657           *         2:å¦‚æœä¸ºæ¨¡å—è‡ªå¤„ç†æ¨¡å¼,MCUæ— é¡»è°ƒç”¨è¯¥å‡½æ•°
 658           */
 659          unsigned char mcu_get_wifimode_flag(void)
 660          {
C51 COMPILER V9.60.0.0   MCU_API                                                           03/08/2023 18:02:10 PAGE 12  

 661   1          return set_wifimode_flag;
 662   1      }
 663          
 664          /**
 665           * @brief  MCUè®¾ç½®wifiå·¥ä½œæ¨¡å¼
 666           * @param[in] {mode} è¿›å…¥çš„æ¨¡å¼
 667           * @ref        0(SMART_CONFIG):è¿›å…¥smartconfigæ¨¡å¼
 668           * @ref        1(AP_CONFIG):è¿›å…¥APæ¨¡å¼
 669           * @return Null
 670           * @note   1:MCUä¸»åŠ¨è°ƒç”¨
 671           *         2:æˆåŠŸå,å¯åˆ¤æ–­set_wifi_config_stateæ˜¯å¦ä¸ºTRUE;TRUEè¡¨ç¤ºä¸ºè®¾ç½®wifiå·¥ä½œæ¨¡å¼æˆå
             -ŠŸ
 672           *         3:å¦‚æœä¸ºæ¨¡å—è‡ªå¤„ç†æ¨¡å¼,MCUæ— é¡»è°ƒç”¨è¯¥å‡½æ•°
 673           */
 674          void mcu_set_wifi_mode(unsigned char mode)
 675          {
 676   1          unsigned char length = 0;
 677   1          
 678   1          set_wifimode_flag = SET_WIFICONFIG_ERROR;
 679   1          
 680   1          length = set_wifi_uart_byte(length, mode);
 681   1          
 682   1          wifi_uart_write_frame(WIFI_MODE_CMD, length);
 683   1      }
 684          
 685          /**
 686           * @brief  MCUä¸»åŠ¨è·å–å½“å‰wifiå·¥ä½œçŠ¶æ€
 687           * @param  Null
 688           * @return wifi work state
 689           * -          SMART_CONFIG_STATE: smartconfigé…ç½®çŠ¶æ€
 690           * -          AP_STATE: APé…ç½®çŠ¶æ€
 691           * -          WIFI_NOT_CONNECTED: WIFIé…ç½®æˆåŠŸä½†æœªè¿ä¸Šè·¯ç”±å™¨
 692           * -          WIFI_CONNECTED: WIFIé…ç½®æˆåŠŸä¸”è¿ä¸Šè·¯ç”±å™¨
 693           * -          WIFI_CONN_CLOUD: WIFIå·²ç»è¿æ¥ä¸Šäº‘æœåŠ¡å™¨
 694           * -          WIFI_LOW_POWER: WIFIå¤„äºä½åŠŸè€—æ¨¡å¼
 695           * -          SMART_AND_AP_STATE: WIFI smartconfig&AP æ¨¡å¼
 696           * @note   å¦‚æœä¸ºæ¨¡å—è‡ªå¤„ç†æ¨¡å¼,MCUæ— é¡»è°ƒç”¨è¯¥å‡½æ•°
 697           */
 698          unsigned char mcu_get_wifi_work_state(void)
 699          {
 700   1          return wifi_work_state;
 701   1      }
 702          #endif
 703          
 704          #ifdef SUPPORT_MCU_RTC_CHECK
              /**
               * @brief  MCUè·å–æœ¬åœ°æ—¶é—´,ç”¨äºæ ¡å¯¹æœ¬åœ°æ—¶é’Ÿ
               * @param  Null
               * @return Null
               * @note   MCUä¸»åŠ¨è°ƒç”¨å®Œæˆååœ¨ mcu_write_rtctime å‡½æ•°å†…æ ¡å¯¹rtcæ—¶é’Ÿ
               */
              void mcu_get_system_time(void)
              {
                  wifi_uart_write_frame(GET_LOCAL_TIME_CMD,0);
              }
              #endif
 716          
 717          #ifdef SUPPORT_GREEN_TIME
 718          /**
 719           * @brief  MCUè·å–æ ¼æ—æ—¶é—´,ç”¨äºæ ¡å¯¹æœ¬åœ°æ—¶é’Ÿ
 720           * @param  Null
 721           * @return Null
C51 COMPILER V9.60.0.0   MCU_API                                                           03/08/2023 18:02:10 PAGE 13  

 722           * @note   MCUä¸»åŠ¨è°ƒç”¨å®Œæˆååœ¨ mcu_write_gltime å‡½æ•°å†…è®°å½•å¹¶è®¡ç®—æ ¼æ—æ—¶é—´ï¼Œ
 723                     ç”¨äºé—¨é”ç±»æ—¶é—´æˆ³æ ¡éªŒ
 724           */
 725          void mcu_get_gelin_time(void)
 726          {
 727   1          wifi_uart_write_frame(GET_GL_TIME_CMD,0);
 728   1      }
 729          #endif
 730          
 731          #ifdef WIFI_TEST_ENABLE
 732          /**
 733           * @brief  mcuå‘èµ·wifiåŠŸèƒ½æµ‹è¯•
 734           * @param  Null
 735           * @return Null
 736           * @note   MCUéœ€è¦è‡ªè¡Œè°ƒç”¨è¯¥åŠŸèƒ½
 737           */
 738          void mcu_start_wifitest(void)
 739          {
 740   1          wifi_uart_write_frame(WIFI_TEST_CMD,0);
 741   1      }
 742          #endif
 743          
 744          /**
 745           * @brief  MCUè¯·æ±‚wifiå›ºä»¶å‡çº§
 746           * @param  Null
 747           * @return Null
 748           * @note   MCUä¸»åŠ¨è°ƒç”¨å®Œæˆååœ¨ wifi_update_handle å‡½æ•°å†…å¯è·å–å‡çº§å½“å‰çŠ¶æ€
 749           */
 750          void wifi_update_request(void)
 751          { 
 752   1          wifi_uart_write_frame(WIFI_UG_REQ_CMD, 0);
 753   1      }
 754          
 755          #ifdef DP_CACHE_SUPPORT
              /**
               * @brief  è·å–dpç¼“å­˜æŒ‡ä»¤
               * @param[in] {table} dpè¡¨ï¼Œå­˜æ”¾ç”¨æˆ·éœ€è¦æŸ¥è¯¢çš„dpï¼Œå¦‚æœç”¨æˆ·éœ€è¦æŸ¥è¯¢æ‰€æœ‰dpï¼Œåˆ™tableç
             -›´æ¥å¡«NULLå³å¯
               * @param[in] {dp_num} éœ€è¦æŸ¥è¯¢çš„dpçš„æ•°é‡,å¦‚æœéœ€è¦æŸ¥è¯¢æ‰€æœ‰dpï¼Œåˆ™dp_numå¡«0å³å¯
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œè°ƒç”¨è¯¥åŠŸèƒ½
               */
              void get_dp_cache(unsigned char *table,unsigned char dp_num)
              {
                  unsigned char length = 0;
                  
                  length = set_wifi_uart_byte(length,dp_num);
                  if(table != NULL) {
                      length = set_wifi_uart_buffer(length,table, dp_num);
                  }
                  wifi_uart_write_frame(GET_DP_CACHE_CMD,length);
              }
              #endif
 774          
 775          #ifdef REPORTED_MCU_SN_ENABLE
              /**
               * @brief  MCUä¸ŠæŠ¥SN
               * @param[in] {sn} SNå·
               * @param[in] {sn_len} SNå·é•¿åº¦
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œè°ƒç”¨åï¼Œå¯åœ¨ mcu_sn_updata_result å‡½æ•°ä¸­å¯¹ç»“æœè¿›è¡Œå¤„ç†
               */
C51 COMPILER V9.60.0.0   MCU_API                                                           03/08/2023 18:02:10 PAGE 14  

              void mcu_sn_updata(unsigned char sn[],unsigned char sn_len)
              {
                  unsigned char length = 0;
                  
                  length = set_wifi_uart_byte(length,sn_len);
                  length = set_wifi_uart_buffer(length,sn,sn_len);
                  
                  wifi_uart_write_frame(REPORTED_MCU_SN_CMD,length);
              }
              #endif
 793          
 794          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3316    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2     106
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)

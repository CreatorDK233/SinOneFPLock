C51 COMPILER V9.60.0.0   IAP_INIT                                                          05/09/2023 14:53:11 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE IAP_INIT
OBJECT MODULE PLACED IN .\Objects\IAP_Init.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Drivers\Lib\c\IAP_Init.c LARGE OMF2 OPTIMIZE(9,SPEED) BROWSE INCDIR(.\Dr
                    -ivers\Lib\c;.\Drivers\Lib\H;.\Drivers\Lib\IAP_Lib;.\Drivers\Lib\TouchKey_lib;.\Drivers\Physical;.\Drivers\Protocol;.\Sof
                    -twares\Application;.\Softwares\Basic;.\Softwares\ModuleLogic) DEBUG PRINT(.\Listings\IAP_Init.lst) TABS(2) OBJECT(.\Obje
                    -cts\IAP_Init.obj)

line level    source

   1          #include "Function_Init.H"
   2          #include "IAP_Option_EW.h"
   3          unsigned char code* POINT;       //该指针指向0x0000
   4          
   5          #define IAP_APROM 0x00
   6          #define IAP_UniqueID 0x01
   7          #define IAP_EEPROM 0x02
   8          #define IAP_LDROM 0x03
   9          
  10          //unsigned char IAP_Read(unsigned long IAP_IapAddr, unsigned char area);
  11          
  12          void IAP_Test(void)
  13          {
  14   1        unsigned char IapReadData1,IapReadData2;        //定义储存读出数据的变量
  15   1        
  16   1        IAP_CodeSectorEraseOption(0xFFFE);      //往CODE 0x1FFFE地址块擦
  17   1        IAP_CodeProgramByteOption(0xFFFE, 0x55);      //往CODE 0x1FFFE地址写入0x55
  18   1        IapReadData1 = IAP_Read(0xFFFE, IAP_APROM); //读取CODE 0x1FFFE地址数据
  19   1        
  20   1        IAP_EEPROMSectorEraseOption(0x1000);      //往EEPROM 0x1000地址块擦
  21   1        IAP_EEPROMProgramByteOption(0x1000, 0xAA);      //往EEPROM 0x1000地址写入0xAA
  22   1        IapReadData2 = IAP_Read(0x1000, IAP_EEPROM);    //读取EEPROM 0x1000地址数据
  23   1        while(1)
  24   1        {
  25   2          if((IapReadData1 == 0x55) && (IapReadData2 == 0xAA))
  26   2          {
  27   3            P02 = ~P02;
  28   3          }
  29   2          else
  30   2          {
  31   3            P03 = ~P03;
  32   3          }
  33   2        }
  34   1      }
  35          
  36          /**************************************************
  37          *函数名称：unsigned char IAP_Read(unsigned long Add,unsigned char ADER)
  38          *函数功能：单Byte读取
  39          *入口参数：Add ：需要擦除的地址(0X00~0X1FFFF（FLASH物理地址）
  40          *         Data：要写入的Byte,ADER:操作对象 APROM为00,EEPROM为02
  41          *出口参数：void
  42          **************************************************/
  43          unsigned char IAP_Read(unsigned long Add, unsigned char Iapade)
  44          {
  45   1        unsigned char IAP_IapData;
  46   1        //保存ROMBNK、IAPADE、EA
  47   1        unsigned char tempADER = IAPADE;
  48   1        unsigned char tempEA = EA;
  49   1      
  50   1        unsigned char code* point = 0;
  51   1      
  52   1        EA = 0;//关闭中断
C51 COMPILER V9.60.0.0   IAP_INIT                                                          05/09/2023 14:53:11 PAGE 2   

  53   1      
  54   1        IAPADE = Iapade;
  55   1      
  56   1        IAP_IapData = *(point + Add);
  57   1      
  58   1        //操作结束恢复ROMBNK、IAPADE、EA，避免MOVC位置出错
  59   1        IAPADE = tempADER;
  60   1        EA = tempEA;
  61   1      
  62   1        return IAP_IapData;
  63   1      
  64   1      }
  65          
  66          
  67          
  68          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    160    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2       7
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.60.0.0   USART                                                             04/19/2023 14:20:21 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE USART
OBJECT MODULE PLACED IN .\Objects\usart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Drivers\Physical\usart.c LARGE OMF2 OPTIMIZE(9,SPEED) BROWSE INCDIR(.\Dr
                    -ivers\Lib\c;.\Drivers\Lib\H;.\Drivers\Lib\IAP_Lib;.\Drivers\Lib\TouchKey_lib;.\Drivers\Physical;.\Drivers\Protocol;.\Sof
                    -twares\Application;.\Softwares\Basic;.\Softwares\ModuleLogic) DEBUG PRINT(.\Listings\usart.lst) TABS(2) OBJECT(.\Objects
                    -\usart.obj)

line level    source

   1          #include "usart.h"
   2          #include "ISR.h"
   3          #include "SC95F861xB_C.H"
   4          
   5          //选择三合一模块：
   6          #define  USCI2   2
   7          #define  USCI3   3
   8          #define  USCI4   4
   9          #define  USCI5   5
  10          
  11          //选择三合一模式：
  12          #define  UartX   0
  13          #define  TWIX    1
  14          #define  SPIX    2
  15          
  16          uint16_t uart3_rx_count=0;
  17          uint8_t xdata Uart3_Rx[UART3_MAX_LEN];
  18          bit Uart2SendFlag = 0;    //Uart2发送中断标志位
  19          bit Uart2ReceiveFlag = 0; //Uart2接收中断标志位
  20          bit Uart3SendFlag = 0;
  21          bit Uart3ReceiveFlag = 0;
  22          
  23          #define   Choose_SSI2   SSIxx_Select = USCI2; /*SSIxx_Mode = UartX;*/ USXINX = SSIxx_Select
  24          #define   Choose_SSI3   SSIxx_Select = USCI3; /*SSIxx_Mode = UartX;*/ USXINX = SSIxx_Select
  25          
  26          #define   Uart2_send_OK   while(!Uart2SendFlag); Uart2SendFlag = 0//while( !(USXCON0 & 0x02) ); USXCON0 |= 0
             -x02
  27          #define   Uart3_send_OK   while(!Uart3SendFlag); Uart3SendFlag = 0//while( !(USXCON0 & 0x02) ); USXCON0 |= 0
             -x02
  28          
  29          #define   USXINX_Clear  //USXINX = 0
  30          //uart2,FPM
  31          void MX_UART2_Init(void)
  32          {
  33   1        Choose_SSI2;
  34   1        UARTX_Init(32, 57600);
  35   1        //IP2 |= 0x02;
  36   1        USXINX_Clear;
  37   1      }
  38          void MX_UART2_DeInit(void)
  39          {
  40   1        Choose_SSI2;
  41   1        TMCON &= 0x3F;
  42   1        IE2 &= ~0x02;  
  43   1        //IP2 &= ~0x02;
  44   1        USXINX_Clear;
  45   1      }
  46          //uart3
  47          void MX_UART3_Init(void)
  48          {
  49   1        Choose_SSI3;
  50   1        uart3_rx_count=0;
C51 COMPILER V9.60.0.0   USART                                                             04/19/2023 14:20:21 PAGE 2   

  51   1        UARTX_Init(32, 115200);
  52   1        USXINX_Clear;
  53   1      }
  54          void MX_UART3_DeInit(void)
  55          {
  56   1        Choose_SSI3;
  57   1        TMCON &= 0x3F;
  58   1        IE2 &= ~0x04;  
  59   1        USXINX_Clear; 
  60   1      }
  61          ////uart5
  62          //void MX_USART5_UART_Init(void)
  63          //{
  64          //  Choose_SSI5;
  65          //  uart5_rx_count=0;
  66          //  UARTX_Init(32, 115200);
  67          //  USXINX_Clear;
  68          //}
  69          //void UART5_DeInit(void)
  70          //{
  71          //  Choose_SSI5;
  72          //  TMCON &= 0x3F;
  73          //  IE2 &= ~0x10;  
  74          //  USXINX_Clear; 
  75          //}
  76          /*******************************串口2发送字节*/
  77          void Uart2SendByte(uint8_t dat)
  78          {
  79   1        Choose_SSI2;
  80   1        USXCON3 = dat;
  81   1        Uart2_send_OK;
  82   1        //Soft_Delay_usS(5);
  83   1        USXINX_Clear;
  84   1      }
  85          /******************************串口2发送字符串*/
  86          void Uart2SendStr(uint8_t *pstr,uint16_t strlen)
  87          {
  88   1        if((NULL == pstr)||(0 == strlen))
  89   1        {
  90   2          return;
  91   2        }
  92   1      //  Choose_SSI2;
  93   1        while(strlen--)
  94   1        {
  95   2          Uart2SendByte(*pstr);
  96   2      //    USXCON3 = *pstr;
  97   2      //    Uart2_send_OK;
  98   2          pstr++;
  99   2        }
 100   1      //  USXINX_Clear;
 101   1      }
 102          
 103          /*******************************串口3发送字节*/
 104          void Uart3SendByte(uint8_t dat)
 105          {
 106   1        Choose_SSI3;
 107   1        USXCON3 = dat;
 108   1        Uart3_send_OK;
 109   1        USXINX_Clear;
 110   1      }
 111          /******************************串口4发送字符串*/
 112          void Uart3SendStr(uint8_t *pstr,uint16_t strlen)
C51 COMPILER V9.60.0.0   USART                                                             04/19/2023 14:20:21 PAGE 3   

 113          {
 114   1        if((NULL == pstr)||(0 == strlen))
 115   1        {
 116   2          return;
 117   2        }
 118   1      //  Choose_SSI4;
 119   1        while(strlen--)
 120   1        {
 121   2          Uart3SendByte(*pstr);
 122   2      //    USXCON3 = *pstr;
 123   2      //    Uart4_send_OK;
 124   2          pstr++;
 125   2        }
 126   1      //  USXINX_Clear;
 127   1      }
 128          ///*******************************串口5发送字节*/
 129          //void Uart5SendByte(uint8_t dat)
 130          //{
 131          //  Choose_SSI5;
 132          //  USXCON3 = dat;
 133          //  Uart5_send_OK;
 134          //  USXINX_Clear;
 135          //}
 136          ///******************************串口5发送字符串*/
 137          //void Uart5SendStr(uint8_t *pstr,uint16_t strlen)
 138          //{
 139          //  if((NULL == pstr)||(0 == strlen))
 140          //  {
 141          //    return;
 142          //  }
 143          ////  Choose_SSI5;
 144          //  while(strlen--)
 145          //  {
 146          //    Uart5SendByte(*pstr);
 147          ////    USXCON3 = *pstr;
 148          ////    Uart5_send_OK;
 149          //    pstr++;
 150          //  }
 151          ////  USXINX_Clear;
 152          //}
 153          
 154          
 155          void UART2_Int() interrupt 16   //Uart2中断函数
 156          {
 157   1      //  uint8_t res;
 158   1        Choose_SSI2;
 159   1        if(USXCON0 & 0x02)  //发送标志位判断TI
 160   1        {
 161   2          USXCON0 |= 0x02;
 162   2          Uart2SendFlag = 1;
 163   2        }
 164   1        if((USXCON0 & 0x01)) //接收标志位判断RI
 165   1        {
 166   2          USXCON0 |= 0x01;
 167   2          
 168   2          UART2_ISR();
 169   2      
 170   2          Uart2ReceiveFlag = 1;
 171   2        }
 172   1        USXINX_Clear;
 173   1      }
 174          
C51 COMPILER V9.60.0.0   USART                                                             04/19/2023 14:20:21 PAGE 4   

 175          void UART3_Int() interrupt 17   //Uart3中断函数
 176          {
 177   1        uint8_t res;
 178   1        Choose_SSI3;
 179   1        if(USXCON0 & 0x02)  //发送标志位判断TI
 180   1        {
 181   2          USXCON0 |= 0x02;
 182   2          Uart3SendFlag = 1;
 183   2        }
 184   1        if((USXCON0 & 0x01)) //接收标志位判断RI
 185   1        {
 186   2          USXCON0 |= 0x01;
 187   2          res=USXCON3;
 188   2          Uart3_Rx[uart3_rx_count]=res; 
 189   2          uart3_rx_count++;
 190   2          if (uart3_rx_count >= UART3_MAX_LEN) {
 191   3              //防止溢出
 192   3              uart3_rx_count = 0;
 193   3          }
 194   2          Uart3ReceiveFlag = 1;
 195   2        }
 196   1        USXINX_Clear;
 197   1      }
 198          /*
 199          void UART5_Int() interrupt 19   //Uart5中断函数
 200          {
 201            uint8_t res;
 202            Choose_SSI5;
 203            if(USXCON0 & 0x02)  //发送标志位判断TI
 204            {
 205              USXCON0 |= 0x02;
 206              Uart5SendFlag = 1;
 207            }
 208            if((USXCON0 & 0x01)) //接收标志位判断RI
 209            {
 210              USXCON0 |= 0x01;
 211              res=USXCON3;
 212              Uart5_Rx[uart5_rx_count]=res; 
 213              uart5_rx_count++;
 214              if (uart5_rx_count >= UART5_MAX_LEN) {
 215                  //防止溢出
 216                  uart5_rx_count = 0;
 217              }
 218              Uart5ReceiveFlag = 1;
 219            }
 220            USXINX_Clear;
 221          }*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    430    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    130       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.60.0.0   USART                                                             04/19/2023 14:20:21 PAGE 5   


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

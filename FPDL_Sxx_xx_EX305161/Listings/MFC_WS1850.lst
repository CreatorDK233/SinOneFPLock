C51 COMPILER V9.60.0.0   MFC_WS1850                                                        05/16/2023 16:36:56 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MFC_WS1850
OBJECT MODULE PLACED IN .\Objects\MFC_WS1850.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Drivers\Protocol\MFC_WS1850.c LARGE OMF2 OPTIMIZE(9,SPEED) BROWSE INCDIR
                    -(.\Drivers\Lib\c;.\Drivers\Lib\H;.\Drivers\Lib\IAP_Lib;.\Drivers\Lib\TouchKey_lib;.\Drivers\Physical;.\Drivers\Protocol;
                    -.\Softwares\Application;.\Softwares\Basic;.\Softwares\ModuleLogic) DEBUG PRINT(.\Listings\MFC_WS1850.lst) TABS(2) OBJECT
                    -(.\Objects\MFC_WS1850.obj)

line level    source

   1          #include "IO.h"
   2          #include "I2cBus.h"
   3          #include "StdTypes.h"
   4          #include "Basic_Function.h"
   5          
   6          #define MAXRLEN        18
   7          #define MIN_STRENGTH  228
   8          //******************************************************************/
   9          //                    RC522 FIFO长度定义                            /
  10          //******************************************************************/
  11          #define DEF_FIFO_LENGTH             64           //FIFO size=64byte
  12          
  13          //******************************************************************/
  14          //                       RC522命令字                                /
  15          //******************************************************************/
  16          #define PCD_SLEEP                 0x10           //取消当前命令
  17          #define PCD_IDLE                  0x00           //取消当前命令
  18          #define PCD_AUTHENT               0x0E           //验证密钥
  19          #define PCD_RECEIVE               0x08           //接收数据
  20          #define PCD_TRANSMIT              0x04           //发送数据
  21          #define PCD_TRANSCEIVE            0x0C           //发送并接收数据
  22          #define PCD_RESETPHASE            0x0F           //复位
  23          #define PCD_CALCCRC               0x03           //CRC计算
  24          
  25          //******************************************************************/
  26          //                   Mifare_One卡片命令字                          */
  27          //******************************************************************/
  28          #define PICC_REQIDL               0x26           //寻天线区内未进入休眠状态
  29          #define PICC_REQALL               0x52           //寻天线区内全部卡
  30          #define PICC_ANTICOLL1            0x93           //防冲撞
  31          #define PICC_ANTICOLL2            0x95           //防冲撞
  32          #define PICC_AUTHENT1A            0x60           //验证A密钥
  33          #define PICC_AUTHENT1B            0x61           //验证B密钥
  34          #define PICC_READ                 0x30           //读块
  35          #define PICC_WRITE                0xA0           //写块
  36          #define PICC_DECREMENT            0xC0           //扣款
  37          #define PICC_INCREMENT            0xC1           //充值
  38          #define PICC_RESTORE              0xC2           //调块数据到缓冲区
  39          #define PICC_TRANSFER             0xB0           //保存缓冲区中数据
  40          #define PICC_HALT                 0x50           //休眠
  41          
  42          //******************************************************************/
  43          //                        MF522寄存器定义                           /
  44          //******************************************************************/
  45          // PAGE 0
  46          #define     RFU00                 0x00    
  47          #define     CommandReg            0x01    
  48          #define     ComIEnReg             0x02    
  49          #define     DivlEnReg             0x03    
  50          #define     ComIrqReg             0x04    
  51          #define     DivIrqReg             0x05
  52          #define     ErrorReg              0x06    
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        05/16/2023 16:36:56 PAGE 2   

  53          #define     Status1Reg            0x07    
  54          #define     Status2Reg            0x08    
  55          #define     FIFODataReg           0x09
  56          #define     FIFOLevelReg          0x0A
  57          #define     WaterLevelReg         0x0B
  58          #define     ControlReg            0x0C
  59          #define     BitFramingReg         0x0D
  60          #define     CollReg               0x0E
  61          #define     RFU0F                 0x0F
  62          // PAGE 1     
  63          #define     RFU10                 0x10
  64          #define     ModeReg               0x11
  65          #define     TxModeReg             0x12
  66          #define     RxModeReg             0x13
  67          #define     TxControlReg          0x14
  68          #define     TxASKReg              0x15
  69          #define     TxSelReg              0x16
  70          #define     RxSelReg              0x17
  71          #define     RxThresholdReg        0x18
  72          #define     DemodReg              0x19
  73          #define     RFU1A                 0x1A
  74          #define     RFU1B                 0x1B
  75          #define     MifareReg             0x1C
  76          #define     RFU1D                 0x1D
  77          #define     RFU1E                 0x1E
  78          #define     SerialSpeedReg        0x1F
  79          // PAGE 2    
  80          #define     RFU20                 0x20  
  81          #define     CRCResultRegM         0x21
  82          #define     CRCResultRegL         0x22
  83          #define     RFU23                 0x23
  84          #define     ModWidthReg           0x24
  85          #define     RFU25                 0x25
  86          #define     RFCfgReg              0x26
  87          #define     GsNReg                0x27
  88          #define     CWGsCfgReg            0x28
  89          #define     ModGsCfgReg           0x29
  90          #define     TModeReg              0x2A
  91          #define     TPrescalerReg         0x2B
  92          #define     TReloadRegH           0x2C
  93          #define     TReloadRegL           0x2D
  94          #define     TCounterValueRegH     0x2E
  95          #define     TCounterValueRegL     0x2F
  96          // PAGE 3      
  97          #define     RFU30                 0x30
  98          #define     TestSel1Reg           0x31
  99          #define     TestSel2Reg           0x32
 100          #define     TestPinEnReg          0x33
 101          #define     TestPinValueReg       0x34
 102          #define     TestBusReg            0x35
 103          #define     AutoTestReg           0x36
 104          #define     VersionReg            0x37
 105          #define     AnalogTestReg         0x38
 106          #define     TestDAC1Reg           0x39  
 107          #define     TestDAC2Reg           0x3A   
 108          #define     TestADCReg            0x3B   
 109          #define     RFU3C                 0x3C   
 110          #define     RFU3D                 0x3D   
 111          #define     RFU3E                 0x3E   
 112          #define     RFU3F                 0x3F
 113          
 114          //******************************************************************/
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        05/16/2023 16:36:56 PAGE 3   

 115          //                    RC522通讯返回错误代码                         /
 116          //******************************************************************/
 117          #define MI_ERR                      0xFE 
 118          //#define MI_ERR                         //(-2)
 119          
 120          
 121          // Mifare Error Codes 
 122          // Each function returns a status value, which corresponds to the 
 123          // mifare error codes. 
 124          
 125          #define MI_OK                          0 
 126          #define MI_CHK_OK                      0 
 127          #define MI_CRC_ZERO                    0 
 128          
 129          #define MI_CRC_NOTZERO                 1 
 130          
 131          #define MI_NOTAGERR                 0xFF 
 132          #define MI_CHK_S_FAILED             0xFF 
 133          #define MI_CRCERR                   0xFE 
 134          #define MI_CHK_COMPERR              0xFE 
 135          #define MI_EMPTY                    0xFD 
 136          #define MI_AUTHERR                  0xFC 
 137          #define MI_PARITYERR                0xFB 
 138          #define MI_CODEERR                  0xFA 
 139          
 140          #define MI_SERNRERR                 0xF8 
 141          #define MI_KEYERR                   0xF7 
 142          #define MI_NOTAUTHERR               0xF6 
 143          #define MI_BITCOUNTERR              0xF5 
 144          #define MI_BYTECOUNTERR             0xF4 
 145          #define MI_IDLE                     0xF3 
 146          #define MI_TRANSERR                 0xF2 
 147          #define MI_WRITEERR                 0xF1 
 148          #define MI_INCRERR                  0xF0 
 149          #define MI_DECRERR                  0xEF 
 150          #define MI_READERR                  0xEE 
 151          #define MI_OVFLERR                  0xED 
 152          #define MI_POLLING                  0xEC 
 153          #define MI_FRAMINGERR               0xEB 
 154          #define MI_ACCESSERR                0xEA 
 155          #define MI_UNKNOWN_COMMAND          0xE9 
 156          #define MI_COLLERR                  0xE8 
 157          #define MI_RESETERR                 0xE7 
 158          #define MI_INITERR                  0xE7 
 159          #define MI_INTERFACEERR             0xE7 
 160          #define MI_ACCESSTIMEOUT            0xE5 
 161          #define MI_NOBITWISEANTICOLL        0xE4 
 162          #define MI_QUIT                     0xE2 
 163          
 164          #define MI_RECBUF_OVERFLOW          0xCF 
 165          #define MI_SENDBYTENR               0xCE 
 166          
 167          #define MI_SENDBUF_OVERFLOW         0xCC 
 168          #define MI_BAUDRATE_NOT_SUPPORTED   0xCB 
 169          #define MI_SAME_BAUDRATE_REQUIRED   0xCA 
 170          
 171          #define MI_WRONG_PARAMETER_VALUE    0xC5 
 172          
 173          #define MI_BREAK                    0x9E 
 174          #define MI_NY_IMPLEMENTED           0x9D 
 175          #define MI_NO_MFRC                  0x9C 
 176          #define MI_MFRC_NOTAUTH             0x9B 
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        05/16/2023 16:36:56 PAGE 4   

 177          #define MI_WRONG_DES_MODE           0x9A 
 178          #define MI_HOST_AUTH_S_FAILED         0x99 
 179          
 180          #define MI_WRONG_LOAD_MODE          0x97 
 181          #define MI_WRONG_DESKEY             0x96 
 182          #define MI_MKLOAD_S_FAILED            0x95 
 183          #define MI_FIFOERR                  0x94 
 184          #define MI_WRONG_ADDR               0x93 
 185          #define MI_DESKEYLOAD_S_FAILED        0x92 
 186          
 187          #define MI_WRONG_SEL_CNT            0x8F 
 188          #define MI_RC531_WRONG_READVALUE    0x8E //LI ADDED 09-4-24 
 189          #define MI_WRONG_TEST_MODE          0x8C 
 190          #define MI_TEST_S_FAILED              0x8B 
 191          #define MI_TOC_ERROR                0x8A 
 192          #define MI_COMM_ABORT               0x89 
 193          #define MI_INVALID_BASE             0x88 
 194          #define MI_MFRC_RESET               0x87 
 195          #define MI_WRONG_VALUE              0x86 
 196          #define MI_VALERR                   0x85
 197          //******************************************************************/
 198          //                         函数定义                                 /
 199          //******************************************************************/
 200          sint8_t PcdHalt(void);
 201          sint8_t PcdReset(void);
 202          void PcdAntennaOn(void);
 203          void PcdAntennaOff(void);
 204          sint8_t PcdRequest(uint8_t req_code,uint8_t *pTagType);   
 205          sint8_t PcdAnticoll(uint8_t *pSnr);
 206          sint8_t PcdSelect(uint8_t *pSnr);
 207          sint8_t PcdAuthState(uint8_t auth_mode,uint8_t addr,
 208                            uint8_t *pKey,uint8_t *pSnr);     
 209          sint8_t PcdRead(uint8_t addr,uint8_t *pData);     
 210          sint8_t PcdWrite(uint8_t addr,uint8_t *pData);    
 211          sint8_t PcdValue(uint8_t dd_mode,uint8_t addr,uint8_t *pValue);   
 212          sint8_t PcdBakValue(uint8_t sourceaddr, uint8_t goaladdr);                                 
 213          sint8_t PcdComMF522(uint8_t Command, uint8_t *pInData, 
 214                           uint8_t InLenByte,uint8_t *pOutData, 
 215                           uint16_t  *pOutLenBit);
 216          void CalulateCRC(uint8_t *pIndata,uint8_t len,
 217                           uint8_t *pOutData);
 218          void WriteRawRC(uint8_t Address,uint8_t value);
 219          uint8_t ReadRawRC(uint8_t Address); 
 220          void SetBitMask(uint8_t reg,uint8_t mask); 
 221          void ClearBitMask(uint8_t reg,uint8_t mask); 
 222          sint8_t Read_Block(uint8_t Block,uint8_t *Buf);
 223          sint8_t Write_Block(uint8_t Block);
 224          void PcdAntennaTestOn(void);
 225          
 226          extern sint8_t KK[8]; // 数据加密密钥
 227          static uint8_t RF_Buffer[18]; // 射频卡数据缓冲区
 228          static uint8_t UID[5];
 229          static uint8_t Password_Buffer[6]={0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
 230          //extern void Des_Encrypt(sint8_t* In, sint8_t* K,sint8_t* Out);
 231          //extern void Des_Decrypt(sint8_t* In, sint8_t* K,sint8_t* Out);
 232          static uint8_t des_on; // DES加密标志
 233          
 234          static uint8_t TestVal;
 235          static uint8_t TestBuff[20];
 236          
 237          static uint8_t HAL_SPI2_RXBUFF;
 238          #ifdef Function_CardReaderUseSPI
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        05/16/2023 16:36:56 PAGE 5   

              //******************************************************************/
              //功    能：读RC522寄存器
              //参数说明：Address[IN]:寄存器地址
              //返    回：读出的值
              //******************************************************************/
              uint8_t ReadRawRC(uint8_t Address)
              {
                uint8_t ucResult;
                HAL_StatusTypeDef HAL_STATUS;
                
                SET_MFC_CS_L;
                Hardware_DelayX1us(10);
              //  Hardware_DelayMs(10);
                ucResult = (Address<<1)|0x80;
                
                HAL_STATUS = HAL_SPI_Transmit(&hspi1,&ucResult,1,10);
                HAL_STATUS = HAL_SPI_Receive(&hspi1,&HAL_SPI2_RXBUFF,1,10);
                SET_MFC_CS_H;
              
              //  Hardware_DelayMs(10);
                Hardware_DelayX1us(10);
                return HAL_SPI2_RXBUFF;
              }
              
              //******************************************************************/
              //功    能：写RC522寄存器
              //参数说明：Address[IN]:寄存器地址
              //          value[IN]:写入的值
              //******************************************************************/
              void  WriteRawRC(uint8_t Address, uint8_t value)
              {
                uint8_t temp;
                HAL_StatusTypeDef HAL_STATUS;
                
                SET_MFC_CS_L;
                Hardware_DelayX1us(10);
                
                temp = Address<<1;
                HAL_STATUS = HAL_SPI_Transmit(&hspi1,&temp,1,500);
                HAL_STATUS = HAL_SPI_Transmit(&hspi1,&value,1,500);
                SET_MFC_CS_H;
                //Hardware_DelayX1us(100);
              }
              
              #else
 284          uint8_t ReadRawRC(uint8_t Address)
 285          {
 286   1        uint8_t ucResult;
 287   1        I2C_ReadRandom(I2CADDR_MFC,Address,&ucResult);
 288   1        return ucResult;
 289   1      }
 290          void WriteRawRC(uint8_t Address, uint8_t value)
 291          {  
 292   1        I2C_WriteRandom(I2CADDR_MFC,Address,value);
 293   1      }
 294          #endif
 295          
 296          //******************************************************************/
 297          //功    能：置RC522寄存器位
 298          //参数说明：reg[IN]:寄存器地址
 299          //          mask[IN]:置位值
 300          //******************************************************************/
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        05/16/2023 16:36:56 PAGE 6   

 301          void SetBitMask(uint8_t reg,uint8_t mask)  
 302          {
 303   1        sint8_t tmp = 0x00;
 304   1        tmp = ReadRawRC(reg)| mask;
 305   1        WriteRawRC(reg, tmp);  // set bit mask
 306   1      }
 307          
 308          //******************************************************************/
 309          //功    能：清RC522寄存器位
 310          //参数说明：reg[IN]:寄存器地址
 311          //          mask[IN]:清位值
 312          //******************************************************************/
 313          void ClearBitMask(uint8_t reg,uint8_t mask)  
 314          {
 315   1        sint8_t tmp = 0x00;
 316   1        tmp = ReadRawRC(reg)&(~mask);
 317   1        WriteRawRC(reg, tmp)        ;  // clear bit mask
 318   1      } 
 319          
 320          //******************************************************************/
 321          //功    能：复位RC522
 322          //返    回: 成功返回MI_OK
 323          //******************************************************************/
 324          sint8_t PcdReset(void)
 325          {
 326   1        //SET_MFC_RST_H;
 327   1        //Hardware_DelayMs(1);
 328   1        SET_MFC_RST_L;
 329   1        Hardware_DelayX1us(10);
 330   1        SET_MFC_RST_H;
 331   1        Hardware_DelayX1us(50);
 332   1        
 333   1        WriteRawRC(CommandReg,PCD_RESETPHASE);
 334   1        Hardware_DelayMs(5);
 335   1        
 336   1        WriteRawRC(RFCfgReg,0x48)       ; 
 337   1        /* 增益调整 GsN前后两位独立 CWGsCfg最大0x3F ModGsCfg最大0x3F*/
 338   1        #ifdef ProjectIs_BarLock_S6431
 339   1        WriteRawRC(GsNReg,0x33); 
 340   1        WriteRawRC(CWGsCfgReg,0x03); 
 341   1        WriteRawRC(ModGsCfgReg,0x03); 
 342   1        #else
                WriteRawRC(GsNReg,0xFF); 
                WriteRawRC(CWGsCfgReg,0x3F); 
                WriteRawRC(ModGsCfgReg,0x3F);
                #endif
 347   1        
 348   1        WriteRawRC(ModeReg,0x3D);
 349   1        WriteRawRC(TReloadRegL,30);
 350   1        WriteRawRC(TReloadRegH,0);
 351   1        
 352   1        WriteRawRC(TModeReg,0x8D);
 353   1        WriteRawRC(TPrescalerReg,0x3E);  
 354   1          
 355   1      //  WriteRawRC(TxASKReg,0x40)            ; // FOR DEBUG AND TEST
 356   1        return MI_OK; 
 357   1      }
 358          
 359          //******************************************************************/
 360          //开启天线发射  
 361          //每次启动或关闭天险发射之间应至少有1ms的间隔
 362          //******************************************************************/
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        05/16/2023 16:36:56 PAGE 7   

 363          void PcdAntennaOn(void)
 364          {
 365   1        //uint8_t i;
 366   1        /*
 367   1        WriteRawRC(TxASKReg,0x40)       ;
 368   1        Hardware_DelayMs(3)            ;
 369   1        i = ReadRawRC(TxControlReg)     ;
 370   1        if(!(i&0x03))
 371   1          SetBitMask(TxControlReg, 0x03);
 372   1        i=ReadRawRC(TxASKReg)       ;
 373   1        */
 374   1        WriteRawRC(TxASKReg,0x40)       ;
 375   1        SetBitMask(TxControlReg, 0x03);
 376   1      }
 377          
 378          //******************************************************************/
 379          //开启天线发射  
 380          //每次启动或关闭天险发射之间应至少有1ms的间隔
 381          //******************************************************************/
 382          void PcdAntennaTestOn(void)
 383          {
 384   1      //*
 385   1        SET_MFC_RST_H                         ;
 386   1        Hardware_DelayMs(15); // 2010.10.09 ???? FOR DEBUG
 387   1        
 388   1        WriteRawRC(TxControlReg,0x02)    ;
 389   1      }
 390          
 391          
 392          //******************************************************************/
 393          //关闭天线发射
 394          //******************************************************************/
 395          void PcdAntennaOff(void)
 396          {
 397   1        //return;
 398   1          ClearBitMask(TxControlReg, 0x03);
 399   1      }
 400          
 401          //******************************************************************/
 402          //功    能：通过RC522和ISO14443卡通讯
 403          //参数说明：Command[IN]:RC522命令字
 404          //          pInData[IN]:通过RC522发送到卡片的数据
 405          //          InLenByte[IN]:发送数据的字节长度
 406          //          pOutData[OUT]:接收到的卡片返回数据
 407          //          *pOutLenBit[OUT]:返回数据的位长度
 408          //******************************************************************/
 409          sint8_t PcdComMF522(uint8_t Command  ,uint8_t *pInData , 
 410                           uint8_t InLenByte,uint8_t *pOutData, 
 411                           uint16_t  *pOutLenBit                       )
 412          {
 413   1        sint8_t status = MI_ERR                          ;
 414   1        uint8_t irqEn   = 0x00                  ;
 415   1        uint8_t waitFor = 0x00                  ;
 416   1        uint8_t lastBits                        ;
 417   1        uint8_t n                               ;
 418   1        uint16_t  i                               ;
 419   1        switch (Command)
 420   1        {
 421   2          case PCD_AUTHENT:
 422   2            irqEn   = 0x12                            ;
 423   2            waitFor = 0x10                            ;
 424   2            break                                     ;
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        05/16/2023 16:36:56 PAGE 8   

 425   2          case PCD_TRANSCEIVE:
 426   2            irqEn   = 0x20;//0x77                            ;
 427   2            waitFor = 0x30                            ;
 428   2            break                                     ;
 429   2          default:
 430   2            break                                     ;
 431   2        }
 432   1        WriteRawRC(ComIEnReg,irqEn|0x80)              ; //
 433   1        ClearBitMask(ComIrqReg,0x80)                  ;
 434   1        WriteRawRC(CommandReg,PCD_IDLE)               ;
 435   1        SetBitMask(FIFOLevelReg,0x80)                 ; // 清空FIFO 
 436   1        for(i=0; i<InLenByte; i++)
 437   1          WriteRawRC(FIFODataReg,pInData[i])          ; // 数据写入FIFO 
 438   1        WriteRawRC(CommandReg, Command)               ; // 命令写入命令寄存器
 439   1        if(Command == PCD_TRANSCEIVE)
 440   1          SetBitMask(BitFramingReg,0x80)              ; // 开始发送     
 441   1        
 442   1        PcdAntennaOn()                                ;//开启天线发射
 443   1        
 444   1        i = 100                                       ; //根据时钟频率调整，操作M1等待时间15ms
 445   1        do 
 446   1        {
 447   2          n = ReadRawRC(ComIrqReg)                    ;
 448   2          i--                                         ;
 449   2        }
 450   1        while((i!=0)&&!(n&0x01)&&!(n&waitFor))        ;
 451   1        ClearBitMask(BitFramingReg,0x80)              ;
 452   1        if(i!=0)
 453   1        {
 454   2          if(!(ReadRawRC(ErrorReg)&0x1B))
 455   2          {
 456   3            status = MI_OK                            ;
 457   3            if (n&irqEn&0x01)
 458   3              status = MI_NOTAGERR                    ;
 459   3            if(Command==PCD_TRANSCEIVE)
 460   3            {
 461   4              n = ReadRawRC(FIFOLevelReg)             ;
 462   4              lastBits = ReadRawRC(ControlReg)&0x07   ;
 463   4              if(lastBits)
 464   4                *pOutLenBit = (n-1)*8 + lastBits      ;
 465   4              else
 466   4                *pOutLenBit = n*8                     ;
 467   4              if(n==0)
 468   4                n = 1                                 ;
 469   4              if(n>MAXRLEN)
 470   4                n = MAXRLEN                           ;
 471   4              
 472   4             for (i=0; i<n; i++)
 473   4              { 
 474   5                pOutData[i]= ReadRawRC(FIFODataReg)  ; 
 475   5              }
 476   4              
 477   4              DEBUG_MARK;
 478   4            }
 479   3          }
 480   2          else
 481   2            status = MI_ERR;        
 482   2        }
 483   1        else{
 484   2          PcdAntennaOff();
 485   2        }
 486   1        SetBitMask(ControlReg,0x80);// stop timer now
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        05/16/2023 16:36:56 PAGE 9   

 487   1        WriteRawRC(CommandReg,PCD_IDLE); 
 488   1        return status;
 489   1      }
 490          
 491          //******************************************************************/
 492          //功    能：寻卡                                                    /
 493          //参数说明: req_code[IN]:寻卡方式                                   /
 494          //                0x52 = 寻感应区内所有符合14443A标准的卡           /
 495          //                0x26 = 寻未进入休眠状态的卡                       /
 496          //          pTagType[OUT]：卡片类型代码                             /
 497          //                0x4400 = Mifare_UltraLight                        /
 498          //                0x0400 = Mifare_One(S50)                          /
 499          //                0x0200 = Mifare_One(S70)                          /
 500          //                0x0800 = Mifare_Pro(X)                            /
 501          //                0x4403 = Mifare_DESFire                           /
 502          //返    回: 成功返回MI_OK                                           /
 503          //******************************************************************/
 504          sint8_t PcdRequest(uint8_t req_code,uint8_t *pTagType)
 505          {
 506   1        sint8_t status;  
 507   1        uint16_t  unLen;
 508   1        uint8_t ucComMF522Buf[MAXRLEN]; 
 509   1      
 510   1        ClearBitMask(Status2Reg,0x08);
 511   1        WriteRawRC(BitFramingReg,0x07);
 512   1        SetBitMask(TxControlReg,0x03);
 513   1       
 514   1        ucComMF522Buf[0] = req_code;
 515   1      
 516   1        status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,
 517   1                             1,ucComMF522Buf,&unLen);
 518   1        if ((status == MI_OK) && (unLen == 0x10))
 519   1        {    
 520   2          *pTagType     = ucComMF522Buf[0];
 521   2          *(pTagType+1) = ucComMF522Buf[1];
 522   2        }
 523   1        else
 524   1          status = MI_ERR;
 525   1        return status;
 526   1      }
 527          
 528          //******************************************************************/
 529          //功    能：防冲撞                                                  /
 530          //参数说明: pSnr[OUT]:卡片序列号，4字节                             /
 531          //返    回: 成功返回MI_OK                                           /
 532          //******************************************************************/
 533          sint8_t PcdAnticoll(uint8_t *pSnr)
 534          {
 535   1          sint8_t status;
 536   1          uint8_t i,snr_check=0;
 537   1          uint16_t  unLen;
 538   1          uint8_t ucComMF522Buf[MAXRLEN]; 
 539   1          
 540   1        //return MI_OK;
 541   1        
 542   1          ClearBitMask(Status2Reg,0x08);
 543   1          WriteRawRC(BitFramingReg,0x00);
 544   1          ClearBitMask(CollReg,0x80);
 545   1       
 546   1          ucComMF522Buf[0] = PICC_ANTICOLL1;
 547   1          ucComMF522Buf[1] = 0x20;
 548   1      
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        05/16/2023 16:36:56 PAGE 10  

 549   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
 550   1      
 551   1          if (status == MI_OK)
 552   1          {
 553   2             for (i=0; i<4; i++)
 554   2               {   
 555   3                   *(pSnr+i)  = ucComMF522Buf[i];
 556   3                   snr_check ^= ucComMF522Buf[i];
 557   3                 TestVal = snr_check;
 558   3               }
 559   2               if (snr_check != ucComMF522Buf[i])
 560   2               {   status = MI_ERR;    }
 561   2          }
 562   1          
 563   1          SetBitMask(CollReg,0x80);
 564   1          return status;
 565   1      }
 566          
 567          /////////////////////////////////////////////////////////////////////
 568          //功    能：选定卡片
 569          //参数说明: pSnr[IN]:卡片序列号，4字节
 570          //返    回: 成功返回MI_OK
 571          /////////////////////////////////////////////////////////////////////
 572          sint8_t PcdSelect(uint8_t *pSnr)
 573          {
 574   1          sint8_t status;
 575   1          uint8_t i;
 576   1          uint16_t  unLen;
 577   1          uint8_t ucComMF522Buf[MAXRLEN]; 
 578   1          
 579   1          ucComMF522Buf[0] = PICC_ANTICOLL1;
 580   1          ucComMF522Buf[1] = 0x70;
 581   1          ucComMF522Buf[6] = 0;
 582   1          for (i=0; i<4; i++)
 583   1          {
 584   2            ucComMF522Buf[i+2] = *(pSnr+i);
 585   2            ucComMF522Buf[6]  ^= *(pSnr+i);
 586   2          }
 587   1          CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
 588   1        
 589   1          ClearBitMask(Status2Reg,0x08);
 590   1      
 591   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
 592   1          
 593   1          if ((status == MI_OK) && (unLen == 0x18))
 594   1          {   status = MI_OK;  }
 595   1          else
 596   1          {   status = MI_ERR;    }
 597   1      
 598   1          return status;
 599   1      }
 600          
 601          //******************************************************************/
 602          //功    能：验证卡片密码
 603          //参数说明: auth_mode[IN]: 密码验证模式
 604          //                 0x60 = 验证A密钥
 605          //                 0x61 = 验证B密钥 
 606          //          addr[IN]：块地址
 607          //          pKey[IN]：密码
 608          //          pSnr[IN]：卡片序列号，4字节
 609          //返    回: 成功返回MI_OK
 610          //******************************************************************/
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        05/16/2023 16:36:56 PAGE 11  

 611          sint8_t PcdAuthState(uint8_t auth_mode,uint8_t addr,
 612                            uint8_t *pKey,uint8_t *pSnr    )
 613          {
 614   1          sint8_t status;
 615   1          uint16_t  unLen;
 616   1          uint8_t i,ucComMF522Buf[MAXRLEN]; 
 617   1      
 618   1          ucComMF522Buf[0] = auth_mode;
 619   1          ucComMF522Buf[1] = addr;
 620   1          for (i=0; i<6; i++)
 621   1          {    ucComMF522Buf[i+2] = *(pKey+i);   }
 622   1          for (i=0; i<6; i++)
 623   1          {    ucComMF522Buf[i+8] = *(pSnr+i);   }
 624   1          
 625   1          status = PcdComMF522(PCD_AUTHENT,ucComMF522Buf,12,ucComMF522Buf,&unLen);
 626   1          if ((status != MI_OK) || (!(ReadRawRC(Status2Reg) & 0x08)))
 627   1          {   status = MI_ERR;   }
 628   1          
 629   1          return status;
 630   1      }
 631          
 632          //******************************************************************/
 633          //功    能：读取M1卡一块数据
 634          //参数说明: addr[IN]：块地址
 635          //          pData[OUT]：读出的数据，16字节
 636          //返    回: 成功返回MI_OK
 637          //******************************************************************/
 638          sint8_t PcdRead(uint8_t addr,uint8_t *pData)
 639          {
 640   1          sint8_t status                                          ;
 641   1          uint16_t  unLen                                  ;
 642   1          uint8_t i;uint8_t ucComMF522Buf[MAXRLEN]               ; 
 643   1      
 644   1          ucComMF522Buf[0] = PICC_READ                         ;
 645   1          ucComMF522Buf[1] = addr                              ;
 646   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2])       ;   
 647   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,
 648   1                               ucComMF522Buf,&unLen           );
 649   1          if ((status == MI_OK) && (unLen == 0x90))
 650   1          {
 651   2              for (i=0; i<16; i++)
 652   2                  *(pData+i) = ucComMF522Buf[i];   
 653   2          }
 654   1          else
 655   1            status = MI_ERR;       
 656   1          return status;
 657   1      }
 658          
 659          //******************************************************************/
 660          //功    能：读取M1卡一块数据
 661          //参数说明: addr[IN]：块地址
 662          //          pData[OUT]：读出的数据，16字节
 663          //返    回: 成功返回MI_OK
 664          //******************************************************************/
 665          sint8_t Read_Block(uint8_t Block,uint8_t *Buf)
 666          {
 667   1        sint8_t result                                          ;
 668   1      
 669   1        result = PcdAuthState(0x60,Block,Password_Buffer,UID)   ;
 670   1        if(result!=MI_OK)
 671   1          return result                                         ;
 672   1        result = PcdRead(Block,Buf)                             ;
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        05/16/2023 16:36:56 PAGE 12  

 673   1      //  return result; // 2011.01.03
 674   1        
 675   1        if(result!=MI_OK)     return   result                   ;
 676   1        if(Block!=0x00&&des_on)
 677   1        {
 678   2          /*
 679   2          Des_Decrypt((sint8_t *)Buf,KK,(sint8_t *)Buf);
 680   2          Des_Decrypt((sint8_t *)&Buf[8],KK,(sint8_t *)&Buf[8]);  
 681   2          */
 682   2        }
 683   1        return MI_OK                                            ; 
 684   1      }
 685          
 686          //******************************************************************/
 687          //功    能：写数据到M1卡一块
 688          //参数说明: addr[IN]：块地址
 689          //          pData[IN]：写入的数据，16字节
 690          //返    回: 成功返回MI_OK
 691          //******************************************************************/
 692          sint8_t PcdWrite(uint8_t addr,uint8_t *pData)
 693          {
 694   1        sint8_t status                                          ;
 695   1        uint16_t  unLen                                     ;
 696   1        uint8_t i;uint8_t ucComMF522Buf[MAXRLEN]                ; 
 697   1          
 698   1        ucComMF522Buf[0] = PICC_WRITE                           ;
 699   1        ucComMF522Buf[1] = addr                                 ;
 700   1        CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2])          ;
 701   1        status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,
 702   1                             ucComMF522Buf,&unLen          )    ;
 703   1        if(  ( status != MI_OK)||(unLen != 4)
 704   1           ||((ucComMF522Buf[0]&0x0F)!= 0x0A))
 705   1          status = MI_ERR                                       ;           
 706   1        if (status == MI_OK)
 707   1        {
 708   2          for (i=0; i<16; i++)
 709   2            ucComMF522Buf[i] = *(pData+i)                       ;  
 710   2          CalulateCRC(ucComMF522Buf,16,&ucComMF522Buf[16])      ;
 711   2          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,
 712   2                               18,ucComMF522Buf,&unLen     )    ;
 713   2          if(  (status != MI_OK)||(unLen != 4 )
 714   2             ||((ucComMF522Buf[0]&0x0F)!= 0x0A))
 715   2            status = MI_ERR                                     ;   
 716   2        }    
 717   1        return status                                           ;
 718   1      }
 719          //******************************************************************/
 720          //功    能：写数据到M1卡一块
 721          //参数说明: addr[IN]：块地址
 722          //          pData[IN]：写入的数据，16字节
 723          //返    回: 成功返回MI_OK
 724          //******************************************************************/
 725          
 726          sint8_t Write_Block(uint8_t Block)
 727          {
 728   1        sint8_t result                                          ;
 729   1        if(des_on)
 730   1        {
 731   2      /*    Des_Encrypt((sint8_t *)RF_Buffer    ,KK,
 732   2                      (sint8_t *)RF_Buffer        )                ;// for debug
 733   2          Des_Encrypt((sint8_t *)&RF_Buffer[8],KK,
 734   2                      (sint8_t *)&RF_Buffer[8]    )                ;// for debug  
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        05/16/2023 16:36:56 PAGE 13  

 735   2      */                
 736   2        }
 737   1        result = PcdAuthState(0x60,Block,Password_Buffer,UID)   ;
 738   1        if(result!=MI_OK)
 739   1          return result                                         ;  
 740   1        result = PcdWrite(Block,RF_Buffer)                      ;
 741   1        return result                                           ;  
 742   1      }
 743          
 744          //******************************************************************/
 745          //功    能：扣款和充值
 746          //参数说明: dd_mode[IN]：命令字
 747          //               0xC0 = 扣款
 748          //               0xC1 = 充值
 749          //          addr[IN]：钱包地址
 750          //          pValue[IN]：4字节增(减)值，低位在前
 751          //返    回: 成功返回MI_OK
 752          //******************************************************************/
 753          sint8_t PcdValue(uint8_t dd_mode,uint8_t addr,uint8_t *pValue)
 754          {
 755   1          sint8_t status;
 756   1          uint16_t  unLen;
 757   1          uint8_t i,ucComMF522Buf[MAXRLEN]; 
 758   1          
 759   1          ucComMF522Buf[0] = dd_mode;
 760   1          ucComMF522Buf[1] = addr;
 761   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 762   1       
 763   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 764   1      
 765   1          if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
 766   1          {   status = MI_ERR;   }
 767   1              
 768   1          if (status == MI_OK)
 769   1          {
 770   2              for (i=0; i<16; i++)
 771   2              {    ucComMF522Buf[i] = *(pValue+i);   }
 772   2              CalulateCRC(ucComMF522Buf,4,&ucComMF522Buf[4]);
 773   2              unLen = 0;
 774   2              status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,6,ucComMF522Buf,&unLen);
 775   2              if (status != MI_ERR)
 776   2              {    status = MI_OK;    }
 777   2          }
 778   1          
 779   1          if (status == MI_OK)
 780   1          {
 781   2              ucComMF522Buf[0] = PICC_TRANSFER;
 782   2              ucComMF522Buf[1] = addr;
 783   2              CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]); 
 784   2         
 785   2              status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 786   2      
 787   2              if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
 788   2              {   status = MI_ERR;   }
 789   2          }
 790   1          return status;
 791   1      }
 792          
 793          //******************************************************************/
 794          //功    能：备份钱包
 795          //参数说明: sourceaddr[IN]：源地址
 796          //          goaladdr[IN]：目标地址
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        05/16/2023 16:36:56 PAGE 14  

 797          //返    回: 成功返回MI_OK
 798          //******************************************************************/
 799          sint8_t PcdBakValue(uint8_t sourceaddr, uint8_t goaladdr)
 800          {
 801   1          sint8_t status;
 802   1          uint16_t  unLen;
 803   1          uint8_t ucComMF522Buf[MAXRLEN]; 
 804   1      
 805   1          ucComMF522Buf[0] = PICC_RESTORE;
 806   1          ucComMF522Buf[1] = sourceaddr;
 807   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 808   1       
 809   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 810   1      
 811   1          if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
 812   1          {   status = MI_ERR;   }
 813   1          
 814   1          if (status == MI_OK)
 815   1          {
 816   2              ucComMF522Buf[0] = 0;
 817   2              ucComMF522Buf[1] = 0;
 818   2              ucComMF522Buf[2] = 0;
 819   2              ucComMF522Buf[3] = 0;
 820   2              CalulateCRC(ucComMF522Buf,4,&ucComMF522Buf[4]);
 821   2       
 822   2              status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,6,ucComMF522Buf,&unLen);
 823   2              if (status != MI_ERR)
 824   2              {    status = MI_OK;    }
 825   2          }
 826   1          
 827   1          if (status != MI_OK)
 828   1          {    return MI_ERR;   }
 829   1          
 830   1          ucComMF522Buf[0] = PICC_TRANSFER;
 831   1          ucComMF522Buf[1] = goaladdr;
 832   1      
 833   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 834   1       
 835   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 836   1      
 837   1          if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
 838   1          {   status = MI_ERR;   }
 839   1      
 840   1          return status;
 841   1      }
 842          
 843          
 844          //******************************************************************/
 845          //功    能：命令卡片进入休眠状态
 846          //返    回: 成功返回MI_OK
 847          //******************************************************************/
 848          sint8_t PcdHalt(void)
 849          {
 850   1          sint8_t status;
 851   1          uint16_t  unLen;
 852   1          uint8_t ucComMF522Buf[MAXRLEN]; 
 853   1      
 854   1          ucComMF522Buf[0] = PICC_HALT;
 855   1          ucComMF522Buf[1] = 0;
 856   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 857   1       
 858   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        05/16/2023 16:36:56 PAGE 15  

 859   1          return status;
 860   1      //    return MI_OK;
 861   1      }
 862          
 863          //******************************************************************/
 864          //功    能：命令卡片进入休眠状态
 865          //返    回: 成功返回MI_OK
 866          //******************************************************************/
 867          sint8_t MIF_Halt(void)
 868          {
 869   1          sint8_t status;
 870   1          uint16_t  unLen;
 871   1          uint8_t ucComMF522Buf[MAXRLEN]; 
 872   1      
 873   1          ucComMF522Buf[0] = PICC_HALT;
 874   1          ucComMF522Buf[1] = 0;
 875   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 876   1       
 877   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 878   1          return status ;  
 879   1      //    return MI_OK;
 880   1      }
 881          
 882          
 883          
 884          //******************************************************************/
 885          //用MF522计算CRC16函数
 886          //******************************************************************/
 887          void CalulateCRC(uint8_t *pIndata,uint8_t len,uint8_t *pOutData)
 888          {
 889   1          uint8_t i,n;
 890   1          ClearBitMask(DivIrqReg,0x04);
 891   1          WriteRawRC(CommandReg,PCD_IDLE);
 892   1          SetBitMask(FIFOLevelReg,0x80);
 893   1          for (i=0; i<len; i++)
 894   1          {   WriteRawRC(FIFODataReg, *(pIndata+i));   }
 895   1          WriteRawRC(CommandReg, PCD_CALCCRC);
 896   1          i = 0xFF;
 897   1          do 
 898   1          {
 899   2              n = ReadRawRC(DivIrqReg);
 900   2              i--;
 901   2          }
 902   1          while ((i!=0) && !(n&0x04));
 903   1          pOutData[0] = ReadRawRC(CRCResultRegL);
 904   1          pOutData[1] = ReadRawRC(CRCResultRegM);
 905   1      }
 906          
 907          
 908          status_t Find_Card(void)
 909          {
 910   1      
 911   1        //sint8_t status = MI_ERR ;
 912   1        uint8_t irqEn  = 0x00    ;
 913   1        uint8_t waitFor = 0x00   ;
 914   1        //uint8_t lastBits         ;
 915   1        uint8_t n                ;
 916   1        uint16_t  i              ;
 917   1       
 918   1        //ENTKS = 0;
 919   1       //ClearBitMask(ComIrqReg,0x80);    //release IRQ PIN
 920   1        ClearBitMask(Status2Reg,0x08);
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        05/16/2023 16:36:56 PAGE 16  

 921   1        WriteRawRC(BitFramingReg,0x07);
 922   1        SetBitMask(TxControlReg,0x03);
 923   1        Hardware_DelayMs(2);
 924   1        irqEn  = 0x20;//0x77;
 925   1        waitFor = 0x30;
 926   1      
 927   1        WriteRawRC(ComIEnReg,irqEn|0x80); //
 928   1        ClearBitMask(ComIrqReg,0x80);
 929   1        WriteRawRC(CommandReg,PCD_IDLE);
 930   1        SetBitMask(FIFOLevelReg,0x80); // 清空FIFO 
 931   1        WriteRawRC(FIFODataReg,0x52); // 数据写入FIFO 
 932   1        WriteRawRC(CommandReg, PCD_TRANSCEIVE); // 命令写入命令寄存器
 933   1      
 934   1        SetBitMask(BitFramingReg,0x80); // 开始发送  
 935   1         
 936   1        PcdAntennaOn();//开启天线发射
 937   1         
 938   1        i = 15; //根据时钟频率调整，操作M1等待时间15ms
 939   1        do 
 940   1        {
 941   2          n = ReadRawRC(ComIrqReg);
 942   2          i--;
 943   2          if (PINMACRO_NFC_IRQ_STATUS == 0 )
 944   2          {
 945   3            //PcdAntennaOff();
 946   3            return S_SUCCESS;
 947   3          }
 948   2        }
 949   1        while((i!=0)&&!(n&0x01)&&!(n&waitFor));
 950   1      
 951   1        //PcdAntennaOff();
 952   1      
 953   1        return S_FAIL;
 954   1       
 955   1      }
 956          
 957          status_t MFC_Auto_Reader(uint8_t *Point)
 958          {
 959   1        uint8_t i;
 960   1         
 961   1      //  return S_FAIL;
 962   1          
 963   1        //PcdAntennaOn();//开启天线发射 
 964   1      //  Hardware_DelayMs(1);
 965   1      
 966   1        //PA_ODR |=SETBIT2;
 967   1        
 968   1        if ( Find_Card() == S_SUCCESS )
 969   1        {
 970   2          if(PcdAnticoll(UID)==MI_OK)
 971   2          {   
 972   3            DEBUG_MARK;
 973   3            if ( PcdSelect(UID) == MI_OK )
 974   3            {
 975   4              PcdAntennaOff();
 976   4              SetBitMask(ControlReg,0x80);// stop timer now
 977   4                WriteRawRC(CommandReg,PCD_IDLE); 
 978   4              
 979   4              for (i=0;i<4;i++)
 980   4              {
 981   5                *Point = UID[i];
 982   5                Point++;
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        05/16/2023 16:36:56 PAGE 17  

 983   5              }
 984   4              DEBUG_MARK;
 985   4              return S_SUCCESS;
 986   4            }
 987   3          }
 988   2        }
 989   1        PcdAntennaOff();
 990   1        SetBitMask(ControlReg,0x80);// stop timer now
 991   1          WriteRawRC(CommandReg,PCD_IDLE); 
 992   1        //WriteRawRC(CommandReg,PCD_SLEEP);
 993   1      
 994   1        //PA_ODR &=CLRBIT2; 
 995   1        return S_FAIL;
 996   1      }
 997          
 998          status_t MFC_ReadLockBrandData(uint8_t *buff)
 999          {
1000   1        uint8_t i;
1001   1        uint8_t tempBuff[224];
1002   1        status_t TempResult;
1003   1        
1004   1        TempResult = S_FAIL;
1005   1        if ( Find_Card() == S_SUCCESS )
1006   1        {
1007   2          if(PcdAnticoll(UID)==MI_OK)
1008   2          {
1009   3            if( PcdSelect(UID)==MI_OK )
1010   3            {
1011   4              if ( Read_Block(0x04,tempBuff) == MI_OK ) //for save identify byte
1012   4              { 
1013   5                if (  (tempBuff[0] == 0x11)
1014   5                    &&(tempBuff[1] == 0x55)
1015   5                    &&(tempBuff[2] == 0xAA)
1016   5                    &&(tempBuff[3] == 0xDD)
1017   5                    &&(tempBuff[4] == 0xBB)
1018   5                    &&(tempBuff[5] == 0x11)
1019   5                    &&(tempBuff[6] == 0x55)
1020   5                    &&(tempBuff[7] == 0xAA)
1021   5                    &&(tempBuff[8] == 0xDD)
1022   5                    &&(tempBuff[9] == 0xBB) )
1023   5                {
1024   6                  for ( i=0;i<7;i++)
1025   6                  {
1026   7                    if ( Read_Block(4*i+8,&tempBuff[(2*i)*16]) != MI_OK ){
1027   8                      break;
1028   8                    }
1029   7                    if ( Read_Block(4*i+9,&tempBuff[((2*i)+1)*16]) != MI_OK ){
1030   8                      break;
1031   8                    }
1032   7                    CLRWDT();
1033   7                  }
1034   6                  if ( i==7 )
1035   6                  {
1036   7                    for (i=0;i<224;i++)
1037   7                    {
1038   8                      *(buff+i)=tempBuff[i];
1039   8                    }
1040   7                    TempResult = S_SUCCESS;
1041   7                  }
1042   6                }
1043   5              }
1044   4            }
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        05/16/2023 16:36:56 PAGE 18  

1045   3          }
1046   2        }
1047   1        PcdAntennaOff();
1048   1        SetBitMask(ControlReg,0x80);// stop timer now
1049   1          WriteRawRC(CommandReg,PCD_IDLE); 
1050   1        
1051   1        return TempResult;
1052   1      }
1053          
1054          
1055          void MFC_POWERDOWN(void)
1056          {
1057   1        
1058   1        SET_MFC_RST_L;
1059   1        Hardware_DelayMs(1);
1060   1      
1061   1        //WriteRawRC(CommandReg,PCD_RESETPHASE);
1062   1        //Hardware_DelayMs(1)          ;
1063   1        
1064   1        //WriteRawRC(CommandReg,PCD_SLEEP);
1065   1      }
1066          
1067          void MFC_WAKEUP(void)
1068          { 
1069   1        SET_MFC_RST_H;
1070   1        Hardware_DelayMs(1);
1071   1      /*  
1072   1        WriteRawRC(RFCfgReg,0x78)     ; 
1073   1        WriteRawRC(GsNReg,0xFF)     ; 
1074   1        WriteRawRC(CWGsCfgReg,0x3F)   ; 
1075   1        WriteRawRC(ModGsCfgReg,0x3F)     ; 
1076   1          
1077   1          
1078   1        WriteRawRC(ModeReg,0x3D)       ;
1079   1        WriteRawRC(TReloadRegL,30)       ;
1080   1        WriteRawRC(TReloadRegH,0)      ;
1081   1      
1082   1        WriteRawRC(TModeReg,0x8D)      ;
1083   1        WriteRawRC(TPrescalerReg,0x3E)     ;  
1084   1      */
1085   1        
1086   1        DEBUG_MARK;
1087   1      }
1088          
1089          
1090          void MFC_Init(void)
1091          {
1092   1        PcdReset();//复位RC522
1093   1        //PcdAntennaOn();//开启天线发射 
1094   1        PcdAntennaOff();
1095   1        
1096   1        DEBUG_MARK;
1097   1      }
1098          
1099          
1100          void MFC_Test(void)
1101          {
1102   1             uint8_t i;
1103   1              TestVal = 0x00;
1104   1             DEBUG_MARK;
1105   1        TestVal = ReadRawRC(RFCfgReg);//,0x78)       ; 
1106   1        DEBUG_MARK;
C51 COMPILER V9.60.0.0   MFC_WS1850                                                        05/16/2023 16:36:56 PAGE 19  

1107   1        TestVal = ReadRawRC(GsNReg);//,0xFF)        ; 
1108   1        DEBUG_MARK;
1109   1        TestVal = ReadRawRC(CWGsCfgReg);//,0x3F)     ; 
1110   1        DEBUG_MARK;
1111   1        TestVal = ReadRawRC(ModGsCfgReg);//,0x3F)     ; 
1112   1        DEBUG_MARK;
1113   1        
1114   1        TestVal = ReadRawRC(ModeReg);//,0x3D)             ;
1115   1        DEBUG_MARK;
1116   1        TestVal = ReadRawRC(TReloadRegL);//,30)           ;
1117   1        DEBUG_MARK;
1118   1        TestVal = ReadRawRC(TReloadRegH);//,0)            ;
1119   1        DEBUG_MARK;
1120   1        
1121   1        TestVal = ReadRawRC(TModeReg);//,0x8D)            ;
1122   1        DEBUG_MARK;
1123   1        TestVal = ReadRawRC(TPrescalerReg);//,0x3E)       ;
1124   1        DEBUG_MARK;
1125   1          TestVal = ReadRawRC(TPrescalerReg);//,0x3E)       ;
1126   1        DEBUG_MARK;
1127   1          TestVal = ReadRawRC(TPrescalerReg);//,0x3E)       ;
1128   1        DEBUG_MARK;
1129   1        //PcdAntennaOn();//开启天线发射 
1130   1        //Hardware_DelayMs(1);
1131   1        //Find_Card();
1132   1        //PcdAntennaOff();
1133   1         for(i=0; i<10; i++)
1134   1          TestBuff[i]=i;
1135   1          
1136   1         for(i=0; i<10; i++)
1137   1            WriteRawRC(FIFODataReg,TestBuff[i])          ; // 数据写入FIFO 
1138   1        DEBUG_MARK;     
1139   1        for(i=0; i<10; i++)
1140   1          TestBuff[i]=0xFF;   
1141   1        DEBUG_MARK; 
1142   1        
1143   1        //i=0;  
1144   1        
1145   1        TestVal = (FIFODataReg<<1)|0x80;
1146   1        for(i=0; i<10; i++)
1147   1        {
1148   2          
1149   2          TestBuff[i] = ReadRawRC(FIFODataReg)          ; //
1150   2          /*
1151   2          SET_MFC_CS_L;
1152   2          Hardware_DelayX1us(100);
1153   2        
1154   2          HAL_SPI_Transmit(&hspi2,&TestVal,1,10);
1155   2          Hardware_DelayMs(10);
1156   2          HAL_SPI_Receive(&hspi2,&TestBuff[i],1,10);
1157   2        //  HAL_STATUS = HAL_SPI_TransmitReceive(&hspi2,&ucResult,&ReadData,1,500);
1158   2          Hardware_DelayMs(10);
1159   2          SET_MFC_CS_H;
1160   2      
1161   2        //  Hardware_DelayMs(10);
1162   2          Hardware_DelayX1us(100);
1163   2          */
1164   2          DEBUG_MARK;   
1165   2        }   
1166   1      }


C51 COMPILER V9.60.0.0   MFC_WS1850                                                        05/16/2023 16:36:56 PAGE 20  

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3539    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     52     503
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

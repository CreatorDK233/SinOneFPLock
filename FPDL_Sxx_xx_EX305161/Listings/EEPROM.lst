C51 COMPILER V9.60.0.0   EEPROM                                                            05/16/2023 14:42:14 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE EEPROM
OBJECT MODULE PLACED IN .\Objects\EEPROM.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Drivers\Protocol\EEPROM.c LARGE OMF2 OPTIMIZE(9,SPEED) BROWSE INCDIR(.\D
                    -rivers\Lib\c;.\Drivers\Lib\H;.\Drivers\Lib\IAP_Lib;.\Drivers\Lib\TouchKey_lib;.\Drivers\Physical;.\Drivers\Protocol;.\So
                    -ftwares\Application;.\Softwares\Basic;.\Softwares\ModuleLogic) DEBUG PRINT(.\Listings\EEPROM.lst) TABS(2) OBJECT(.\Objec
                    -ts\EEPROM.obj)

line level    source

   1          #include "EEPROM.h"
   2          #include "IAP_Option_EW.h"
   3          #include "Function_Init.H"
   4          
   5          #define DEF_InternalEEPROM_SectorSize           512 //Required _size of a sector
   6          
   7          void EEPROM_ReadSequential(uint16_t StartAddr,uint8_t *BUFF,uint16_t Num)
   8          {
   9   1        while( Num-- )
  10   1        {
  11   2          *BUFF = IAP_Read(StartAddr, IAP_EEPROM);    //¶ÁÈ¡EEPROMÊý¾Ý
  12   2          BUFF++;
  13   2          StartAddr++;
  14   2        }
  15   1      }
  16          
  17          void EEPROM_WriteSequential(uint16_t StartAddr,uint8_t *BUFF,uint16_t Num)
  18          {
  19   1        uint8_t SectorDATA[DEF_InternalEEPROM_SectorSize]={0};
  20   1        uint16_t i=0;
  21   1        uint16_t OffsetByte;
  22   1        uint16_t CurrentByte;
  23   1        uint16_t SavedByteNum;
  24   1        uint16_t Addr;
  25   1        SavedByteNum = 0;
  26   1        Addr=StartAddr;
  27   1        
  28   1        for (;;)
  29   1        {
  30   2            if ( Num > SavedByteNum)
  31   2            {
  32   3                OffsetByte = Addr%DEF_InternalEEPROM_SectorSize;
  33   3                if ( Num > (SavedByteNum+DEF_InternalEEPROM_SectorSize-OffsetByte) )//ÅÐ¶ÏÐ´Êý¾ÝÊÇ·ñ³¬³öµ±Ç°ÉÈÇø
  34   3                {
  35   4                  if( OffsetByte != 0 )
  36   4                  {
  37   5                    EEPROM_ReadSequential((Addr-OffsetByte),SectorDATA,DEF_InternalEEPROM_SectorSize);//È¡³öSectorÔ­Êý¾
             -Ý
  38   5                    Soft_Delay1ms(1);
  39   5                  }
  40   4            
  41   4                  CurrentByte=OffsetByte;
  42   4                  for( i=0 ; i<( DEF_InternalEEPROM_SectorSize-OffsetByte ) ; i++ )//¸üÐÂ¸ÃÉÈÇøÐèÒª´æ´¢µÄÊý¾Ý
  43   4                  {
  44   5                    SectorDATA[CurrentByte]=*BUFF;
  45   5                    CurrentByte++;
  46   5                    BUFF++;
  47   5                  }
  48   4                  IAP_EEPROMSectorEraseOption(Addr-OffsetByte);//²Á³ýµ±Ç°ÉÈÇøËùÓÐÊý¾Ý
  49   4                  EEPROM_PageWrite(Addr-OffsetByte,SectorDATA,DEF_InternalEEPROM_SectorSize);//Ð´Èëµ±Ç°ÉÈÇøÐÂÊý¾Ý
  50   4                  SavedByteNum+=(DEF_InternalEEPROM_SectorSize-OffsetByte);
  51   4                  Addr+=(DEF_InternalEEPROM_SectorSize-OffsetByte);
C51 COMPILER V9.60.0.0   EEPROM                                                            05/16/2023 14:42:14 PAGE 2   

  52   4                  Soft_Delay1ms(5);
  53   4                }
  54   3                else
  55   3                {
  56   4                  EEPROM_ReadSequential((Addr-OffsetByte),SectorDATA,DEF_InternalEEPROM_SectorSize);//È¡³öSectorÔ­Êý¾Ý
  57   4                  Soft_Delay1ms(1);
  58   4                  CurrentByte=OffsetByte;
  59   4                  for( i=0 ; i<( Num-SavedByteNum ) ; i++ )//¸üÐÂ¸ÃÉÈÇøÐèÒª´æ´¢µÄÊý¾Ý
  60   4                  {
  61   5                    SectorDATA[CurrentByte]=*BUFF;
  62   5                    CurrentByte++;
  63   5                    BUFF++;
  64   5                  }
  65   4                  IAP_EEPROMSectorEraseOption(Addr-OffsetByte);//²Á³ýµ±Ç°ÉÈÇøËùÓÐÊý¾Ý
  66   4                  EEPROM_PageWrite(Addr-OffsetByte,SectorDATA,DEF_InternalEEPROM_SectorSize);//Ð´Èëµ±Ç°ÉÈÇøÐÂÊý¾Ý
  67   4                  SavedByteNum = Num;
  68   4                  Soft_Delay1ms(5);
  69   4                  break;
  70   4                }
  71   3            }
  72   2        } 
  73   1      }
  74          
  75          void EEPROM_PageWrite(uint16_t StartAddr,uint8_t *BUFF,uint16_t Num)//Ê¹ÓÃÇ°±ØÐëÏÈ²ÁÔÙÐ´
  76          {
  77   1        while( Num-- )
  78   1        {
  79   2          IAP_EEPROMProgramByteOption(StartAddr, *BUFF);    //ÍùEEPROM µØÖ·Ð´Èë
  80   2          BUFF++;
  81   2          StartAddr++;
  82   2        }
  83   1      }
  84          
  85          
  86          void EEPROM_TESTING(void)
  87          {
  88   1        //uint16_t i;
  89   1      
  90   1        //EEPROM_WriteSequential(VolumeSwitchStartAddr,&BUFFA,2);
  91   1        
  92   1        //EEPROM_ReadSequential(VolumeSwitchStartAddr,&BUFFB,1);
  93   1        
  94   1        //EEPROM_ReadSequential(VolumeSwitchStartAddr,&BUFFB,2);
  95   1      
  96   1      }
  97          
  98          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    677    ----
   CONSTANT SIZE    =    512    ----
   XDATA SIZE       =   ----     543
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.60.0.0   EEPROM                                                            05/16/2023 14:42:14 PAGE 3   


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.60.0.0   BEEPMGR                                                           04/26/2023 11:06:25 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE BEEPMGR
OBJECT MODULE PLACED IN .\Objects\BeepMgr.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Drivers\Protocol\BeepMgr.c LARGE OMF2 OPTIMIZE(9,SPEED) BROWSE INCDIR(.\
                    -Drivers\Lib\c;.\Drivers\Lib\H;.\Drivers\Lib\IAP_Lib;.\Drivers\Lib\TouchKey_lib;.\Drivers\Physical;.\Drivers\Protocol;.\S
                    -oftwares\Application;.\Softwares\Basic;.\Softwares\ModuleLogic;.\Drivers\Protocol\YC_NFC;.\Drivers\Protocol\WIFI_Tuya) D
                    -EBUG PRINT(.\Listings\BeepMgr.lst) TABS(2) OBJECT(.\Objects\BeepMgr.obj)

line level    source

   1          #include "IO.h"
   2          #include "global_variable.h"
   3          #include "BeepMgr.h"
   4          
   5          void PLAY_VOICE_ONESEGMENT(uint8_t segment)
   6          {
   7   1        uint8_t Buff[2];
   8   1      
   9   1        Buff[0]= segment;
  10   1        Buff[1]= DEF_VoiceSegmentEndFlag;
  11   1        PLAY_VOICE_MULTISEGMENTS(Buff);
  12   1      }
  13          
  14          void PLAY_VOICE_TWOSEGMENT(uint8_t segment1,uint8_t segment2)
  15          {
  16   1        uint8_t Buff[3];
  17   1      
  18   1        Buff[0]= segment1;
  19   1        Buff[1]= segment2;
  20   1        Buff[2]= DEF_VoiceSegmentEndFlag;
  21   1        PLAY_VOICE_MULTISEGMENTS(Buff);
  22   1      
  23   1      }
  24          
  25          void PLAY_VOICE_THREESEGMENT(uint8_t segment1,uint8_t segment2,uint8_t segment3)
  26          {
  27   1        uint8_t Buff[4];
  28   1      
  29   1        Buff[0]= segment1;
  30   1        Buff[1]= segment2;
  31   1        Buff[2]= segment3;
  32   1        Buff[3]= DEF_VoiceSegmentEndFlag;
  33   1        PLAY_VOICE_MULTISEGMENTS(Buff);
  34   1      }
  35          
  36          void PLAY_VOICE_MULTISEGMENTS(uint8_t BUFF[])
  37          {
  38   1        uint8_t SegmentCnt;
  39   1        
  40   1        if (  ( VoiceMgr.Enable == bFALSE)&&
  41   1            ( ( CurrentScreen == SCREEN_Main)
  42   1              ||( CurrentScreen == SCREEN_IdentifySuccess)
  43   1              ||( CurrentScreen == SCREEN_IdentifyFail)
  44   1            )
  45   1          )
  46   1        {
  47   2          return;
  48   2        }
  49   1        VoiceDataTransferMgr.DataBuff[0] = 0xfe;
  50   1        for ( SegmentCnt =0;SegmentCnt<49;SegmentCnt++)
  51   1        {
  52   2          if ( BUFF[SegmentCnt] == DEF_VoiceSegmentEndFlag ){break;}
C51 COMPILER V9.60.0.0   BEEPMGR                                                           04/26/2023 11:06:25 PAGE 2   

  53   2          VoiceDataTransferMgr.DataBuff[2*SegmentCnt+1] = 0xF3; //Continue play
  54   2          VoiceDataTransferMgr.DataBuff[2*SegmentCnt+2] = BUFF[SegmentCnt]+SystemLanguage; //Continue play
  55   2          //VoiceDataTransferMgr.DataBuff[2*SegmentCnt+2] = BUFF[SegmentCnt]; //Continue play
  56   2        }
  57   1        VoiceDataTransferMgr.BitPoint = 0x00;
  58   1        VoiceDataTransferMgr.SendDataNum = 0;
  59   1        VoiceDataTransferMgr.TotalDataNum = 2*SegmentCnt+1;
  60   1        VoiceDataTransferMgr.Status = SendingDataStart;
  61   1        VoiceDataTransferMgr.VoicePlayEndCnt=0;
  62   1        VoiceDataTransferMgr.VoicePlayEnd = bFALSE;
  63   1      }
  64          
  65          //使用FIXED后缀时，无需切换中英文
  66          void PLAY_VOICE_ONESEGMENT_FIXED(uint8_t segment)
  67          {
  68   1        if (  ( VoiceMgr.Enable == bFALSE)&&
  69   1            ( ( CurrentScreen == SCREEN_Main )
  70   1              ||( CurrentScreen == SCREEN_IdentifySuccess)
  71   1              ||( CurrentScreen == SCREEN_IdentifyFail)
  72   1            )
  73   1          )
  74   1        {
  75   2          return;
  76   2        }
  77   1        VoiceDataTransferMgr.DataBuff[0]= segment;
  78   1        VoiceDataTransferMgr.BitPoint = 0x00;
  79   1        VoiceDataTransferMgr.SendDataNum = 0;
  80   1        VoiceDataTransferMgr.TotalDataNum = 1;
  81   1        VoiceDataTransferMgr.Status = SendingDataStart;
  82   1        VoiceDataTransferMgr.VoicePlayEndCnt=0;
  83   1        VoiceDataTransferMgr.VoicePlayEnd = bFALSE;
  84   1      }
  85          
  86          void PLAY_VOICE_TWOSEGMENT_FIXED(uint8_t segment1,uint8_t segment2)
  87          {
  88   1        uint8_t Buff[4];
  89   1      
  90   1        Buff[0]= segment1;
  91   1        Buff[1]= segment2;
  92   1        Buff[2]= DEF_VoiceSegmentEndFlag;
  93   1        PLAY_VOICE_MULTISEGMENTS_FIXED(Buff);
  94   1      }
  95          
  96          void PLAY_VOICE_THREESEGMENT_FIXED(uint8_t segment1,uint8_t segment2,uint8_t segment3)
  97          {
  98   1        uint8_t Buff[4];
  99   1      
 100   1        Buff[0]= segment1;
 101   1        Buff[1]= segment2;
 102   1        Buff[2]= segment3;
 103   1        Buff[3]= DEF_VoiceSegmentEndFlag;
 104   1        PLAY_VOICE_MULTISEGMENTS_FIXED(Buff);
 105   1      }
 106          
 107          void PLAY_VOICE_MULTISEGMENTS_FIXED(uint8_t BUFF[])
 108          {
 109   1        uint8_t SegmentCnt;
 110   1        
 111   1        if (  ( VoiceMgr.Enable == bFALSE)&&
 112   1            ( ( CurrentScreen == SCREEN_Main)
 113   1              ||( CurrentScreen == SCREEN_IdentifySuccess)
 114   1              ||( CurrentScreen == SCREEN_IdentifyFail)
C51 COMPILER V9.60.0.0   BEEPMGR                                                           04/26/2023 11:06:25 PAGE 3   

 115   1            )
 116   1          )
 117   1        {
 118   2          return;
 119   2        }
 120   1        VoiceDataTransferMgr.DataBuff[0] = 0xfe;
 121   1        for ( SegmentCnt =0;SegmentCnt<49;SegmentCnt++)
 122   1        {
 123   2          if ( BUFF[SegmentCnt] == DEF_VoiceSegmentEndFlag ){break;}
 124   2          VoiceDataTransferMgr.DataBuff[2*SegmentCnt+1] = 0xF3; //Continue play
 125   2          VoiceDataTransferMgr.DataBuff[2*SegmentCnt+2] = BUFF[SegmentCnt]; //Continue play
 126   2        }
 127   1        VoiceDataTransferMgr.BitPoint = 0x00;
 128   1        VoiceDataTransferMgr.SendDataNum = 0;
 129   1        VoiceDataTransferMgr.TotalDataNum = 2*SegmentCnt+1;
 130   1        VoiceDataTransferMgr.Status = SendingDataStart;
 131   1        VoiceDataTransferMgr.VoicePlayEndCnt=0;
 132   1        VoiceDataTransferMgr.VoicePlayEnd = bFALSE;
 133   1      }
 134          
 135          void SET_VOLUME(uint8_t volume)
 136          {
 137   1        PLAY_VOICE_ONESEGMENT_FIXED(0xE0+volume);
 138   1      }
 139          
 140          void STOP_VOICEPLAY(void)
 141          {
 142   1        PLAY_VOICE_ONESEGMENT_FIXED(0xFE);
 143   1      }
 144          
 145          void VoicePlayerPowerDown(void)
 146          {
 147   1        SET_VOICEDATA_SLEEP;
 148   1        SET_VOICEBUSY_SLEEP;
 149   1      }
 150          
 151          void PLAY_VOICE_DOORBELL(void)
 152          {
 153   1        if ( VoiceDataTransferMgr.Status != VoiceIdle )
 154   1        {
 155   2          return;
 156   2        }
 157   1        VoiceDataTransferMgr.DataBuff[0] = 0xfe;
 158   1        VoiceDataTransferMgr.DataBuff[1]= 0xF3;
 159   1        VoiceDataTransferMgr.DataBuff[2]= VOICE_Doorbell;
 160   1        VoiceDataTransferMgr.DataBuff[3]= 0xF3;
 161   1        VoiceDataTransferMgr.DataBuff[4]= VOICE_Doorbell;
 162   1        VoiceDataTransferMgr.BitPoint = 0x00;
 163   1        VoiceDataTransferMgr.SendDataNum = 0;
 164   1        VoiceDataTransferMgr.TotalDataNum = 5;
 165   1        VoiceDataTransferMgr.Status = SendingDataStart;
 166   1        VoiceDataTransferMgr.VoicePlayEndCnt=0;
 167   1        VoiceDataTransferMgr.VoicePlayEnd = bFALSE;
 168   1      }
 169          
 170          /*void PLAY_VOICE2_ONESEGMENT(uint8_t segment)
 171          {
 172            VoiceDataTransferMgr2.BitPoint = 0x00;
 173            VoiceDataTransferMgr2.DataBuff[0] = segment;
 174            VoiceDataTransferMgr2.SendDataNum = 1;
 175            VoiceDataTransferMgr2.Status = SendingDataStart;
 176          }
C51 COMPILER V9.60.0.0   BEEPMGR                                                           04/26/2023 11:06:25 PAGE 4   

 177          
 178          void PLAY_VOICE2_TWOSEGMENT(uint8_t segment1,uint8_t segment2)
 179          {
 180            if ( VoiceMgr.Enable == bTRUE)
 181            {
 182              VoiceDataTransferMgr2.BitPoint = 0x00;
 183              VoiceDataTransferMgr2.DataBuff[3] = 0xF3;
 184              VoiceDataTransferMgr2.DataBuff[2] = segment1;
 185              VoiceDataTransferMgr2.DataBuff[1] = 0xF3;
 186              VoiceDataTransferMgr2.DataBuff[0] = segment2;
 187              VoiceDataTransferMgr2.SendDataNum = 4;
 188              VoiceDataTransferMgr2.Status = SendingDataStart;
 189            }
 190          }
 191          
 192          void PLAY_VOICE2_DOORBELL(void)
 193          {
 194            VoiceDataTransferMgr2.BitPoint = 0x00;
 195            VoiceDataTransferMgr2.DataBuff[3] = 0xF3;
 196            VoiceDataTransferMgr2.DataBuff[2] = VOICE_Doorbell;
 197            VoiceDataTransferMgr2.DataBuff[1] = 0xF3;
 198            VoiceDataTransferMgr2.DataBuff[0] = VOICE_Doorbell;
 199            VoiceDataTransferMgr2.SendDataNum = 4;
 200            VoiceDataTransferMgr2.Status = SendingDataStart;
 201          }
 202          
 203          void PLAY_VOICE2_CONTINUE(uint8_t segment)
 204          {
 205            VoiceDataTransferMgr2.BitPoint = 0x00;
 206            VoiceDataTransferMgr2.DataBuff[1] = segment;
 207            VoiceDataTransferMgr2.DataBuff[0] = 0xF2;
 208            VoiceDataTransferMgr2.SendDataNum = 2;
 209            VoiceDataTransferMgr2.Status = SendingDataStart;
 210          }
 211          
 212          void STOP_VOICEPLAY2(void)
 213          {
 214            VoiceDataTransferMgr2.BitPoint = 0x00;
 215            VoiceDataTransferMgr2.DataBuff[0] = 0xFE;
 216            VoiceDataTransferMgr2.SendDataNum = 1;
 217            VoiceDataTransferMgr2.Status = SendingDataStart;
 218          }*/
 219          
 220          void VOICE_Init(void)
 221          {
 222   1        VoiceDataTransferMgr.PulseWidthCnt = 0;
 223   1        VoiceDataTransferMgr.Status = VoiceIdle;
 224   1        //VoiceDataTransferMgr2.PulseWidthCnt = 0;  
 225   1        //VoiceDataTransferMgr2.Status = VoiceIdle; 
 226   1      }
 227          
 228          void BeepMgrTask(void)
 229          {
 230   1        if ( VoiceDataTransferMgr.PulseWidthCnt > 0 )
 231   1          {
 232   2            VoiceDataTransferMgr.PulseWidthCnt--;
 233   2          }
 234   1          
 235   1          if ( VoiceDataTransferMgr.PulseWidthCnt == 0 )
 236   1          {
 237   2            switch ( VoiceDataTransferMgr.Status )
 238   2            {
C51 COMPILER V9.60.0.0   BEEPMGR                                                           04/26/2023 11:06:25 PAGE 5   

 239   3              default:
 240   3                
 241   3              case VoiceIdle:
 242   3                SET_VOICEDATA_H;
 243   3      
 244   3                if ( STATUS_PINMACRO_VOICEBUSY != 0 )
 245   3                { 
 246   4                  if ( VoiceDataTransferMgr.VoicePlayEndCnt < 1500)
 247   4                  {
 248   5                    VoiceDataTransferMgr.VoicePlayEndCnt++;
 249   5                  }
 250   4                  else{
 251   5                    VoiceDataTransferMgr.VoicePlayEnd = bTRUE;
 252   5                  }
 253   4                  DEBUG_MARK;
 254   4                }
 255   3                else
 256   3                {
 257   4                  VoiceDataTransferMgr.VoicePlayEndCnt=0;
 258   4                  VoiceDataTransferMgr.VoicePlayEnd = bFALSE;
 259   4                  DEBUG_MARK;
 260   4                }
 261   3                break;  
 262   3                  
 263   3              case SendingDataStart:
 264   3      //  
 265   3      //          if ( STATUS_PINMACRO_VOICEDATA != 0 )
 266   3      //          {
 267   3      //            SET_VOICEDATA_L;
 268   3      //            VoiceDataTransferMgr.PulseWidthCnt = 17;  //5.1ms
 269   3      //          }
 270   3      //          else
 271   3      //          {
 272   3      //            VoiceDataTransferMgr.Status =  SendingData;//SendingData;
 273   3      //            VoiceDataTransferMgr.Data = VoiceDataTransferMgr.DataBuff[VoiceDataTransferMgr.SendDataNum];
 274   3      //          }
 275   3                  SET_VOICEDATA_L;
 276   3                  VoiceDataTransferMgr.PulseWidthCnt = 27;
 277   3                  VoiceDataTransferMgr.Status =  SendingData;//SendingData;
 278   3                  VoiceDataTransferMgr.Data = VoiceDataTransferMgr.DataBuff[VoiceDataTransferMgr.SendDataNum];
 279   3                  
 280   3                break;
 281   3                
 282   3              case SendingData:
 283   3        
 284   3                  if ( STATUS_PINMACRO_VOICEDATA == 0 ) //send High level
 285   3                  {
 286   4                    SET_VOICEDATA_H;
 287   4                    if ( (VoiceDataTransferMgr.Data&0x01) != 0x00)
 288   4                    {
 289   5                      VoiceDataTransferMgr.PulseWidthCnt = 3; //900US
 290   5                      DEBUG_MARK;
 291   5                    }
 292   4                    else
 293   4                    {
 294   5                      VoiceDataTransferMgr.PulseWidthCnt = 1; //300US
 295   5                      DEBUG_MARK;
 296   5                    }
 297   4                  }
 298   3                  else    //send low level
 299   3                  {
 300   4                    SET_VOICEDATA_L;
C51 COMPILER V9.60.0.0   BEEPMGR                                                           04/26/2023 11:06:25 PAGE 6   

 301   4                    if ( (VoiceDataTransferMgr.Data&0x01) != 0x00)
 302   4                    {
 303   5                      VoiceDataTransferMgr.PulseWidthCnt = 1; //300US
 304   5                    }
 305   4                    else
 306   4                    {
 307   5                      VoiceDataTransferMgr.PulseWidthCnt = 3; //900US
 308   5                    }
 309   4                    VoiceDataTransferMgr.Data>>=1;
 310   4        
 311   4                    if ( ++VoiceDataTransferMgr.BitPoint >=8 )
 312   4                    {
 313   5                      VoiceDataTransferMgr.Status = SendingDataEnd;
 314   5                      DEBUG_MARK;
 315   5                    }
 316   4                  }
 317   3                break;
 318   3                
 319   3                case SendingDataEnd:  
 320   3                  
 321   3                  SET_VOICEDATA_H;
 322   3                
 323   3                  VoiceDataTransferMgr.SendDataNum++;
 324   3                
 325   3                  if (VoiceDataTransferMgr.SendDataNum < VoiceDataTransferMgr.TotalDataNum )
 326   3                  {
 327   4                    VoiceDataTransferMgr.Status = ContinueSendData;
 328   4                    VoiceDataTransferMgr.PulseWidthCnt = 10; //3MS
 329   4                  }
 330   3                  else
 331   3                  {
 332   4                    VoiceDataTransferMgr.Status = VoiceIdle;
 333   4                    VoiceDataTransferMgr.PulseWidthCnt = 333; //100MS
 334   4                  }
 335   3                  
 336   3                  
 337   3                  DEBUG_MARK;
 338   3                break;  
 339   3                
 340   3                case ContinueSendData:  
 341   3      
 342   3                  //if ( STATUS_PINMACRO_VOICEBUSY != 0 )
 343   3                  {
 344   4                    VoiceDataTransferMgr.Status = SendingDataStart;
 345   4                    VoiceDataTransferMgr.BitPoint = 0x00;
 346   4                  }
 347   3      
 348   3                  DEBUG_MARK;
 349   3                break;  
 350   3                
 351   3            }
 352   2          }
 353   1        return;
 354   1      
 355   1      }
 356          
 357          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    757    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V9.60.0.0   BEEPMGR                                                           04/26/2023 11:06:25 PAGE 7   

   XDATA SIZE       =   ----      23
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

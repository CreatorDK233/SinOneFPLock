C51 COMPILER V9.60.0.0   USART                                                             05/09/2023 14:43:37 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE USART
OBJECT MODULE PLACED IN .\Objects\usart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Drivers\Physical\usart.c LARGE OMF2 OPTIMIZE(9,SPEED) BROWSE INCDIR(.\Dr
                    -ivers\Lib\c;.\Drivers\Lib\H;.\Drivers\Lib\IAP_Lib;.\Drivers\Lib\TouchKey_lib;.\Drivers\Physical;.\Drivers\Protocol;.\Sof
                    -twares\Application;.\Softwares\Basic;.\Softwares\ModuleLogic;.\Drivers\Protocol\YC_NFC;.\Drivers\Protocol\WIFI_Tuya) DEB
                    -UG PRINT(.\Listings\usart.lst) TABS(2) OBJECT(.\Objects\usart.obj)

line level    source

   1          #include "usart.h"
   2          #include "ISR.h"
   3          #include "Project.h"
   4          #include "SC95F861xB_C.H"
   5          
   6          //选择三合一模块：
   7          #define  USCI2   2
   8          #define  USCI3   3
   9          #define  USCI4   4
  10          #define  USCI5   5
  11          
  12          //选择三合一模式：
  13          #define  UartX   0
  14          #define  TWIX    1
  15          #define  SPIX    2
  16          
  17          //uint16_t uart3_rx_count=0;
  18          //uint8_t xdata Uart3_Rx[UART_MAX_LEN];
  19          //uint16_t uart1_rx_count=0;
  20          //uint8_t xdata Uart1_Rx[UART_MAX_LEN];
  21          bit Uart1SendFlag = 0;    //Uart1发送中断标志位
  22          bit Uart1ReceiveFlag = 0; //Uart1接收中断标志位
  23          bit Uart2SendFlag = 0;    //Uart2发送中断标志位
  24          bit Uart2ReceiveFlag = 0; //Uart2接收中断标志位
  25          bit Uart3SendFlag = 0;
  26          bit Uart3ReceiveFlag = 0;
  27          
  28          #define   Choose_SSI2   SSIxx_Select = USCI2; /*SSIxx_Mode = UartX;*/ USXINX = SSIxx_Select
  29          #define   Choose_SSI3   SSIxx_Select = USCI3; /*SSIxx_Mode = UartX;*/ USXINX = SSIxx_Select
  30          
  31          #define   Uart1_send_OK   while(!Uart1SendFlag); Uart1SendFlag = 0
  32          #define   Uart2_send_OK   while(!Uart2SendFlag); Uart2SendFlag = 0//while( !(USXCON0 & 0x02) ); USXCON0 |= 0
             -x02
  33          #define   Uart3_send_OK   while(!Uart3SendFlag); Uart3SendFlag = 0//while( !(USXCON0 & 0x02) ); USXCON0 |= 0
             -x02
  34          
  35          #define   USXINX_Clear  //USXINX = 0
  36          //uart1,wifi
  37          void MX_UART1_Init(void)
  38          {
  39   1        Uart1_Init(32,115200);
  40   1      }
  41          void MX_UART1_DeInit(void)
  42          {
  43   1        OTCON &=~ 0xC0;//关闭USART0
  44   1        IE2   &=~ 0x01;//关闭串口中断
  45   1      }
  46          //uart2,FPM
  47          void MX_UART2_Init(void)
  48          {
  49   1        Choose_SSI2;
  50   1        UARTX_Init(32, 57600);
C51 COMPILER V9.60.0.0   USART                                                             05/09/2023 14:43:37 PAGE 2   

  51   1        //IP2 |= 0x02;
  52   1        USXINX_Clear;
  53   1      }
  54          void MX_UART2_DeInit(void)
  55          {
  56   1        Choose_SSI2;
  57   1        TMCON &= 0x3F;
  58   1        IE2 &= ~0x02;  
  59   1        //IP2 &= ~0x02;
  60   1        USXINX_Clear;
  61   1      }
  62          //uart3
  63          void MX_UART3_Init(void)
  64          {
  65   1        Choose_SSI3;
  66   1        UARTX_Init(32, 115200);
  67   1        USXINX_Clear;
  68   1      }
  69          void MX_UART3_DeInit(void)
  70          {
  71   1        Choose_SSI3;
  72   1        TMCON &= 0x3F;
  73   1        IE2 &= ~0x04;  
  74   1        USXINX_Clear; 
  75   1      }
  76          ////uart5
  77          //void MX_USART5_UART_Init(void)
  78          //{
  79          //  Choose_SSI5;
  80          //  uart5_rx_count=0;
  81          //  UARTX_Init(32, 115200);
  82          //  USXINX_Clear;
  83          //}
  84          //void UART5_DeInit(void)
  85          //{
  86          //  Choose_SSI5;
  87          //  TMCON &= 0x3F;
  88          //  IE2 &= ~0x10;  
  89          //  USXINX_Clear; 
  90          //}
  91          /*******************************串口1发送单字节*/
  92          void Uart1SendByte(uint8_t dat)
  93          {
  94   1         US1CON3 = dat;
  95   1         Uart1_send_OK;
  96   1      }
  97          /******************************串口1发送字符串*/
  98          void Uart1SendStr(uint8_t *pstr,uint16_t strlen)
  99          {
 100   1        if((NULL == pstr)||(0 == strlen))
 101   1        {
 102   2          return;
 103   2        }
 104   1        while(strlen--)
 105   1        {
 106   2          Uart1SendByte(*pstr);
 107   2          pstr++;
 108   2        }
 109   1      }
 110          /******************************串口1读取单字节*/
 111          void Uart1ReadByte(uint8_t *dat)
 112          {
C51 COMPILER V9.60.0.0   USART                                                             05/09/2023 14:43:37 PAGE 3   

 113   1         *dat = US1CON3;
 114   1      }
 115          /*******************************串口2发送字节*/
 116          void Uart2SendByte(uint8_t dat)
 117          {
 118   1        Choose_SSI2;
 119   1        USXCON3 = dat;
 120   1        Uart2_send_OK;
 121   1        //Soft_Delay_usS(5);
 122   1        USXINX_Clear;
 123   1      }
 124          /******************************串口2发送字符串*/
 125          void Uart2SendStr(uint8_t *pstr,uint16_t strlen)
 126          {
 127   1        if((NULL == pstr)||(0 == strlen))
 128   1        {
 129   2          return;
 130   2        }
 131   1      //  Choose_SSI2;
 132   1        while(strlen--)
 133   1        {
 134   2          Uart2SendByte(*pstr);
 135   2      //    USXCON3 = *pstr;
 136   2      //    Uart2_send_OK;
 137   2          pstr++;
 138   2        }
 139   1      //  USXINX_Clear;
 140   1      }
 141          /******************************串口2读取单字节*/
 142          void Uart2ReadByte(uint8_t *dat)
 143          {
 144   1        Choose_SSI2;
 145   1        *dat = USXCON3;
 146   1        USXINX_Clear;
 147   1      }
 148          /*******************************串口3发送字节*/
 149          void Uart3SendByte(uint8_t dat)
 150          {
 151   1        Choose_SSI3;
 152   1        USXCON3 = dat;
 153   1        Uart3_send_OK;
 154   1        USXINX_Clear;
 155   1      }
 156          /******************************串口3发送字符串*/
 157          void Uart3SendStr(uint8_t *pstr,uint16_t strlen)
 158          {
 159   1        if((NULL == pstr)||(0 == strlen))
 160   1        {
 161   2          return;
 162   2        }
 163   1        while(strlen--)
 164   1        {
 165   2          Uart3SendByte(*pstr);
 166   2      
 167   2          pstr++;
 168   2        }
 169   1      }
 170          /******************************串口3读取单字节*/
 171          void Uart3ReadByte(uint8_t *dat)
 172          {
 173   1        Choose_SSI3;
 174   1        *dat = USXCON3;
C51 COMPILER V9.60.0.0   USART                                                             05/09/2023 14:43:37 PAGE 4   

 175   1        USXINX_Clear;
 176   1      }
 177          ///*******************************串口5发送字节*/
 178          //void Uart5SendByte(uint8_t dat)
 179          //{
 180          //  Choose_SSI5;
 181          //  USXCON3 = dat;
 182          //  Uart5_send_OK;
 183          //  USXINX_Clear;
 184          //}
 185          ///******************************串口5发送字符串*/
 186          //void Uart5SendStr(uint8_t *pstr,uint16_t strlen)
 187          //{
 188          //  if((NULL == pstr)||(0 == strlen))
 189          //  {
 190          //    return;
 191          //  }
 192          ////  Choose_SSI5;
 193          //  while(strlen--)
 194          //  {
 195          //    Uart5SendByte(*pstr);
 196          ////    USXCON3 = *pstr;
 197          ////    Uart5_send_OK;
 198          //    pstr++;
 199          //  }
 200          ////  USXINX_Clear;
 201          //}
 202          
 203          void UART1_Int() interrupt 15   //Uart1中断函数
 204          {
 205   1        if(US1CON0&0x02)    //发送标志位判断
 206   1        {
 207   2          US1CON0 |= 0x02;
 208   2          Uart1SendFlag = 1;
 209   2        }
 210   1        if((US1CON0&0x01))  //接收标志位判断
 211   1        {
 212   2          US1CON0 |= 0x01;
 213   2          UART1_ISR();
 214   2          //Uart1ReceiveFlag = 1;
 215   2        } 
 216   1      }
 217          void UART2_Int() interrupt 16   //Uart2中断函数
 218          {
 219   1      //  uint8_t res;
 220   1        Choose_SSI2;
 221   1        if(USXCON0 & 0x02)  //发送标志位判断TI
 222   1        {
 223   2          USXCON0 |= 0x02;
 224   2          Uart2SendFlag = 1;
 225   2        }
 226   1        if((USXCON0 & 0x01)) //接收标志位判断RI
 227   1        {
 228   2          USXCON0 |= 0x01;
 229   2          
 230   2          UART2_ISR();
 231   2      
 232   2          //Uart2ReceiveFlag = 1;
 233   2        }
 234   1        USXINX_Clear;
 235   1      }
 236          
C51 COMPILER V9.60.0.0   USART                                                             05/09/2023 14:43:37 PAGE 5   

 237          void UART3_Int() interrupt 17   //Uart3中断函数
 238          {
 239   1        Choose_SSI3;
 240   1        if(USXCON0 & 0x02)  //发送标志位判断TI
 241   1        {
 242   2          USXCON0 |= 0x02;
 243   2          Uart3SendFlag = 1;
 244   2        }
 245   1        if((USXCON0 & 0x01)) //接收标志位判断RI
 246   1        {
 247   2          USXCON0 |= 0x01;
 248   2        }
 249   1        USXINX_Clear;
 250   1      }
 251          /*
 252          void UART5_Int() interrupt 19   //Uart5中断函数
 253          {
 254            uint8_t res;
 255            Choose_SSI5;
 256            if(USXCON0 & 0x02)  //发送标志位判断TI
 257            {
 258              USXCON0 |= 0x02;
 259              Uart5SendFlag = 1;
 260            }
 261            if((USXCON0 & 0x01)) //接收标志位判断RI
 262            {
 263              USXCON0 |= 0x01;
 264              res=USXCON3;
 265              Uart5_Rx[uart5_rx_count]=res; 
 266              uart5_rx_count++;
 267              if (uart5_rx_count >= UART5_MAX_LEN) {
 268                  //防止溢出
 269                  uart5_rx_count = 0;
 270              }
 271              Uart5ReceiveFlag = 1;
 272            }
 273            USXINX_Clear;
 274          }*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    535    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----       9
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      6    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
